<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Learning Rust With Entirely Too Many Linked Lists</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Learning Rust With Entirely Too Many Linked Lists">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="first.html"><strong aria-hidden="true">2.</strong> A Bad Stack</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="first-layout.html"><strong aria-hidden="true">2.1.</strong> Layout</a></li><li class="chapter-item expanded "><a href="first-new.html"><strong aria-hidden="true">2.2.</strong> New</a></li><li class="chapter-item expanded "><a href="first-ownership.html"><strong aria-hidden="true">2.3.</strong> Ownership 101</a></li><li class="chapter-item expanded "><a href="first-push.html"><strong aria-hidden="true">2.4.</strong> Push</a></li><li class="chapter-item expanded "><a href="first-pop.html"><strong aria-hidden="true">2.5.</strong> Pop</a></li><li class="chapter-item expanded "><a href="first-test.html"><strong aria-hidden="true">2.6.</strong> Testing</a></li><li class="chapter-item expanded "><a href="first-drop.html"><strong aria-hidden="true">2.7.</strong> Drop</a></li><li class="chapter-item expanded "><a href="first-final.html"><strong aria-hidden="true">2.8.</strong> Final Code</a></li></ol></li><li class="chapter-item expanded "><a href="second.html"><strong aria-hidden="true">3.</strong> An Ok Stack</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="second-option.html"><strong aria-hidden="true">3.1.</strong> Option</a></li><li class="chapter-item expanded "><a href="second-generic.html"><strong aria-hidden="true">3.2.</strong> Generic</a></li><li class="chapter-item expanded "><a href="second-peek.html"><strong aria-hidden="true">3.3.</strong> Peek</a></li><li class="chapter-item expanded "><a href="second-into-iter.html"><strong aria-hidden="true">3.4.</strong> IntoIter</a></li><li class="chapter-item expanded "><a href="second-iter.html"><strong aria-hidden="true">3.5.</strong> Iter</a></li><li class="chapter-item expanded "><a href="second-iter-mut.html"><strong aria-hidden="true">3.6.</strong> IterMut</a></li><li class="chapter-item expanded "><a href="second-final.html"><strong aria-hidden="true">3.7.</strong> Final Code</a></li></ol></li><li class="chapter-item expanded "><a href="third.html"><strong aria-hidden="true">4.</strong> A Persistent Stack</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="third-layout.html"><strong aria-hidden="true">4.1.</strong> Layout</a></li><li class="chapter-item expanded "><a href="third-basics.html"><strong aria-hidden="true">4.2.</strong> Basics</a></li><li class="chapter-item expanded "><a href="third-drop.html"><strong aria-hidden="true">4.3.</strong> Drop</a></li><li class="chapter-item expanded "><a href="third-arc.html"><strong aria-hidden="true">4.4.</strong> Arc</a></li><li class="chapter-item expanded "><a href="third-final.html"><strong aria-hidden="true">4.5.</strong> Final Code</a></li></ol></li><li class="chapter-item expanded "><a href="fourth.html"><strong aria-hidden="true">5.</strong> A Bad Safe Deque</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="fourth-layout.html"><strong aria-hidden="true">5.1.</strong> Layout</a></li><li class="chapter-item expanded "><a href="fourth-building.html"><strong aria-hidden="true">5.2.</strong> Building</a></li><li class="chapter-item expanded "><a href="fourth-breaking.html"><strong aria-hidden="true">5.3.</strong> Breaking</a></li><li class="chapter-item expanded "><a href="fourth-peek.html"><strong aria-hidden="true">5.4.</strong> Peek</a></li><li class="chapter-item expanded "><a href="fourth-symmetry.html"><strong aria-hidden="true">5.5.</strong> Symmetric Cases</a></li><li class="chapter-item expanded "><a href="fourth-iteration.html"><strong aria-hidden="true">5.6.</strong> Iteration</a></li><li class="chapter-item expanded "><a href="fourth-final.html"><strong aria-hidden="true">5.7.</strong> Final Code</a></li></ol></li><li class="chapter-item expanded "><a href="fifth.html"><strong aria-hidden="true">6.</strong> An Ok Unsafe Queue</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="fifth-layout.html"><strong aria-hidden="true">6.1.</strong> Layout</a></li><li class="chapter-item expanded "><a href="fifth-unsafe.html"><strong aria-hidden="true">6.2.</strong> Unsafe</a></li><li class="chapter-item expanded "><a href="fifth-basics.html"><strong aria-hidden="true">6.3.</strong> Basics</a></li><li class="chapter-item expanded "><a href="fifth-miri.html"><strong aria-hidden="true">6.4.</strong> Miri</a></li><li class="chapter-item expanded "><a href="fifth-stacked-borrows.html"><strong aria-hidden="true">6.5.</strong> Stacked Borrows</a></li><li class="chapter-item expanded "><a href="fifth-testing-stacked-borrows.html"><strong aria-hidden="true">6.6.</strong> Testing Stacked Borrows</a></li><li class="chapter-item expanded "><a href="fifth-layout-basics-redux.html"><strong aria-hidden="true">6.7.</strong> Layout + Basics Redux</a></li><li class="chapter-item expanded "><a href="fifth-extras.html"><strong aria-hidden="true">6.8.</strong> Extras</a></li><li class="chapter-item expanded "><a href="fifth-final.html"><strong aria-hidden="true">6.9.</strong> Final Code</a></li></ol></li><li class="chapter-item expanded "><a href="sixth.html"><strong aria-hidden="true">7.</strong> A Production Unsafe Deque</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="sixth-layout.html"><strong aria-hidden="true">7.1.</strong> Layout</a></li><li class="chapter-item expanded "><a href="sixth-variance.html"><strong aria-hidden="true">7.2.</strong> Variance and Subtyping</a></li><li class="chapter-item expanded "><a href="sixth-basics.html"><strong aria-hidden="true">7.3.</strong> Basics</a></li><li class="chapter-item expanded "><a href="sixth-panics.html"><strong aria-hidden="true">7.4.</strong> Panic Safety</a></li><li class="chapter-item expanded "><a href="sixth-combinatorics.html"><strong aria-hidden="true">7.5.</strong> Boring Combinatorics</a></li><li class="chapter-item expanded "><a href="sixth-random-bits.html"><strong aria-hidden="true">7.6.</strong> Filling In Random Bits</a></li><li class="chapter-item expanded "><a href="sixth-testing.html"><strong aria-hidden="true">7.7.</strong> Testing</a></li><li class="chapter-item expanded "><a href="sixth-send-sync.html"><strong aria-hidden="true">7.8.</strong> Send, Sync, and Compile Tests</a></li><li class="chapter-item expanded "><a href="sixth-cursors-intro.html"><strong aria-hidden="true">7.9.</strong> An Introduction To Cursors</a></li><li class="chapter-item expanded "><a href="sixth-cursors-impl.html"><strong aria-hidden="true">7.10.</strong> Implementing Cursors</a></li><li class="chapter-item expanded "><a href="sixth-cursors-testing.html"><strong aria-hidden="true">7.11.</strong> Testing Cursors</a></li><li class="chapter-item expanded "><a href="sixth-final.html"><strong aria-hidden="true">7.12.</strong> Final Code</a></li></ol></li><li class="chapter-item expanded "><a href="infinity.html"><strong aria-hidden="true">8.</strong> A Bunch of Silly Lists</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="infinity-double-single.html"><strong aria-hidden="true">8.1.</strong> The Double Single</a></li><li class="chapter-item expanded "><a href="infinity-stack-allocated.html"><strong aria-hidden="true">8.2.</strong> The Stack-Allocated Linked List</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Learning Rust With Entirely Too Many Linked Lists</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/rust-unofficial/too-many-lists" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#learn-rust-with-entirely-too-many-linked-lists" id="learn-rust-with-entirely-too-many-linked-lists">Learn Rust With Entirely Too Many Linked Lists</a></h1>
<blockquote>
<p>Got any issues or want to check out all the final code at once?
<a href="https://github.com/rust-unofficial/too-many-lists">Everything's on Github!</a></p>
</blockquote>
<blockquote>
<p><strong>NOTE</strong>: The current edition of this book is written against Rust 2018,
which was first released with rustc 1.31 (Dec 8, 2018). If your rust toolchain
is new enough, the Cargo.toml file that <code>cargo new</code> creates should contain the
line <code>edition = &quot;2018&quot;</code> (or if you're reading this in the far future, perhaps
some even larger number!). Using an older toolchain is possible, but unlocks
a secret <strong>hardmode</strong>, where you get extra compiler errors that go completely
unmentioned in the text of this book. Wow, sounds like fun!</p>
</blockquote>
<p>I fairly frequently get asked how to implement a linked list in Rust. The
answer honestly depends on what your requirements are, and it's obviously not
super easy to answer the question on the spot. As such I've decided to write
this book to comprehensively answer the question once and for all.</p>
<p>In this series I will teach you basic and advanced Rust programming
entirely by having you implement 6 linked lists. In doing so, you should
learn:</p>
<ul>
<li>The following pointer types: <code>&amp;</code>, <code>&amp;mut</code>, <code>Box</code>, <code>Rc</code>, <code>Arc</code>, <code>*const</code>, <code>*mut</code>, <code>NonNull</code>(?)</li>
<li>Ownership, borrowing, inherited mutability, interior mutability, Copy</li>
<li>All The Keywords: struct, enum, fn, pub, impl, use, ...</li>
<li>Pattern matching, generics, destructors</li>
<li>Testing, installing new toolchains, using <code>miri</code></li>
<li>Unsafe Rust: raw pointers, aliasing, stacked borrows, UnsafeCell, variance</li>
</ul>
<p>Yes, linked lists are so truly awful that you deal with all of these concepts in
making them real.</p>
<p>Everything's in the sidebar (may be collapsed on mobile), but for quick
reference, here's what we're going to be making:</p>
<ol>
<li><a href="first.html">A Bad Singly-Linked Stack</a></li>
<li><a href="second.html">An Ok Singly-Linked Stack</a></li>
<li><a href="third.html">A Persistent Singly-Linked Stack</a></li>
<li><a href="fourth.html">A Bad But Safe Doubly-Linked Deque</a></li>
<li><a href="fifth.html">An Unsafe Singly-Linked Queue</a></li>
<li><a href="sixth.html">TODO: An Ok Unsafe Doubly-Linked Deque</a></li>
<li><a href="infinity.html">Bonus: A Bunch of Silly Lists</a></li>
</ol>
<p>Just so we're all the same page, I'll be writing out all the commands that I
feed into my terminal. I'll also be using Rust's standard package manager, Cargo,
to develop the project. Cargo isn't necessary to write a Rust program, but it's
<em>so much</em> better than using rustc directly. If you just want to futz around you
can also run some simple programs in the browser via <a href="https://play.rust-lang.org/">play.rust-lang.org</a>.</p>
<p>In later sections, we'll be using &quot;rustup&quot; to install extra Rust tooling.
I strongly recommend <a href="https://www.rust-lang.org/tools/install">installing all of your Rust toolchains using rustup</a>.</p>
<p>Let's get started and make our project:</p>
<pre><code class="language-text">&gt; cargo new --lib lists
&gt; cd lists
</code></pre>
<p>We'll put each list in a separate file so that we don't lose any of our work.</p>
<p>It should be noted that the <em>authentic</em> Rust learning experience involves
writing code, having the compiler scream at you, and trying to figure out
what the heck that means. I will be carefully ensuring that this occurs as
frequently as possible. Learning to read and understand Rust's generally
excellent compiler errors and documentation is <em>incredibly</em> important to
being a productive Rust programmer.</p>
<p>Although actually that's a lie. In writing this I encountered <em>way</em> more
compiler errors than I show. In particular, in the later chapters I won't be
showing a lot of the random &quot;I typed (copy-pasted) bad&quot; errors that you
expect to encounter in every language. This is a <em>guided tour</em> of having the
compiler scream at us.</p>
<p>We're going to be going pretty slow, and I'm honestly not going to be very
serious pretty much the entire time. I think programming should be fun, dang it!
If you're the type of person who wants maximally information-dense, serious, and
formal content, this book is not for you. Nothing I will ever make is for you.
You are wrong.</p>
<h1><a class="header" href="#an-obligatory-public-service-announcement" id="an-obligatory-public-service-announcement">An Obligatory Public Service Announcement</a></h1>
<p>Just so we're totally 100% clear: I hate linked lists. With
a passion. Linked lists are terrible data structures. Now of course there's
several great use cases for a linked list:</p>
<ul>
<li>You want to do <em>a lot</em> of splitting or merging of big lists. <em>A lot</em>.</li>
<li>You're doing some awesome lock-free concurrent thing.</li>
<li>You're writing a kernel/embedded thing and want to use an intrusive list.</li>
<li>You're using a pure functional language and the limited semantics and absence
of mutation makes linked lists easier to work with.</li>
<li>... and more!</li>
</ul>
<p>But all of these cases are <em>super rare</em> for anyone writing a Rust program. 99%
of the time you should just use a Vec (array stack), and 99% of the other 1%
of the time you should be using a VecDeque (array deque). These are blatantly
superior data structures for most workloads due to less frequent allocation,
lower memory overhead, true random access, and cache locality.</p>
<p>Linked lists are as <em>niche</em> and <em>vague</em> of a data structure as a trie. Few would
balk at me claiming a trie is a niche structure that your average programmer
could happily never learn in an entire productive career -- and yet linked lists
have some bizarre celebrity status. We teach every undergrad how to write a
linked list. It's the only niche collection
<a href="https://doc.rust-lang.org/std/collections/struct.LinkedList.html">I couldn't kill from std::collections</a>. It's
<a href="http://en.cppreference.com/w/cpp/container/list"><em>the</em> list in C++</a>!</p>
<p>We should all as a community say <em>no</em> to linked lists as a &quot;standard&quot; data
structure. It's a fine data structure with several great use cases, but those
use cases are <em>exceptional</em>, not common.</p>
<p>Several people apparently read the first paragraph of this PSA and then stop
reading. Like, literally they'll try to rebut my argument by listing one of the
things in my list of <em>great use cases</em>. The thing right after the first
paragraph!</p>
<p>Just so I can link directly to a detailed argument, here are several attempts
at counter-arguments I have seen, and my response to them. Feel free to skip
to <a href="first.html">the first chapter</a> if you just want to learn some Rust!</p>
<h2><a class="header" href="#performance-doesnt-always-matter" id="performance-doesnt-always-matter">Performance doesn't always matter</a></h2>
<p>Yes! Maybe your application is I/O-bound or the code in question is in some
cold case that just doesn't matter. But this isn't even an argument for using
a linked list. This is an argument for using <em>whatever at all</em>. Why settle for
a linked list? Use a linked hash map!</p>
<p>If performance doesn't matter, then it's <em>surely</em> fine to apply the natural
default of an array.</p>
<h2><a class="header" href="#they-have-o1-split-append-insert-remove-if-you-have-a-pointer-there" id="they-have-o1-split-append-insert-remove-if-you-have-a-pointer-there">They have O(1) split-append-insert-remove if you have a pointer there</a></h2>
<p>Yep! Although as <a href="https://www.youtube.com/watch?v=YQs6IC-vgmo">Bjarne Stroustrup notes</a> <em>this doesn't actually
matter</em> if the time it takes to get that pointer completely dwarfs the
time it would take to just copy over all the elements in an array (which is
really quite fast).</p>
<p>Unless you have a workload that is heavily dominated by splitting and merging
costs, the penalty <em>every other</em> operation takes due to caching effects and code
complexity will eliminate any theoretical gains.</p>
<p><em>But yes, if you're profiling your application to spend a lot of time in
splitting and merging, you may have gains in a linked list</em>.</p>
<h2><a class="header" href="#i-cant-afford-amortization" id="i-cant-afford-amortization">I can't afford amortization</a></h2>
<p>You've already entered a pretty niche space -- most can afford amortization.
Still, arrays are amortized <em>in the worst case</em>. Just because you're using an
array, doesn't mean you have amortized costs. If you can predict how many
elements you're going to store (or even have an upper-bound), you can
pre-reserve all the space you need. In my experience it's <em>very</em> common to be
able to predict how many elements you'll need. In Rust in particular, all
iterators provide a <code>size_hint</code> for exactly this case.</p>
<p>Then <code>push</code> and <code>pop</code> will be truly O(1) operations. And they're going to be
<em>considerably</em> faster than <code>push</code> and <code>pop</code> on linked list. You do a pointer
offset, write the bytes, and increment an integer. No need to go to any kind of
allocator.</p>
<p>How's that for low latency?</p>
<p><em>But yes, if you can't predict your load, there are worst-case
latency savings to be had!</em></p>
<h2><a class="header" href="#linked-lists-waste-less-space" id="linked-lists-waste-less-space">Linked lists waste less space</a></h2>
<p>Well, this is complicated. A &quot;standard&quot; array resizing strategy is to grow
or shrink so that at most half the array is empty. This is indeed a lot of
wasted space. Especially in Rust, we don't automatically shrink collections
(it's a waste if you're just going to fill it back up again), so the wastage
can approach infinity!</p>
<p>But this is a worst-case scenario. In the best-case, an array stack only has
three pointers of overhead for the entire array. Basically no overhead.</p>
<p>Linked lists on the other hand unconditionally waste space per element.
A singly-linked list wastes one pointer while a doubly-linked list wastes
two. Unlike an array, the relative wasteage is proportional to the size of
the element. If you have <em>huge</em> elements this approaches 0 waste. If you have
tiny elements (say, bytes), then this can be as much as 16x memory overhead
(8x on 32-bit)!</p>
<p>Actually, it's more like 23x (11x on 32-bit) because padding will be added
to the byte to align the whole node's size to a pointer.</p>
<p>This is also assuming the best-case for your allocator: that allocating and
deallocating nodes is being done densely and you're not losing memory to
fragmentation.</p>
<p><em>But yes, if you have huge elements, can't predict your load, and have a
decent allocator, there are memory savings to be had!</em></p>
<h2><a class="header" href="#i-use-linked-lists-all-the-time-in-functional-language" id="i-use-linked-lists-all-the-time-in-functional-language">I use linked lists all the time in &lt;functional language&gt;</a></h2>
<p>Great! Linked lists are super elegant to use in functional languages
because you can manipulate them without any mutation, can describe them
recursively, and also work with infinite lists due to the magic of laziness.</p>
<p>Specifically, linked lists are nice because they represent an iteration without
the need for any mutable state. The next step is just visiting the next sublist.</p>
<p>Rust mostly does this kind of thing with <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html">iterators</a>. They can be infinite 
and you can map, filter, reverse, and concatenate them just like a functional list,
and it will all be done just as lazily!</p>
<p>Rust also lets you easily talk about sub-arrays with <em><a href="https://doc.rust-lang.org/std/primitive.slice.html">slices</a></em>. Your usual
head/tail split in a functional language is <a href="https://doc.rust-lang.org/std/primitive.slice.html#method.split_at_mut">just <code>slice.split_at_mut(1)</code></a>.
For a long time, Rust had an experimental system for pattern matching on
slices which was super cool, but the feature was simplified when it was
stabilized. Still, <a href="https://doc.rust-lang.org/edition-guide/rust-2018/slice-patterns.html">basic slice patterns</a> are neat! And of course,
slices can be turned into iterators!</p>
<p><em>But yes, if you're limited to immutable semantics, linked lists can be very
nice</em>.</p>
<p>Note that I'm not saying that functional programming is necessarily weak or
bad. However it <em>is</em> fundamentally semantically limited: you're largely only
allowed to talk about how things <em>are</em>, and not how they should be <em>done</em>. This
is actually a <em>feature</em>, because it enables the compiler to do tons of <a href="https://wiki.haskell.org/GHC_optimisations#Fusion">exotic
transformations</a> and potentially figure out the <em>best</em> way to do things
without you having to worry about it. However this comes at the cost of being
<em>able</em> to worry about it. There are usually escape hatches, but at some limit
you're just writing procedural code again.</p>
<p>Even in functional languages, you should endeavour to use the appropriate data
structure for the job when you actually need a data structure. Yes,
singly-linked lists are your primary tool for control flow, but they're a
really poor way to actually store a bunch of data and query it.</p>
<h2><a class="header" href="#linked-lists-are-great-for-building-concurrent-data-structures" id="linked-lists-are-great-for-building-concurrent-data-structures">Linked lists are great for building concurrent data structures!</a></h2>
<p>Yes! Although writing a concurrent data structure is really a whole different
beast, and isn't something that should be taken lightly. Certainly not something
many people will even <em>consider</em> doing. Once one's been written, you're also not
really choosing to use a linked list. You're choosing to use an MPSC queue or
whatever. The implementation strategy is pretty far removed in this case!</p>
<p><em>But yes, linked lists are the defacto heroes of the dark world of lock-free
concurrency.</em></p>
<h2><a class="header" href="#mumble-mumble-kernel-embedded-something-something-intrusive" id="mumble-mumble-kernel-embedded-something-something-intrusive">Mumble mumble kernel embedded something something intrusive.</a></h2>
<p>It's niche. You're talking about a situation where you're not even using
your language's <em>runtime</em>. Is that not a red flag that you're doing something
strange?</p>
<p>It's also wildly unsafe.</p>
<p><em>But sure. Build your awesome zero-allocation lists on the stack.</em></p>
<h2><a class="header" href="#iterators-dont-get-invalidated-by-unrelated-insertionsremovals" id="iterators-dont-get-invalidated-by-unrelated-insertionsremovals">Iterators don't get invalidated by unrelated insertions/removals</a></h2>
<p>That's a delicate dance you're playing. Especially if you don't have
a garbage collector. I might argue that your control flow and ownership
patterns are probably a bit too tangled, depending on the details.</p>
<p><em>But yes, you can do some really cool crazy stuff with cursors.</em></p>
<h2><a class="header" href="#theyre-simple-and-great-for-teaching" id="theyre-simple-and-great-for-teaching">They're simple and great for teaching!</a></h2>
<p>Well, yeah. You're reading a book dedicated to that premise.
Well, singly-linked lists are pretty simple. Doubly-linked lists
can get kinda gnarly, as we'll see.</p>
<h1><a class="header" href="#take-a-breath" id="take-a-breath">Take a Breath</a></h1>
<p>Ok. That's out of the way. Let's write a bajillion linked lists.</p>
<p><a href="first.html">On to the first chapter!</a></p>
<h1><a class="header" href="#a-bad-singly-linked-stack" id="a-bad-singly-linked-stack">A Bad Singly-Linked Stack</a></h1>
<p>This one's gonna be <em>by far</em> the longest, as we need to introduce basically
all of Rust, and are gonna build up some things &quot;the hard way&quot; to better
understand the language.</p>
<p>We'll put our first list in <code>src/first.rs</code>. We need to tell Rust that <code>first.rs</code> is
something that our lib uses. All that requires is that we put this at the top of
<code>src/lib.rs</code> (which Cargo made for us):</p>
<pre><code class="language-rust ignore">// in lib.rs
pub mod first;
</code></pre>
<h1><a class="header" href="#basic-data-layout" id="basic-data-layout">Basic Data Layout</a></h1>
<p>Alright, so what's a linked list? Well basically, it's a bunch of pieces of data
on the heap (hush, kernel people!) that point to each other in sequence. Linked
lists are something procedural programmers shouldn't touch with a 10-foot pole,
and what functional programmers use for everything. It seems fair, then, that we
should ask functional programmers for the definition of a linked list. They will
probably give you something like the following definition:</p>
<pre><code class="language-haskell">List a = Empty | Elem a (List a)
</code></pre>
<p>Which reads approximately as &quot;A List is either Empty or an Element followed by a
List&quot;. This is a recursive definition expressed as a <em>sum type</em>, which is a
fancy name for &quot;a type that can have different values which may be different
types&quot;. Rust calls sum types <code>enum</code>s! If you're coming from a C-like language,
this is exactly the enum you know and love, but in overdrive. So let's
transcribe this functional definition into Rust!</p>
<p>For now we'll avoid generics to keep things simple. We'll only support
storing signed 32-bit integers:</p>
<pre><code class="language-rust ignore">// in first.rs

// pub says we want people outside this module to be able to use List
pub enum List {
    Empty,
    Elem(i32, List),
}
</code></pre>
<p><em>phew</em>, I'm swamped. Let's just go ahead and compile that:</p>
<pre><code class="language-text">&gt; cargo build

error[E0072]: recursive type `first::List` has infinite size
 --&gt; src/first.rs:4:1
  |
4 | pub enum List {
  | ^^^^^^^^^^^^^ recursive type has infinite size
5 |     Empty,
6 |     Elem(i32, List),
  |               ---- recursive without indirection
  |
  = help: insert indirection (e.g., a `Box`, `Rc`, or `&amp;`) at some point to make `first::List` representable
</code></pre>
<p>Well. I don't know about you, but I certainly feel betrayed by the functional
programming community.</p>
<p>If we actually check out the error message (after we get over the whole
betrayal thing), we can see that rustc is actually telling us exactly
how to solve this problem:</p>
<blockquote>
<p>insert indirection (e.g., a <code>Box</code>, <code>Rc</code>, or <code>&amp;</code>) at some point to make <code>first::List</code> representable</p>
</blockquote>
<p>Alright, <code>box</code>. What's that? Let's google <code>rust box</code>...</p>
<blockquote>
<p><a href="https://doc.rust-lang.org/std/boxed/struct.Box.html">std::boxed::Box - Rust</a></p>
</blockquote>
<p>Lesse here...</p>
<blockquote>
<p><code>pub struct Box&lt;T&gt;(_);</code></p>
<p>A pointer type for heap allocation.
See the <a href="https://doc.rust-lang.org/std/boxed/">module-level documentation</a> for more.</p>
</blockquote>
<p><em>clicks link</em></p>
<blockquote>
<p><code>Box&lt;T&gt;</code>, casually referred to as a 'box', provides the simplest form of heap allocation in Rust. Boxes provide ownership for this allocation, and drop their contents when they go out of scope.</p>
<p>Examples</p>
<p>Creating a box:</p>
<p><code>let x = Box::new(5);</code></p>
<p>Creating a recursive data structure:</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
enum List&lt;T&gt; {
    Cons(T, Box&lt;List&lt;T&gt;&gt;),
    Nil,
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
</blockquote>
<pre><code class="language-rust ignore">fn main() {
    let list: List&lt;i32&gt; = List::Cons(1, Box::new(List::Cons(2, Box::new(List::Nil))));
    println!(&quot;{:?}&quot;, list);
}
</code></pre>
<blockquote>
<p>This will print <code>Cons(1, Box(Cons(2, Box(Nil))))</code>.</p>
<p>Recursive structures must be boxed, because if the definition of Cons looked like this:</p>
<p><code>Cons(T, List&lt;T&gt;),</code></p>
<p>It wouldn't work. This is because the size of a List depends on how many elements are in the list, and so we don't know how much memory to allocate for a Cons. By introducing a Box, which has a defined size, we know how big Cons needs to be.</p>
</blockquote>
<p>Wow, uh. That is perhaps the most relevant and helpful documentation I have ever seen. Literally the first thing in the documentation is <em>exactly what we're trying to write, why it didn't work, and how to fix it</em>.</p>
<p>Dang, docs rule.</p>
<p>Ok, let's do that:</p>
<pre><code class="language-rust ignore">pub enum List {
    Empty,
    Elem(i32, Box&lt;List&gt;),
}
</code></pre>
<pre><code class="language-text">&gt; cargo build

   Finished dev [unoptimized + debuginfo] target(s) in 0.22s
</code></pre>
<p>Hey it built!</p>
<p>...but this is actually a really foolish definition of a List, for a few reasons.</p>
<p>Consider a list with two elements:</p>
<pre><code class="language-text">[] = Stack
() = Heap

[Elem A, ptr] -&gt; (Elem B, ptr) -&gt; (Empty, *junk*)
</code></pre>
<p>There are two key issues:</p>
<ul>
<li>We're allocating a node that just says &quot;I'm not actually a Node&quot;</li>
<li>One of our nodes isn't heap-allocated at all.</li>
</ul>
<p>On the surface, these two seem to cancel each-other out. We heap-allocate an
extra node, but one of our nodes doesn't need to be heap-allocated at all.
However, consider the following potential layout for our list:</p>
<pre><code class="language-text">[ptr] -&gt; (Elem A, ptr) -&gt; (Elem B, *null*)
</code></pre>
<p>In this layout we now unconditionally heap allocate our nodes. The
key difference is the absence of the <em>junk</em> from our first layout. What is
this junk? To understand that, we'll need to look at how an enum is laid out
in memory.</p>
<p>In general, if we have an enum like:</p>
<pre><code class="language-rust ignore">enum Foo {
    D1(T1),
    D2(T2),
    ...
    Dn(Tn),
}
</code></pre>
<p>A Foo will need to store some integer to indicate which <em>variant</em> of the enum it
represents (<code>D1</code>, <code>D2</code>, .. <code>Dn</code>). This is the <em>tag</em> of the enum. It will also
need enough space to store the <em>largest</em> of <code>T1</code>, <code>T2</code>, .. <code>Tn</code> (plus some extra
space to satisfy alignment requirements).</p>
<p>The big takeaway here is that even though <code>Empty</code> is a single bit of
information, it necessarily consumes enough space for a pointer and an element,
because it has to be ready to become an <code>Elem</code> at any time. Therefore the first
layout heap allocates an extra element that's just full of junk, consuming a
bit more space than the second layout.</p>
<p>One of our nodes not being allocated at all is also, perhaps surprisingly,
<em>worse</em> than always allocating it. This is because it gives us a <em>non-uniform</em>
node layout. This doesn't have much of an appreciable effect on pushing and
popping nodes, but it does have an effect on splitting and merging lists.</p>
<p>Consider splitting a list in both layouts:</p>
<pre><code class="language-text">layout 1:

[Elem A, ptr] -&gt; (Elem B, ptr) -&gt; (Elem C, ptr) -&gt; (Empty *junk*)

split off C:

[Elem A, ptr] -&gt; (Elem B, ptr) -&gt; (Empty *junk*)
[Elem C, ptr] -&gt; (Empty *junk*)
</code></pre>
<pre><code class="language-text">layout 2:

[ptr] -&gt; (Elem A, ptr) -&gt; (Elem B, ptr) -&gt; (Elem C, *null*)

split off C:

[ptr] -&gt; (Elem A, ptr) -&gt; (Elem B, *null*)
[ptr] -&gt; (Elem C, *null*)
</code></pre>
<p>Layout 2's split involves just copying B's pointer to the stack and nulling
the old value out. Layout 1 ultimately does the same thing, but also has to
copy C from the heap to the stack. Merging is the same process in reverse.</p>
<p>One of the few nice things about a linked list is that you can construct the
element in the node itself, and then freely shuffle it around lists without
ever moving it. You just fiddle with pointers and stuff gets &quot;moved&quot;. Layout 1
trashes this property.</p>
<p>Alright, I'm reasonably convinced Layout 1 is bad. How do we rewrite our List?
Well, we could do something like:</p>
<pre><code class="language-rust ignore">pub enum List {
    Empty,
    ElemThenEmpty(i32),
    ElemThenNotEmpty(i32, Box&lt;List&gt;),
}
</code></pre>
<p>Hopefully this seems like an even worse idea to you. Most notably, this really
complicates our logic, because there is now a completely invalid state:
<code>ElemThenNotEmpty(0, Box(Empty))</code>. It also <em>still</em> suffers from non-uniformly
allocating our elements.</p>
<p>However it does have <em>one</em> interesting property: it totally avoids allocating
the Empty case, reducing the total number of heap allocations by 1. Unfortunately,
in doing so it manages to waste <em>even more space</em>! This is because the previous
layout took advantage of the <em>null pointer optimization</em>.</p>
<p>We previously saw that every enum has to store a <em>tag</em> to specify which variant
of the enum its bits represent. However, if we have a special kind of enum:</p>
<pre><code class="language-rust ignore">enum Foo {
    A,
    B(ContainsANonNullPtr),
}
</code></pre>
<p>the null pointer optimization kicks in, which <em>eliminates the space needed for
the tag</em>. If the variant is A, the whole enum is set to all <code>0</code>'s. Otherwise,
the variant is B. This works because B can never be all <code>0</code>'s, since it contains
a non-zero pointer. Slick!</p>
<p>Can you think of other enums and types that could do this kind of optimization?
There's actually a lot! This is why Rust leaves enum layout totally unspecified.
There are a few more complicated enum layout optimizations that Rust will do for
us, but the null pointer one is definitely the most important!
It means <code>&amp;</code>, <code>&amp;mut</code>, <code>Box</code>, <code>Rc</code>, <code>Arc</code>, <code>Vec</code>, and
several other important types in Rust have no overhead when put in an <code>Option</code>!
(We'll get to most of these in due time.)</p>
<p>So how do we avoid the extra junk, uniformly allocate, <em>and</em> get that sweet
null-pointer optimization? We need to better separate out the idea of having an
element from allocating another list. To do this, we have to think a little more
C-like: structs!</p>
<p>While enums let us declare a type that can contain <em>one</em> of several values,
structs let us declare a type that contains <em>many</em> values at once. Let's break
our List into two types: A List, and a Node.</p>
<p>As before, a List is either Empty or has an element followed by another List.
By representing the &quot;has an element followed by another List&quot; case by an
entirely separate type, we can hoist the Box to be in a more optimal position:</p>
<pre><code class="language-rust ignore">struct Node {
    elem: i32,
    next: List,
}

pub enum List {
    Empty,
    More(Box&lt;Node&gt;),
}
</code></pre>
<p>Let's check our priorities:</p>
<ul>
<li>Tail of a list never allocates extra junk: check!</li>
<li><code>enum</code> is in delicious null-pointer-optimized form: check!</li>
<li>All elements are uniformly allocated: check!</li>
</ul>
<p>Alright! We actually just constructed exactly the layout that we used to
demonstrate that our first layout (as suggested by the official Rust
documentation) was problematic.</p>
<pre><code class="language-text">&gt; cargo build

warning: private type `first::Node` in public interface (error E0446)
 --&gt; src/first.rs:8:10
  |
8 |     More(Box&lt;Node&gt;),
  |          ^^^^^^^^^
  |
  = note: #[warn(private_in_public)] on by default
  = warning: this was previously accepted by the compiler but
    is being phased out; it will become a hard error in a future release!
</code></pre>
<p>:(</p>
<p>Rust is mad at us again. We marked the <code>List</code> as public (because we want people
to be able to use it), but not the <code>Node</code>. The problem is that the internals of
an <code>enum</code> are totally public, and we're not allowed to publicly talk about
private types. We could make all of <code>Node</code> totally public, but generally in Rust
we favour keeping implementation details private. Let's make <code>List</code> a struct, so
that we can hide the implementation details:</p>
<pre><code class="language-rust ignore">pub struct List {
    head: Link,
}

enum Link {
    Empty,
    More(Box&lt;Node&gt;),
}

struct Node {
    elem: i32,
    next: Link,
}
</code></pre>
<p>Because <code>List</code> is a struct with a single field, its size is the same as that
field. Yay zero-cost abstractions!</p>
<pre><code class="language-text">&gt; cargo build

warning: field is never used: `head`
 --&gt; src/first.rs:2:5
  |
2 |     head: Link,
  |     ^^^^^^^^^^
  |
  = note: #[warn(dead_code)] on by default

warning: variant is never constructed: `Empty`
 --&gt; src/first.rs:6:5
  |
6 |     Empty,
  |     ^^^^^

warning: variant is never constructed: `More`
 --&gt; src/first.rs:7:5
  |
7 |     More(Box&lt;Node&gt;),
  |     ^^^^^^^^^^^^^^^

warning: field is never used: `elem`
  --&gt; src/first.rs:11:5
   |
11 |     elem: i32,
   |     ^^^^^^^^^

warning: field is never used: `next`
  --&gt; src/first.rs:12:5
   |
12 |     next: Link,
   |     ^^^^^^^^^^

</code></pre>
<p>Alright, that compiled! Rust is pretty mad, because as far as it can tell,
everything we've written is totally useless: we never use <code>head</code>, and no one who
uses our library can either since it's private. Transitively, that means Link
and Node are useless too. So let's solve that! Let's implement some code for our
List!</p>
<h1><a class="header" href="#new" id="new">New</a></h1>
<p>To associate actual code with a type, we use <code>impl</code> blocks:</p>
<pre><code class="language-rust ignore">impl List {
    // TODO, make code happen
}
</code></pre>
<p>Now we just need to figure out how to actually write code. In Rust we declare
a function like so:</p>
<pre><code class="language-rust ignore">fn foo(arg1: Type1, arg2: Type2) -&gt; ReturnType {
    // body
}
</code></pre>
<p>The first thing we want is a way to <em>construct</em> a list. Since we hide the
implementation details, we need to provide that as a function. The usual way
to do that in Rust is to provide a static method, which is just a
normal function inside an <code>impl</code>:</p>
<pre><code class="language-rust ignore">impl List {
    pub fn new() -&gt; Self {
        List { head: Link::Empty }
    }
}
</code></pre>
<p>A few notes on this:</p>
<ul>
<li>Self is an alias for &quot;that type I wrote at the top next to <code>impl</code>&quot;. Great for
not repeating yourself!</li>
<li>We create an instance of a struct in much the same way we declare it, except
instead of providing the types of its fields, we initialize them with values.</li>
<li>We refer to variants of an enum using <code>::</code>, which is the namespacing operator.</li>
<li>The last expression of a function is implicitly returned.
This makes simple functions a little neater. You can still use <code>return</code>
to return early like other C-like languages.</li>
</ul>
<h1><a class="header" href="#ownership-101" id="ownership-101">Ownership 101</a></h1>
<p>Now that we can construct a list, it'd be nice to be able to <em>do</em> something
with it. We do that with &quot;normal&quot; (non-static) methods. Methods are a special
case of function in Rust because of  the <code>self</code> argument, which doesn't have
a declared type:</p>
<pre><code class="language-rust ignore">fn foo(self, arg2: Type2) -&gt; ReturnType {
    // body
}
</code></pre>
<p>There are 3 primary forms that self can take: <code>self</code>, <code>&amp;mut self</code>, and <code>&amp;self</code>.
These 3 forms represent the three primary forms of ownership in Rust:</p>
<ul>
<li><code>self</code> - Value</li>
<li><code>&amp;mut self</code> - mutable reference</li>
<li><code>&amp;self</code> - shared reference</li>
</ul>
<p>A value represents <em>true</em> ownership. You can do whatever you want with a value:
move it, destroy it, mutate it, or loan it out via a reference. When you pass
something by value, it's <em>moved</em> to the new location. The new location now
owns the value, and the old location can no longer access it. For this reason
most methods don't want <code>self</code> -- it would be pretty lame if trying to work with
a list made it go away!</p>
<p>A mutable reference represents temporary <em>exclusive access</em> to a value that you
don't own. You're allowed to do absolutely anything you want to a value you
have a mutable reference to as long you leave it in a valid state when you're
done (it would be rude to the owner otherwise!). This means you can actually completely
overwrite the value. A really useful special case of this is <em>swapping</em> a value
out for another, which we'll be using a lot. The only thing you can't do with an
<code>&amp;mut</code> is move the value out with no replacement. <code>&amp;mut self</code> is great for
methods that want to mutate <code>self</code>.</p>
<p>A shared reference represents temporary <em>shared access</em> to a value that you
don't own. Because you have shared access, you're generally not allowed to
mutate anything. Think of <code>&amp;</code> as putting the value out on display in a museum.
<code>&amp;</code> is great for methods that only want to observe <code>self</code>.</p>
<p>Later we'll see that the rule about mutation can be bypassed in certain cases.
This is why shared references aren't called <em>immutable</em> references. Really,
mutable references could be called <em>unique</em> references, but we've found that
relating ownership to mutability gives the right intuition 99% of the time.</p>
<h1><a class="header" href="#push" id="push">Push</a></h1>
<p>So let's write pushing a value onto a list. <code>push</code> <em>mutates</em> the list,
so we'll want to take <code>&amp;mut self</code>. We also need to take an i32 to push:</p>
<pre><code class="language-rust ignore">impl List {
    pub fn push(&amp;mut self, elem: i32) {
        // TODO
    }
}
</code></pre>
<p>First things first, we need to make a node to store our element in:</p>
<pre><code class="language-rust ignore">    pub fn push(&amp;mut self, elem: i32) {
        let new_node = Node {
            elem: elem,
            next: ?????
        };
    }
</code></pre>
<p>What goes <code>next</code>? Well, the entire old list! Can we... just do that?</p>
<pre><code class="language-rust ignore">impl List {
    pub fn push(&amp;mut self, elem: i32) {
        let new_node = Node {
            elem: elem,
            next: self.head,
        };
    }
}
</code></pre>
<pre><code class="language-text">&gt; cargo build
error[E0507]: cannot move out of borrowed content
  --&gt; src/first.rs:19:19
   |
19 |             next: self.head,
   |                   ^^^^^^^^^ cannot move out of borrowed content
</code></pre>
<p>Nooooope. Rust is telling us the right thing, but it's certainly not obvious
what exactly it means, or what to do about it:</p>
<blockquote>
<p>cannot move out of borrowed content</p>
</blockquote>
<p>We're trying to move the <code>self.head</code> field out to <code>next</code>, but Rust doesn't want
us doing that. This would leave <code>self</code> only partially initialized when we end
the borrow and &quot;give it back&quot; to its rightful owner. As we said before, that's
the <em>one</em> thing you can't do with an <code>&amp;mut</code>: It would be super rude,
and Rust is very polite (it would also be incredibly dangerous, but surely
<em>that</em> isn't why it cares).</p>
<p>What if we put something back? Namely, the node that we're creating:</p>
<pre><code class="language-rust ignore">pub fn push(&amp;mut self, elem: i32) {
    let new_node = Box::new(Node {
        elem: elem,
        next: self.head,
    });

    self.head = Link::More(new_node);
}
</code></pre>
<pre><code class="language-text">&gt; cargo build
error[E0507]: cannot move out of borrowed content
  --&gt; src/first.rs:19:19
   |
19 |             next: self.head,
   |                   ^^^^^^^^^ cannot move out of borrowed content
</code></pre>
<p>No dice. In principle, this is something Rust could actually accept, but it
won't (for various reasons -- the most serious being <a href="https://doc.rust-lang.org/nightly/nomicon/exception-safety.html">exception safety</a>). We need
some way to get the head without Rust noticing that it's gone. For advice, we
turn to infamous Rust Hacker Indiana Jones:</p>
<p><img src="img/indy.gif" alt="Indy Prepares to mem::replace" /></p>
<p>Ah yes, Indy suggests the <code>mem::replace</code> maneuver. This incredibly useful
function lets us steal a value out of a borrow by <em>replacing</em> it with another
value. Let's just pull in <code>std::mem</code> at the top of the file, so that <code>mem</code> is in
local scope:</p>
<pre><code class="language-rust ignore">use std::mem;
</code></pre>
<p>and use it appropriately:</p>
<pre><code class="language-rust ignore">pub fn push(&amp;mut self, elem: i32) {
    let new_node = Box::new(Node {
        elem: elem,
        next: mem::replace(&amp;mut self.head, Link::Empty),
    });

    self.head = Link::More(new_node);
}
</code></pre>
<p>Here we <code>replace</code> self.head temporarily with Link::Empty before replacing it
with the new head of the list. I'm not gonna lie: this is a pretty unfortunate
thing to have to do. Sadly, we must (for now).</p>
<p>But hey, that's <code>push</code> all done! Probably. We should probably test it, honestly.
Right now the easiest way to do that is probably to write <code>pop</code>, and make sure
that it produces the right results.</p>
<h1><a class="header" href="#pop" id="pop">Pop</a></h1>
<p>Like <code>push</code>, <code>pop</code> wants to mutate the list. Unlike <code>push</code>, we actually
want to return something. But <code>pop</code> also has to deal with a tricky corner
case: what if the list is empty? To represent this case, we use the trusty
<code>Option</code> type:</p>
<pre><code class="language-rust ignore">pub fn pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
    // TODO
}
</code></pre>
<p><code>Option&lt;T&gt;</code> is an enum that represents a value that may exist. It can either be
<code>Some(T)</code> or <code>None</code>. We could make our own enum for this like we did for
Link, but we want our users to be able to understand what the heck our return
type is, and Option is so ubiquitous that <em>everyone</em> knows it. In fact, it's so
fundamental that it's implicitly imported into scope in every file, as well
as its variants <code>Some</code> and <code>None</code> (so we don't have to say <code>Option::None</code>).</p>
<p>The pointy bits on <code>Option&lt;T&gt;</code> indicate that Option is actually <em>generic</em> over
T. That means that you can make an Option for <em>any</em> type!</p>
<p>So uh, we have this <code>Link</code> thing, how do we figure out if it's Empty or has
More? Pattern matching with <code>match</code>!</p>
<pre><code class="language-rust ignore">pub fn pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
    match self.head {
        Link::Empty =&gt; {
            // TODO
        }
        Link::More(node) =&gt; {
            // TODO
        }
    };
}
</code></pre>
<pre><code class="language-text">&gt; cargo build

error[E0308]: mismatched types
  --&gt; src/first.rs:27:30
   |
27 |     pub fn pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
   |            ---               ^^^^^^^^^^^ expected enum `std::option::Option`, found ()
   |            |
   |            this function's body doesn't return
   |
   = note: expected type `std::option::Option&lt;i32&gt;`
              found type `()`
</code></pre>
<p>Whoops, <code>pop</code> has to return a value, and we're not doing that yet. We <em>could</em>
return <code>None</code>, but in this case it's probably a better idea to return
<code>unimplemented!()</code>, to indicate that we aren't done implementing the function.
<code>unimplemented!()</code> is a macro (<code>!</code> indicates a macro) that panics the program
when we get to it (~crashes it in a controlled manner).</p>
<pre><code class="language-rust ignore">pub fn pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
    match self.head {
        Link::Empty =&gt; {
            // TODO
        }
        Link::More(node) =&gt; {
            // TODO
        }
    };
    unimplemented!()
}
</code></pre>
<p>Unconditional panics are an example of a <a href="https://doc.rust-lang.org/nightly/book/ch19-04-advanced-types.html#the-never-type-that-never-returns">diverging function</a>.
Diverging functions never return to the caller, so they may be used in places
where a value of any type is expected. Here, <code>unimplemented!()</code> is being
used in place of a value of type <code>Option&lt;T&gt;</code>.</p>
<p>Note also that we don't need to write <code>return</code> in our program. The last
expression (basically line) in a function is implicitly its return value. This
lets us express really simple things a bit more concisely. You can always
explicitly return early with <code>return</code> like any other C-like language.</p>
<pre><code class="language-text">&gt; cargo build

error[E0507]: cannot move out of borrowed content
  --&gt; src/first.rs:28:15
   |
28 |         match self.head {
   |               ^^^^^^^^^
   |               |
   |               cannot move out of borrowed content
   |               help: consider borrowing here: `&amp;self.head`
...
32 |             Link::More(node) =&gt; {
   |                        ---- data moved here
   |
note: move occurs because `node` has type `std::boxed::Box&lt;first::Node&gt;`, which does not implement the `Copy` trait
  --&gt; src/first.rs:32:24
   |
32 |             Link::More(node) =&gt; {
   |                        ^^^^
</code></pre>
<p>Come on Rust, get off our back! As always, Rust is hella mad at us. Thankfully,
this time it's also giving us the full scoop! By default, a pattern match will
try to move its contents into the new branch, but we can't do this because we
don't own self by-value here.</p>
<pre><code class="language-text">help: consider borrowing here: `&amp;self.head`
</code></pre>
<p>Rust says we should add a reference to our <code>match</code> to fix that. 🤷‍♀️ Let's try it:</p>
<pre><code class="language-rust ignore">pub fn pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
    match &amp;self.head {
        Link::Empty =&gt; {
            // TODO
        }
        Link::More(node) =&gt; {
            // TODO
        }
    };
    unimplemented!()
}
</code></pre>
<pre><code class="language-text">&gt; cargo build

warning: unused variable: `node`
  --&gt; src/first.rs:32:24
   |
32 |             Link::More(node) =&gt; {
   |                        ^^^^ help: consider prefixing with an underscore: `_node`
   |
   = note: #[warn(unused_variables)] on by default

warning: field is never used: `elem`
  --&gt; src/first.rs:13:5
   |
13 |     elem: i32,
   |     ^^^^^^^^^
   |
   = note: #[warn(dead_code)] on by default

warning: field is never used: `next`
  --&gt; src/first.rs:14:5
   |
14 |     next: Link,
   |     ^^^^^^^^^^
</code></pre>
<p>Hooray, compiling again! Now let's figure out that logic. We want to make an
Option, so let's make a variable for that. In the Empty case we need to return
None. In the More case we need to return <code>Some(i32)</code>, and change the head of
the list. So, let's try to do basically that?</p>
<pre><code class="language-rust ignore">pub fn pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
    let result;
    match &amp;self.head {
        Link::Empty =&gt; {
            result = None;
        }
        Link::More(node) =&gt; {
            result = Some(node.elem);
            self.head = node.next;
        }
    };
    result
}
</code></pre>
<pre><code class="language-text">&gt; cargo build
   Compiling lists v0.1.0 (/Users/ADesires/dev/temp/lists)
error[E0507]: cannot move out of borrowed content
  --&gt; src/first.rs:35:29
   |
35 |                 self.head = node.next;
   |                             ^^^^^^^^^ cannot move out of borrowed content

</code></pre>
<p><em>head</em></p>
<p><em>desk</em></p>
<p>We're trying to move out of <code>node</code> when all we have is a shared reference to it.</p>
<p>We should probably step back and think about what we're trying to do. We want
to:</p>
<ul>
<li>Check if the list is empty.</li>
<li>If it's empty, just return None</li>
<li>If it's <em>not</em> empty
<ul>
<li>remove the head of the list</li>
<li>remove its <code>elem</code></li>
<li>replace the list's head with its <code>next</code></li>
<li>return <code>Some(elem)</code></li>
</ul>
</li>
</ul>
<p>The key insight is we want to <em>remove</em> things, which means we want to get the
head of the list <em>by value</em>. We certainly can't do that through the shared
reference we get through <code>&amp;self.head</code>. We also &quot;only&quot; have a mutable reference
to <code>self</code>, so the only way we can move stuff is to <em>replace it</em>. Looks like we're doing
the Empty dance again!</p>
<p>Let's try that:</p>
<pre><code class="language-rust ignore">pub fn pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
    let result;
    match mem::replace(&amp;mut self.head, Link::Empty) {
        Link::Empty =&gt; {
            result = None;
        }
        Link::More(node) =&gt; {
            result = Some(node.elem);
            self.head = node.next;
        }
    };
    result
}
</code></pre>
<pre><code class="language-text">cargo build

   Finished dev [unoptimized + debuginfo] target(s) in 0.22s
</code></pre>
<p>O M G</p>
<p>It compiled without <em>any</em> warnings!!!!!</p>
<p>Actually I'm going to apply my own personal lint here: we made this <code>result</code>
value to return, but actually we didn't need to do that at all! Just as a
function evaluates to its last expression, every block also evaluates to
its last expression. Normally we supress this behaviour with semi-colons,
which instead makes the block evaluate to the empty tuple, <code>()</code>. This is
actually the value that functions which don't declare a return value -- like
<code>push</code> -- return.</p>
<p>So instead, we can write <code>pop</code> as:</p>
<pre><code class="language-rust ignore">pub fn pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
    match mem::replace(&amp;mut self.head, Link::Empty) {
        Link::Empty =&gt; None,
        Link::More(node) =&gt; {
            self.head = node.next;
            Some(node.elem)
        }
    }
}
</code></pre>
<p>Which is a bit more concise and idiomatic. Note that the Link::Empty branch
completely lost its braces, because we only have one expression to
evaluate. Just a nice shorthand for simple cases.</p>
<pre><code class="language-text">cargo build

   Finished dev [unoptimized + debuginfo] target(s) in 0.22s
</code></pre>
<p>Nice, still works!</p>
<h1><a class="header" href="#testing" id="testing">Testing</a></h1>
<p>Alright, so we've got <code>push</code> and <code>pop</code> written, now we can actually test out
our stack! Rust and cargo support testing as a first-class feature, so this
will be super easy. All we have to do is write a function, and annotate it with
<code>#[test]</code>.</p>
<p>Generally, we try to keep our tests next to the code that it's testing in the
Rust community. However we usually make a new namespace for the tests, to
avoid conflicting with the &quot;real&quot; code. Just as we used <code>mod</code> to specify that
<code>first.rs</code> should be included in <code>lib.rs</code>, we can use <code>mod</code> to basically
create a whole new file <em>inline</em>:</p>
<pre><code class="language-rust ignore">// in first.rs

mod test {
    #[test]
    fn basics() {
        // TODO
    }
}
</code></pre>
<p>And we invoke it with <code>cargo test</code>.</p>
<pre><code class="language-text">&gt; cargo test
   Compiling lists v0.1.0 (/Users/ADesires/dev/temp/lists)
    Finished dev [unoptimized + debuginfo] target(s) in 1.00s
     Running /Users/ADesires/dev/lists/target/debug/deps/lists-86544f1d97438f1f

running 1 test
test first::test::basics ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
; 0 filtered out
</code></pre>
<p>Yay our do-nothing test passed! Let's make it not-do-nothing. We'll do that
with the <code>assert_eq!</code> macro. This isn't some special testing magic. All it
does is compare the two things you give it, and panic the program if they don't
match. Yep, you indicate failure to the test harness by freaking out!</p>
<pre><code class="language-rust ignore">mod test {
    #[test]
    fn basics() {
        let mut list = List::new();

        // Check empty list behaves right
        assert_eq!(list.pop(), None);

        // Populate list
        list.push(1);
        list.push(2);
        list.push(3);

        // Check normal removal
        assert_eq!(list.pop(), Some(3));
        assert_eq!(list.pop(), Some(2));

        // Push some more just to make sure nothing's corrupted
        list.push(4);
        list.push(5);

        // Check normal removal
        assert_eq!(list.pop(), Some(5));
        assert_eq!(list.pop(), Some(4));

        // Check exhaustion
        assert_eq!(list.pop(), Some(1));
        assert_eq!(list.pop(), None);
    }
}
</code></pre>
<pre><code class="language-text">&gt; cargo test

error[E0433]: failed to resolve: use of undeclared type or module `List`
  --&gt; src/first.rs:43:24
   |
43 |         let mut list = List::new();
   |                        ^^^^ use of undeclared type or module `List`


</code></pre>
<p>Oops! Because we made a new module, we need to pull in List explicitly to use
it.</p>
<pre><code class="language-rust ignore">mod test {
    use super::List;
    // everything else the same
}
</code></pre>
<pre><code class="language-text">&gt; cargo test

warning: unused import: `super::List`
  --&gt; src/first.rs:45:9
   |
45 |     use super::List;
   |         ^^^^^^^^^^^
   |
   = note: #[warn(unused_imports)] on by default

    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running /Users/ADesires/dev/lists/target/debug/deps/lists-86544f1d97438f1f

running 1 test
test first::test::basics ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
; 0 filtered out
</code></pre>
<p>Yay!</p>
<p>What's up with that warning though...? We clearly use List in our test!</p>
<p>...but only when testing! To appease the compiler (and to be friendly to our
consumers), we should indicate that the whole <code>test</code> module should only be
compiled if we're running tests.</p>
<pre><code class="language-rust ignore">#[cfg(test)]
mod test {
    use super::List;
    // everything else the same
}
</code></pre>
<p>And that's everything for testing!</p>
<h1><a class="header" href="#drop" id="drop">Drop</a></h1>
<p>We can make a stack, push on to, pop off it, and we've even tested that it all
works right!</p>
<p>Do we need to worry about cleaning up our list? Technically, no, not at all!
Like C++, Rust uses destructors to automatically clean up resources when they're
done with. A type has a destructor if it implements a <em>trait</em> called Drop.
Traits are Rust's fancy term for interfaces. The Drop trait has the following
interface:</p>
<pre><code class="language-rust ignore">pub trait Drop {
    fn drop(&amp;mut self);
}
</code></pre>
<p>Basically, &quot;when you go out of scope, I'll give you a second to clean up your
affairs&quot;.</p>
<p>You don't actually need to implement Drop if you contain types that implement
Drop, and all you'd want to do is call <em>their</em> destructors. In the case of
List, all it would want to do is drop its head, which in turn would <em>maybe</em>
try to drop a <code>Box&lt;Node&gt;</code>. All that's handled for us automatically... with one
hitch.</p>
<p>The automatic handling is going to be bad.</p>
<p>Let's consider a simple list:</p>
<pre><code class="language-text">list -&gt; A -&gt; B -&gt; C
</code></pre>
<p>When <code>list</code> gets dropped, it will try to drop A, which will try to drop B,
which will try to drop C. Some of you might rightly be getting nervous. This is
recursive code, and recursive code can blow the stack!</p>
<p>Some of you might be thinking &quot;this is clearly tail recursive, and any decent
language would ensure that such code wouldn't blow the stack&quot;. This is, in fact,
incorrect! To see why, let's try to write what the compiler has to do, by
manually implementing Drop for our List as the compiler would:</p>
<pre><code class="language-rust ignore">impl Drop for List {
    fn drop(&amp;mut self) {
        // NOTE: you can't actually explicitly call `drop` in real Rust code;
        // we're pretending to be the compiler!
        self.head.drop(); // tail recursive - good!
    }
}

impl Drop for Link {
    fn drop(&amp;mut self) {
        match *self {
            Link::Empty =&gt; {} // Done!
            Link::More(ref mut boxed_node) =&gt; {
                boxed_node.drop(); // tail recursive - good!
            }
        }
    }
}

impl Drop for Box&lt;Node&gt; {
    fn drop(&amp;mut self) {
        self.ptr.drop(); // uh oh, not tail recursive!
        deallocate(self.ptr);
    }
}

impl Drop for Node {
    fn drop(&amp;mut self) {
        self.next.drop();
    }
}
</code></pre>
<p>We <em>can't</em> drop the contents of the Box <em>after</em> deallocating, so there's no
way to drop in a tail-recursive manner! Instead we're going to have to manually
write an iterative drop for <code>List</code> that hoists nodes out of their boxes.</p>
<pre><code class="language-rust ignore">impl Drop for List {
    fn drop(&amp;mut self) {
        let mut cur_link = mem::replace(&amp;mut self.head, Link::Empty);
        // `while let` == &quot;do this thing until this pattern doesn't match&quot;
        while let Link::More(mut boxed_node) = cur_link {
            cur_link = mem::replace(&amp;mut boxed_node.next, Link::Empty);
            // boxed_node goes out of scope and gets dropped here;
            // but its Node's `next` field has been set to Link::Empty
            // so no unbounded recursion occurs.
        }
    }
}
</code></pre>
<pre><code class="language-text">&gt; cargo test

     Running target/debug/lists-5c71138492ad4b4a

running 1 test
test first::test::basics ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

</code></pre>
<p>Great!</p>
<hr />
<p><span style="float:left"><img src="img/profbee.gif" alt="Bonus" /></span></p>
<h2><a class="header" href="#bonus-section-for-premature-optimization" id="bonus-section-for-premature-optimization">Bonus Section For Premature Optimization!</a></h2>
<p>Our implementation of drop is actually <em>very</em> similar to
<code>while let Some(_) = self.pop() { }</code>, which is certainly simpler. How is
it different, and what performance issues could result from it once we start
generalizing our list to store things other than integers?</p>
<details>
  <summary>Click to expand for answer</summary>
<p>Pop returns <code>Option&lt;i32&gt;</code>, while our implementation only manipulates Links (<code>Box&lt;Node&gt;</code>). So our implementation only moves around pointers to nodes, while the pop-based one will move around the values we stored in nodes. This could be very expensive if we generalize our list and someone uses it to store instances of VeryBigThingWithADropImpl (VBTWADI). Box is able to run the drop implementation of its contents in-place, so it doesn't suffer from this issue. Since VBTWADI is <em>exactly</em> the kind of thing that actually makes using a linked-list desirable over an array, behaving poorly on this case would be a bit of a disappointment.</p>
<p>If you wish to have the best of both implementations, you could add a new method,
<code>fn pop_node(&amp;mut self) -&gt; Link</code>, from-which <code>pop</code> and <code>drop</code> can both be cleanly derived.</p>
</details>
<h1><a class="header" href="#the-final-code" id="the-final-code">The Final Code</a></h1>
<p>Alright, 6000 words later, here's all the code we managed to actually write:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::mem;

pub struct List {
    head: Link,
}

enum Link {
    Empty,
    More(Box&lt;Node&gt;),
}

struct Node {
    elem: i32,
    next: Link,
}

impl List {
    pub fn new() -&gt; Self {
        List { head: Link::Empty }
    }

    pub fn push(&amp;mut self, elem: i32) {
        let new_node = Box::new(Node {
            elem: elem,
            next: mem::replace(&amp;mut self.head, Link::Empty),
        });

        self.head = Link::More(new_node);
    }

    pub fn pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
        match mem::replace(&amp;mut self.head, Link::Empty) {
            Link::Empty =&gt; None,
            Link::More(node) =&gt; {
                self.head = node.next;
                Some(node.elem)
            }
        }
    }
}

impl Drop for List {
    fn drop(&amp;mut self) {
        let mut cur_link = mem::replace(&amp;mut self.head, Link::Empty);

        while let Link::More(mut boxed_node) = cur_link {
            cur_link = mem::replace(&amp;mut boxed_node.next, Link::Empty);
        }
    }
}

#[cfg(test)]
mod test {
    use super::List;

    #[test]
    fn basics() {
        let mut list = List::new();

        // Check empty list behaves right
        assert_eq!(list.pop(), None);

        // Populate list
        list.push(1);
        list.push(2);
        list.push(3);

        // Check normal removal
        assert_eq!(list.pop(), Some(3));
        assert_eq!(list.pop(), Some(2));

        // Push some more just to make sure nothing's corrupted
        list.push(4);
        list.push(5);

        // Check normal removal
        assert_eq!(list.pop(), Some(5));
        assert_eq!(list.pop(), Some(4));

        // Check exhaustion
        assert_eq!(list.pop(), Some(1));
        assert_eq!(list.pop(), None);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Geez. 80 lines, and half of it was tests! Well, I did say this first one was
going to take a while!</p>
<h1><a class="header" href="#an-ok-singly-linked-stack" id="an-ok-singly-linked-stack">An Ok Singly-Linked Stack</a></h1>
<p>In the previous chapter we wrote up a minimum viable singly-linked
stack. However there's a few design decisions that make it kind of sucky.
Let's make it less sucky. In doing so, we will:</p>
<ul>
<li>Deinvent the wheel</li>
<li>Make our list able to handle any element type</li>
<li>Add peeking</li>
<li>Make our list iterable</li>
</ul>
<p>And in the process we'll learn about</p>
<ul>
<li>Advanced Option use</li>
<li>Generics</li>
<li>Lifetimes</li>
<li>Iterators</li>
</ul>
<p>Let's add a new file called <code>second.rs</code>:</p>
<pre><code class="language-rust ignore">// in lib.rs

pub mod first;
pub mod second;
</code></pre>
<p>And copy everything from <code>first.rs</code> into it.</p>
<h1><a class="header" href="#using-option" id="using-option">Using Option</a></h1>
<p>Particularly observant readers may have noticed that we actually reinvented
a really bad version of Option:</p>
<pre><code class="language-rust ignore">enum Link {
    Empty,
    More(Box&lt;Node&gt;),
}
</code></pre>
<p>Link is just <code>Option&lt;Box&lt;Node&gt;&gt;</code>. Now, it's nice not to have to write
<code>Option&lt;Box&lt;Node&gt;&gt;</code> everywhere, and unlike <code>pop</code>, we're not exposing this
to the outside world, so maybe it's fine. However Option has some <em>really
nice</em> methods that we've been manually implementing ourselves. Let's <em>not</em>
do that, and replace everything with Options. First, we'll do it naively
by just renaming everything to use Some and None:</p>
<pre><code class="language-rust ignore">use std::mem;

pub struct List {
    head: Link,
}

// yay type aliases!
type Link = Option&lt;Box&lt;Node&gt;&gt;;

struct Node {
    elem: i32,
    next: Link,
}

impl List {
    pub fn new() -&gt; Self {
        List { head: None }
    }

    pub fn push(&amp;mut self, elem: i32) {
        let new_node = Box::new(Node {
            elem: elem,
            next: mem::replace(&amp;mut self.head, None),
        });

        self.head = Some(new_node);
    }

    pub fn pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
        match mem::replace(&amp;mut self.head, None) {
            None =&gt; None,
            Some(node) =&gt; {
                self.head = node.next;
                Some(node.elem)
            }
        }
    }
}

impl Drop for List {
    fn drop(&amp;mut self) {
        let mut cur_link = mem::replace(&amp;mut self.head, None);
        while let Some(mut boxed_node) = cur_link {
            cur_link = mem::replace(&amp;mut boxed_node.next, None);
        }
    }
}
</code></pre>
<p>This is marginally better, but the big wins will come from Option's methods.</p>
<p>First, <code>mem::replace(&amp;mut option, None)</code> is such an incredibly
common idiom that Option actually just went ahead and made it a method: <code>take</code>.</p>
<pre><code class="language-rust ignore">pub struct List {
    head: Link,
}

type Link = Option&lt;Box&lt;Node&gt;&gt;;

struct Node {
    elem: i32,
    next: Link,
}

impl List {
    pub fn new() -&gt; Self {
        List { head: None }
    }

    pub fn push(&amp;mut self, elem: i32) {
        let new_node = Box::new(Node {
            elem: elem,
            next: self.head.take(),
        });

        self.head = Some(new_node);
    }

    pub fn pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
        match self.head.take() {
            None =&gt; None,
            Some(node) =&gt; {
                self.head = node.next;
                Some(node.elem)
            }
        }
    }
}

impl Drop for List {
    fn drop(&amp;mut self) {
        let mut cur_link = self.head.take();
        while let Some(mut boxed_node) = cur_link {
            cur_link = boxed_node.next.take();
        }
    }
}
</code></pre>
<p>Second, <code>match option { None =&gt; None, Some(x) =&gt; Some(y) }</code> is such an
incredibly common idiom that it was called <code>map</code>. <code>map</code> takes a function to
execute on the <code>x</code> in the <code>Some(x)</code> to produce the <code>y</code> in <code>Some(y)</code>. We could
write a proper <code>fn</code> and pass it to <code>map</code>, but we'd much rather write what to
do <em>inline</em>.</p>
<p>The way to do this is with a <em>closure</em>. Closures are anonymous functions with
an extra super-power: they can refer to local variables <em>outside</em> the closure!
This makes them super useful for doing all sorts of conditional logic. The
only place we do a <code>match</code> is in <code>pop</code>, so let's just rewrite that:</p>
<pre><code class="language-rust ignore">pub fn pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
    self.head.take().map(|node| {
        self.head = node.next;
        node.elem
    })
}
</code></pre>
<p>Ah, much better. Let's make sure we didn't break anything:</p>
<pre><code class="language-text">&gt; cargo test

     Running target/debug/lists-5c71138492ad4b4a

running 2 tests
test first::test::basics ... ok
test second::test::basics ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured

</code></pre>
<p>Great! Let's move on to actually improving the code's <em>behaviour</em>.</p>
<h1><a class="header" href="#making-it-all-generic" id="making-it-all-generic">Making it all Generic</a></h1>
<p>We've already touched a bit on generics with Option and Box. However so
far we've managed to avoid declaring any new type that is actually generic
over arbitrary elements.</p>
<p>It turns out that's actually really easy. Let's make all of our types generic
right now:</p>
<pre><code class="language-rust ignore">pub struct List&lt;T&gt; {
    head: Link&lt;T&gt;,
}

type Link&lt;T&gt; = Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;;

struct Node&lt;T&gt; {
    elem: T,
    next: Link&lt;T&gt;,
}
</code></pre>
<p>You just make everything a little more pointy, and suddenly your code is
generic. Of course, we can't <em>just</em> do this, or else the compiler's going
to be Super Mad.</p>
<pre><code class="language-text">&gt; cargo test

error[E0107]: wrong number of type arguments: expected 1, found 0
  --&gt; src/second.rs:14:6
   |
14 | impl List {
   |      ^^^^ expected 1 type argument

error[E0107]: wrong number of type arguments: expected 1, found 0
  --&gt; src/second.rs:36:15
   |
36 | impl Drop for List {
   |               ^^^^ expected 1 type argument

</code></pre>
<p>The problem is pretty clear: we're talking about this <code>List</code> thing but that's not
real anymore. Like Option and Box, we now always have to talk about
<code>List&lt;Something&gt;</code>.</p>
<p>But what's the Something we use in all these impls? Just like List, we want our
implementations to work with <em>all</em> the T's. So, just like List, let's make our
<code>impl</code>s pointy:</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; List&lt;T&gt; {
    pub fn new() -&gt; Self {
        List { head: None }
    }

    pub fn push(&amp;mut self, elem: T) {
        let new_node = Box::new(Node {
            elem: elem,
            next: self.head.take(),
        });

        self.head = Some(new_node);
    }

    pub fn pop(&amp;mut self) -&gt; Option&lt;T&gt; {
        self.head.take().map(|node| {
            self.head = node.next;
            node.elem
        })
    }
}

impl&lt;T&gt; Drop for List&lt;T&gt; {
    fn drop(&amp;mut self) {
        let mut cur_link = self.head.take();
        while let Some(mut boxed_node) = cur_link {
            cur_link = boxed_node.next.take();
        }
    }
}
</code></pre>
<p>...and that's it!</p>
<pre><code class="language-text">&gt; cargo test

     Running target/debug/lists-5c71138492ad4b4a

running 2 tests
test first::test::basics ... ok
test second::test::basics ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured

</code></pre>
<p>All of our code is now completely generic over arbitrary values of T. Dang,
Rust is <em>easy</em>. I'd like to make a particular shout-out to <code>new</code> which didn't
even change:</p>
<pre><code class="language-rust ignore">pub fn new() -&gt; Self {
    List { head: None }
}
</code></pre>
<p>Bask in the Glory that is Self, guardian of refactoring and copy-pasta coding.
Also of interest, we don't write <code>List&lt;T&gt;</code> when we construct an instance of
list. That part's inferred for us based on the fact that we're returning it
from a function that expects a <code>List&lt;T&gt;</code>.</p>
<p>Alright, let's move on to totally new <em>behaviour</em>!</p>
<h1><a class="header" href="#peek" id="peek">Peek</a></h1>
<p>One thing we didn't even bother to implement last time was peeking. Let's go
ahead and do that. All we need to do is return a reference to the element in
the head of the list, if it exists. Sounds easy, let's try:</p>
<pre><code class="language-rust ignore">pub fn peek(&amp;self) -&gt; Option&lt;&amp;T&gt; {
    self.head.map(|node| {
        &amp;node.elem
    })
}
</code></pre>
<pre><code class="language-text">&gt; cargo build

error[E0515]: cannot return reference to local data `node.elem`
  --&gt; src/second.rs:37:13
   |
37 |             &amp;node.elem
   |             ^^^^^^^^^^ returns a reference to data owned by the current function

error[E0507]: cannot move out of borrowed content
  --&gt; src/second.rs:36:9
   |
36 |         self.head.map(|node| {
   |         ^^^^^^^^^ cannot move out of borrowed content


</code></pre>
<p><em>Sigh</em>. What now, Rust?</p>
<p>Map takes <code>self</code> by value, which would move the Option out of the thing it's in.
Previously this was fine because we had just <code>take</code>n it out, but now we actually
want to leave it where it was. The <em>correct</em> way to handle this is with the
<code>as_ref</code> method on Option, which has the following definition:</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; Option&lt;T&gt; {
    pub fn as_ref(&amp;self) -&gt; Option&lt;&amp;T&gt;;
}
</code></pre>
<p>It demotes the <code>Option&lt;T&gt;</code> to an Option to a reference to its internals. We could
do this ourselves with an explicit match but <em>ugh no</em>. It does mean that we
need to do an extra dereference to cut through the extra indirection, but
thankfully the <code>.</code> operator handles that for us.</p>
<pre><code class="language-rust ignore">pub fn peek(&amp;self) -&gt; Option&lt;&amp;T&gt; {
    self.head.as_ref().map(|node| {
        &amp;node.elem
    })
}
</code></pre>
<pre><code class="language-text">cargo build

    Finished dev [unoptimized + debuginfo] target(s) in 0.32s
</code></pre>
<p>Nailed it.</p>
<p>We can also make a <em>mutable</em> version of this method using <code>as_mut</code>:</p>
<pre><code class="language-rust ignore">pub fn peek_mut(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt; {
    self.head.as_mut().map(|node| {
        &amp;mut node.elem
    })
}
</code></pre>
<pre><code class="language-text">&gt; cargo build

</code></pre>
<p>EZ</p>
<p>Don't forget to test it:</p>
<pre><code class="language-rust ignore">#[test]
fn peek() {
    let mut list = List::new();
    assert_eq!(list.peek(), None);
    assert_eq!(list.peek_mut(), None);
    list.push(1); list.push(2); list.push(3);

    assert_eq!(list.peek(), Some(&amp;3));
    assert_eq!(list.peek_mut(), Some(&amp;mut 3));
}
</code></pre>
<pre><code class="language-text">cargo test

     Running target/debug/lists-5c71138492ad4b4a

running 3 tests
test first::test::basics ... ok
test second::test::basics ... ok
test second::test::peek ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured

</code></pre>
<p>That's nice, but we didn't really test to see if we could mutate that <code>peek_mut</code> return value, did we?  If a reference is mutable but nobody mutates it, have we really tested the mutability?  Let's try using <code>map</code> on this <code>Option&lt;&amp;mut T&gt;</code> to put a profound value in:</p>
<pre><code class="language-rust ignore">#[test]
fn peek() {
    let mut list = List::new();
    assert_eq!(list.peek(), None);
    assert_eq!(list.peek_mut(), None);
    list.push(1); list.push(2); list.push(3);

    assert_eq!(list.peek(), Some(&amp;3));
    assert_eq!(list.peek_mut(), Some(&amp;mut 3));
    list.peek_mut().map(|&amp;mut value| {
        value = 42
    });

    assert_eq!(list.peek(), Some(&amp;42));
    assert_eq!(list.pop(), Some(42));
}
</code></pre>
<pre><code class="language-text">&gt; cargo test

error[E0384]: cannot assign twice to immutable variable `value`
   --&gt; src/second.rs:100:13
    |
99  |         list.peek_mut().map(|&amp;mut value| {
    |                                   -----
    |                                   |
    |                                   first assignment to `value`
    |                                   help: make this binding mutable: `mut value`
100 |             value = 42
    |             ^^^^^^^^^^ cannot assign twice to immutable variable          ^~~~~
</code></pre>
<p>The compiler is complaining that <code>value</code> is immutable, but we pretty clearly wrote <code>&amp;mut value</code>; what gives? It turns out that writing the argument of the closure that way doesn't specify that <code>value</code> is a mutable reference. Instead, it creates a pattern that will be matched against the argument to the closure; <code>|&amp;mut value|</code> means &quot;the argument is a mutable reference, but just copy the value it points to into <code>value</code>, please.&quot;  If we just use <code>|value|</code>, the type of <code>value</code> will be <code>&amp;mut i32</code> and we can actually mutate the head:</p>
<pre><code class="language-rust ignore">    #[test]
    fn peek() {
        let mut list = List::new();
        assert_eq!(list.peek(), None);
        assert_eq!(list.peek_mut(), None);
        list.push(1); list.push(2); list.push(3);

        assert_eq!(list.peek(), Some(&amp;3));
        assert_eq!(list.peek_mut(), Some(&amp;mut 3));

        list.peek_mut().map(|value| {
            *value = 42
        });

        assert_eq!(list.peek(), Some(&amp;42));
        assert_eq!(list.pop(), Some(42));
    }
</code></pre>
<pre><code class="language-text">cargo test

     Running target/debug/lists-5c71138492ad4b4a

running 3 tests
test first::test::basics ... ok
test second::test::basics ... ok
test second::test::peek ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured

</code></pre>
<p>Much better!</p>
<h1><a class="header" href="#intoiter" id="intoiter">IntoIter</a></h1>
<p>Collections are iterated in Rust using the <em>Iterator</em> trait. It's a bit more
complicated than <code>Drop</code>:</p>
<pre><code class="language-rust ignore">pub trait Iterator {
    type Item;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}
</code></pre>
<p>The new kid on the block here is <code>type Item</code>. This is declaring that every
implementation of Iterator has an <em>associated type</em> called Item. In this case,
this is the type that it can spit out when you call <code>next</code>.</p>
<p>The reason Iterator yields <code>Option&lt;Self::Item&gt;</code> is because the interface
coalesces the <code>has_next</code> and <code>get_next</code> concepts. When you have the next value,
you yield
<code>Some(value)</code>, and when you don't you yield <code>None</code>. This makes the
API generally more ergonomic and safe to use and implement, while avoiding
redundant checks and logic between <code>has_next</code> and <code>get_next</code>. Nice!</p>
<p>Sadly, Rust has nothing like a <code>yield</code> statement (yet), so we're going to have to
implement the logic ourselves. Also, there's actually 3 different kinds of
iterator each collection should endeavour to implement:</p>
<ul>
<li>IntoIter - <code>T</code></li>
<li>IterMut - <code>&amp;mut T</code></li>
<li>Iter - <code>&amp;T</code></li>
</ul>
<p>We actually already have all the tools to implement
IntoIter using List's interface: just call <code>pop</code> over and over. As such, we'll
just implement IntoIter as a newtype wrapper around List:</p>
<pre><code class="language-rust ignore">// Tuple structs are an alternative form of struct,
// useful for trivial wrappers around other types.
pub struct IntoIter&lt;T&gt;(List&lt;T&gt;);

impl&lt;T&gt; List&lt;T&gt; {
    pub fn into_iter(self) -&gt; IntoIter&lt;T&gt; {
        IntoIter(self)
    }
}

impl&lt;T&gt; Iterator for IntoIter&lt;T&gt; {
    type Item = T;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        // access fields of a tuple struct numerically
        self.0.pop()
    }
}
</code></pre>
<p>And let's write a test:</p>
<pre><code class="language-rust ignore">#[test]
fn into_iter() {
    let mut list = List::new();
    list.push(1); list.push(2); list.push(3);

    let mut iter = list.into_iter();
    assert_eq!(iter.next(), Some(3));
    assert_eq!(iter.next(), Some(2));
    assert_eq!(iter.next(), Some(1));
    assert_eq!(iter.next(), None);
}
</code></pre>
<pre><code class="language-text">&gt; cargo test

     Running target/debug/lists-5c71138492ad4b4a

running 4 tests
test first::test::basics ... ok
test second::test::basics ... ok
test second::test::into_iter ... ok
test second::test::peek ... ok

test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured

</code></pre>
<p>Nice!</p>
<h1><a class="header" href="#iter" id="iter">Iter</a></h1>
<p>Alright, let's try to implement Iter. This time we won't be able to rely on
List giving us all the features we want. We'll need to roll our own. The
basic logic we want is to hold a pointer to the current node we want to yield
next. Because that node may not exist (the list is empty or we're otherwise
done iterating), we want that reference to be an Option. When we yield an
element, we want to proceed to the current node's <code>next</code> node.</p>
<p>Alright, let's try that:</p>
<pre><code class="language-rust ignore">pub struct Iter&lt;T&gt; {
    next: Option&lt;&amp;Node&lt;T&gt;&gt;,
}

impl&lt;T&gt; List&lt;T&gt; {
    pub fn iter(&amp;self) -&gt; Iter&lt;T&gt; {
        Iter { next: self.head.map(|node| &amp;node) }
    }
}

impl&lt;T&gt; Iterator for Iter&lt;T&gt; {
    type Item = &amp;T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.next.map(|node| {
            self.next = node.next.map(|node| &amp;node);
            &amp;node.elem
        })
    }
}
</code></pre>
<pre><code class="language-text">&gt; cargo build

error[E0106]: missing lifetime specifier
  --&gt; src/second.rs:72:18
   |
72 |     next: Option&lt;&amp;Node&lt;T&gt;&gt;,
   |                  ^ expected lifetime parameter

error[E0106]: missing lifetime specifier
  --&gt; src/second.rs:82:17
   |
82 |     type Item = &amp;T;
   |                 ^ expected lifetime parameter
</code></pre>
<p>Oh god. Lifetimes. I've heard of these things. I hear they're a nightmare.</p>
<p>Let's try something new: see that <code>error[E0106]</code> thing? That's a compiler error
code. We can ask rustc to explain those with, well, <code>--explain</code>:</p>
<pre><code class="language-text">&gt; rustc --explain E0106
This error indicates that a lifetime is missing from a type. If it is an error
inside a function signature, the problem may be with failing to adhere to the
lifetime elision rules (see below).

Here are some simple examples of where you'll run into this error:

struct Foo { x: &amp;bool }        // error
struct Foo&lt;'a&gt; { x: &amp;'a bool } // correct

enum Bar { A(u8), B(&amp;bool), }        // error
enum Bar&lt;'a&gt; { A(u8), B(&amp;'a bool), } // correct

type MyStr = &amp;str;        // error
type MyStr&lt;'a&gt; = &amp;'a str; //correct
...

</code></pre>
<p>That uh... that didn't really clarify much (these docs assume we understand
Rust better than we currently do). But it looks like we should add
those <code>'a</code> things to our struct? Let's try that.</p>
<pre><code class="language-rust ignore">pub struct Iter&lt;'a, T&gt; {
    next: Option&lt;&amp;'a Node&lt;T&gt;&gt;,
}
</code></pre>
<pre><code class="language-text">&gt; cargo build

error[E0106]: missing lifetime specifier
  --&gt; src/second.rs:83:22
   |
83 | impl&lt;T&gt; Iterator for Iter&lt;T&gt; {
   |                      ^^^^^^^ expected lifetime parameter

error[E0106]: missing lifetime specifier
  --&gt; src/second.rs:84:17
   |
84 |     type Item = &amp;T;
   |                 ^ expected lifetime parameter

error: aborting due to 2 previous errors
</code></pre>
<p>Alright I'm starting to see a pattern here... let's just add these little guys
to everything we can:</p>
<pre><code class="language-rust ignore">pub struct Iter&lt;'a, T&gt; {
    next: Option&lt;&amp;'a Node&lt;T&gt;&gt;,
}

impl&lt;'a, T&gt; List&lt;T&gt; {
    pub fn iter(&amp;'a self) -&gt; Iter&lt;'a, T&gt; {
        Iter { next: self.head.map(|node| &amp;'a node) }
    }
}

impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {
    type Item = &amp;'a T;
    fn next(&amp;'a mut self) -&gt; Option&lt;Self::Item&gt; {
        self.next.map(|node| {
            self.next = node.next.map(|node| &amp;'a node);
            &amp;'a node.elem
        })
    }
}
</code></pre>
<pre><code class="language-text">&gt; cargo build

error: expected `:`, found `node`
  --&gt; src/second.rs:77:47
   |
77 |         Iter { next: self.head.map(|node| &amp;'a node) }
   |         ---- while parsing this struct        ^^^^ expected `:`

error: expected `:`, found `node`
  --&gt; src/second.rs:85:50
   |
85 |             self.next = node.next.map(|node| &amp;'a node);
   |                                                  ^^^^ expected `:`

error[E0063]: missing field `next` in initializer of `second::Iter&lt;'_, _&gt;`
  --&gt; src/second.rs:77:9
   |
77 |         Iter { next: self.head.map(|node| &amp;'a node) }
   |         ^^^^ missing `next`
</code></pre>
<p>Oh god. We broke Rust.</p>
<p>Maybe we should actually figure out what the heck this <code>'a</code> lifetime stuff
even means.</p>
<p>Lifetimes can scare off a lot of people because
they're a change to something we've known and loved since the dawn of
programming. We've actually managed to dodge lifetimes so far, even though
they've been tangled throughout our programs this whole time.</p>
<p>Lifetimes are unnecessary in garbage collected languages because the garbage
collector ensures that everything magically lives as long as it needs to. Most
data in Rust is <em>manually</em> managed, so that data needs another solution. C and
C++ give us a clear example what happens if you just let people take pointers
to random data on the stack: pervasive unmanageable unsafety. This can be
roughly separated into two classes of error:</p>
<ul>
<li>Holding a pointer to something that went out of scope</li>
<li>Holding a pointer to something that got mutated away</li>
</ul>
<p>Lifetimes solve both of these problems, and 99% of the time, they do this in
a totally transparent way.</p>
<p>So what's a lifetime?</p>
<p>Quite simply, a lifetime is the name of a region (~block/scope) of code somewhere in a program.
That's it. When a reference is tagged with a lifetime, we're saying that it
has to be valid for that <em>entire</em> region. Different things place requirements on
how long a reference must and can be valid for. The entire lifetime system is in
turn just a constraint-solving system that tries to minimize the region of every
reference. If it successfully finds a set of lifetimes that satisfies all the
constraints, your program compiles! Otherwise you get an error back saying that
something didn't live long enough.</p>
<p>Within a function body you generally can't talk about lifetimes, and wouldn't
want to <em>anyway</em>. The compiler has full information and can infer all the
constraints to find the minimum lifetimes. However at the type and API-level,
the compiler <em>doesn't</em> have all the information. It requires you to tell it
about the relationship between different lifetimes so it can figure out what
you're doing.</p>
<p>In principle, those lifetimes <em>could</em> also be left out, but
then checking all the borrows would be a huge whole-program analysis that would
produce mind-bogglingly non-local errors. Rust's system means all borrow
checking can be done in each function body independently, and all your errors
should be fairly local (or your types have incorrect signatures).</p>
<p>But we've written references in function signatures before, and it was fine!
That's because there are certain cases that are so common that Rust will
automatically pick the lifetimes for you. This is <em>lifetime elision</em>.</p>
<p>In particular:</p>
<pre><code class="language-rust ignore">// Only one reference in input, so the output must be derived from that input
fn foo(&amp;A) -&gt; &amp;B; // sugar for:
fn foo&lt;'a&gt;(&amp;'a A) -&gt; &amp;'a B;

// Many inputs, assume they're all independent
fn foo(&amp;A, &amp;B, &amp;C); // sugar for:
fn foo&lt;'a, 'b, 'c&gt;(&amp;'a A, &amp;'b B, &amp;'c C);

// Methods, assume all output lifetimes are derived from `self`
fn foo(&amp;self, &amp;B, &amp;C) -&gt; &amp;D; // sugar for:
fn foo&lt;'a, 'b, 'c&gt;(&amp;'a self, &amp;'b B, &amp;'c C) -&gt; &amp;'a D;
</code></pre>
<p>So what does <code>fn foo&lt;'a&gt;(&amp;'a A) -&gt; &amp;'a B</code> <em>mean</em>? In practical terms, all it
means is that the input must live at least as long as the output. So if you keep
the output around for a long time, this will expand the region that the input must
be valid for. Once you stop using the output, the compiler will know it's ok for
the input to become invalid too.</p>
<p>With this system set up, Rust can ensure nothing is used after free, and nothing
is mutated while outstanding references exist. It just makes sure the
constraints all work out!</p>
<p>Alright. So. Iter.</p>
<p>Let's roll back to the no lifetimes state:</p>
<pre><code class="language-rust ignore">pub struct Iter&lt;T&gt; {
    next: Option&lt;&amp;Node&lt;T&gt;&gt;,
}

impl&lt;T&gt; List&lt;T&gt; {
    pub fn iter(&amp;self) -&gt; Iter&lt;T&gt; {
        Iter { next: self.head.map(|node| &amp;node) }
    }
}

impl&lt;T&gt; Iterator for Iter&lt;T&gt; {
    type Item = &amp;T;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.next.map(|node| {
            self.next = node.next.map(|node| &amp;node);
            &amp;node.elem
        })
    }
}
</code></pre>
<p>We need to add lifetimes only in function and type signatures:</p>
<pre><code class="language-rust ignore">// Iter is generic over *some* lifetime, it doesn't care
pub struct Iter&lt;'a, T&gt; {
    next: Option&lt;&amp;'a Node&lt;T&gt;&gt;,
}

// No lifetime here, List doesn't have any associated lifetimes
impl&lt;T&gt; List&lt;T&gt; {
    // We declare a fresh lifetime here for the *exact* borrow that
    // creates the iter. Now &amp;self needs to be valid as long as the
    // Iter is around.
    pub fn iter&lt;'a&gt;(&amp;'a self) -&gt; Iter&lt;'a, T&gt; {
        Iter { next: self.head.map(|node| &amp;node) }
    }
}

// We *do* have a lifetime here, because Iter has one that we need to define
impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {
    // Need it here too, this is a type declaration
    type Item = &amp;'a T;

    // None of this needs to change, handled by the above.
    // Self continues to be incredibly hype and amazing
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.next.map(|node| {
            self.next = node.next.map(|node| &amp;node);
            &amp;node.elem
        })
    }
}
</code></pre>
<p>Alright, I think we got it this time y'all.</p>
<pre><code class="language-text">cargo build

error[E0308]: mismatched types
  --&gt; src/second.rs:77:22
   |
77 |         Iter { next: self.head.map(|node| &amp;node) }
   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `second::Node`, found struct `std::boxed::Box`
   |
   = note: expected type `std::option::Option&lt;&amp;second::Node&lt;T&gt;&gt;`
              found type `std::option::Option&lt;&amp;std::boxed::Box&lt;second::Node&lt;T&gt;&gt;&gt;`

error[E0308]: mismatched types
  --&gt; src/second.rs:85:25
   |
85 |             self.next = node.next.map(|node| &amp;node);
   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `second::Node`, found struct `std::boxed::Box`
   |
   = note: expected type `std::option::Option&lt;&amp;'a second::Node&lt;T&gt;&gt;`
              found type `std::option::Option&lt;&amp;std::boxed::Box&lt;second::Node&lt;T&gt;&gt;&gt;`
</code></pre>
<p>(╯°□°)╯︵ ┻━┻</p>
<p>OK. SO. We fixed our lifetime errors but now we're getting some new type errors.</p>
<p>We want to be storing <code>&amp;Node</code>'s, but we're getting <code>&amp;Box&lt;Node&gt;</code>s. Ok, that's easy
enough, we just need to dereference the Box before we take our reference:</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; List&lt;T&gt; {
    pub fn iter&lt;'a&gt;(&amp;'a self) -&gt; Iter&lt;'a, T&gt; {
        Iter { next: self.head.map(|node| &amp;*node) }
    }
}

impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {
    type Item = &amp;'a T;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.next.map(|node| {
            self.next = node.next.map(|node| &amp;*node);
            &amp;node.elem
        })
    }
}
</code></pre>
<pre><code class="language-text">cargo build
   Compiling lists v0.1.0 (/Users/ADesires/dev/temp/lists)
error[E0515]: cannot return reference to local data `*node`
  --&gt; src/second.rs:77:43
   |
77 |         Iter { next: self.head.map(|node| &amp;*node) }
   |                                           ^^^^^^ returns a reference to data owned by the current function

error[E0507]: cannot move out of borrowed content
  --&gt; src/second.rs:77:22
   |
77 |         Iter { next: self.head.map(|node| &amp;*node) }
   |                      ^^^^^^^^^ cannot move out of borrowed content

error[E0515]: cannot return reference to local data `*node`
  --&gt; src/second.rs:85:46
   |
85 |             self.next = node.next.map(|node| &amp;*node);
   |                                              ^^^^^^ returns a reference to data owned by the current function

error[E0507]: cannot move out of borrowed content
  --&gt; src/second.rs:85:25
   |
85 |             self.next = node.next.map(|node| &amp;*node);
   |                         ^^^^^^^^^ cannot move out of borrowed content
</code></pre>
<p>(ﾉಥ益ಥ）ﾉ﻿ ┻━┻</p>
<p>We forgot <code>as_ref</code>, so we're moving the box into <code>map</code>, which means it would
be dropped, which means our references would be dangling:</p>
<pre><code class="language-rust ignore">pub struct Iter&lt;'a, T&gt; {
    next: Option&lt;&amp;'a Node&lt;T&gt;&gt;,
}

impl&lt;T&gt; List&lt;T&gt; {
    pub fn iter&lt;'a&gt;(&amp;'a self) -&gt; Iter&lt;'a, T&gt; {
        Iter { next: self.head.as_ref().map(|node| &amp;*node) }
    }
}

impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {
    type Item = &amp;'a T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.next.map(|node| {
            self.next = node.next.as_ref().map(|node| &amp;*node);
            &amp;node.elem
        })
    }
}
</code></pre>
<pre><code class="language-text">cargo build
   Compiling lists v0.1.0 (/Users/ADesires/dev/temp/lists)
error[E0308]: mismatched types
  --&gt; src/second.rs:77:22
   |
77 |         Iter { next: self.head.as_ref().map(|node| &amp;*node) }
   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `second::Node`, found struct `std::boxed::Box`
   |
   = note: expected type `std::option::Option&lt;&amp;second::Node&lt;T&gt;&gt;`
              found type `std::option::Option&lt;&amp;std::boxed::Box&lt;second::Node&lt;T&gt;&gt;&gt;`

error[E0308]: mismatched types
  --&gt; src/second.rs:85:25
   |
85 |             self.next = node.next.as_ref().map(|node| &amp;*node);
   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `second::Node`, found struct `std::boxed::Box`
   |
   = note: expected type `std::option::Option&lt;&amp;'a second::Node&lt;T&gt;&gt;`
              found type `std::option::Option&lt;&amp;std::boxed::Box&lt;second::Node&lt;T&gt;&gt;&gt;`

</code></pre>
<p>😭</p>
<p><code>as_ref</code> added another layer of indirection we need to remove:</p>
<pre><code class="language-rust ignore">pub struct Iter&lt;'a, T&gt; {
    next: Option&lt;&amp;'a Node&lt;T&gt;&gt;,
}

impl&lt;T&gt; List&lt;T&gt; {
    pub fn iter&lt;'a&gt;(&amp;'a self) -&gt; Iter&lt;'a, T&gt; {
        Iter { next: self.head.as_deref() }
    }
}

impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {
    type Item = &amp;'a T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.next.map(|node| {
            self.next = node.next.as_deref();
            &amp;node.elem
        })
    }
}
</code></pre>
<pre><code class="language-text">cargo build

</code></pre>
<p>🎉 🎉 🎉</p>
<p>The as_deref and as_deref_mut functions are stable as of Rust 1.40. Before that you
would need to do <code>map(|node| &amp;**node)</code> and <code>map(|node| &amp;mut**node)</code>.
You may be thinking &quot;wow that <code>&amp;**</code> thing is really janky&quot;, and you're not wrong,
but like a fine wine Rust gets better over time and we no longer need to do such.
Normally Rust is very good at doing this kind of conversion implicitly, through
a process called <em>deref coercion</em>, where basically it can insert *'s
throughout your code to make it type-check. It can do this because we have the
borrow checker to ensure we never mess up pointers!</p>
<p>But in this case the closure in conjunction with the fact that we
have an <code>Option&lt;&amp;T&gt;</code> instead of <code>&amp;T</code> is a bit too complicated for it to work
out, so we need to help it by being explicit. Thankfully this is pretty rare, in my experience.</p>
<p>Just for completeness' sake, we <em>could</em> give it a <em>different</em> hint with the <em>turbofish</em>:</p>
<pre><code class="language-rust ignore">    self.next = node.next.as_ref().map::&lt;&amp;Node&lt;T&gt;, _&gt;(|node| &amp;node);
</code></pre>
<p>See, map is a generic function:</p>
<pre><code class="language-rust ignore">pub fn map&lt;U, F&gt;(self, f: F) -&gt; Option&lt;U&gt;
</code></pre>
<p>The turbofish, <code>::&lt;&gt;</code>, lets us tell the compiler what we think the types of those
generics should be. In this case <code>::&lt;&amp;Node&lt;T&gt;, _&gt;</code> says &quot;it should return a
<code>&amp;Node&lt;T&gt;</code>, and I don't know/care about that other type&quot;.</p>
<p>This in turn lets the compiler know that <code>&amp;node</code> should have deref coercion
applied to it, so we don't need to manually apply all those *'s!</p>
<p>But in this case I don't think it's really an improvement, this was just a
thinly veiled excuse to show off deref coercion and the sometimes-useful turbofish. 😅</p>
<p>Let's write a test to be sure we didn't no-op it or anything:</p>
<pre><code class="language-rust ignore">#[test]
fn iter() {
    let mut list = List::new();
    list.push(1); list.push(2); list.push(3);

    let mut iter = list.iter();
    assert_eq!(iter.next(), Some(&amp;3));
    assert_eq!(iter.next(), Some(&amp;2));
    assert_eq!(iter.next(), Some(&amp;1));
}
</code></pre>
<pre><code class="language-text">&gt; cargo test

     Running target/debug/lists-5c71138492ad4b4a

running 5 tests
test first::test::basics ... ok
test second::test::basics ... ok
test second::test::into_iter ... ok
test second::test::iter ... ok
test second::test::peek ... ok

test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured

</code></pre>
<p>Heck yeah.</p>
<p>Finally, it should be noted that we <em>can</em> actually apply lifetime elision here:</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; List&lt;T&gt; {
    pub fn iter&lt;'a&gt;(&amp;'a self) -&gt; Iter&lt;'a, T&gt; {
        Iter { next: self.head.as_deref() }
    }
}
</code></pre>
<p>is equivalent to:</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; List&lt;T&gt; {
    pub fn iter(&amp;self) -&gt; Iter&lt;T&gt; {
        Iter { next: self.head.as_deref() }
    }
}
</code></pre>
<p>Yay fewer lifetimes!</p>
<p>Or, if you're not comfortable &quot;hiding&quot; that a struct contains a lifetime,
you can use the Rust 2018 &quot;explicitly elided lifetime&quot; syntax,  <code>'_</code>:</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; List&lt;T&gt; {
    pub fn iter(&amp;self) -&gt; Iter&lt;'_, T&gt; {
        Iter { next: self.head.as_deref() }
    }
}
</code></pre>
<h1><a class="header" href="#itermut" id="itermut">IterMut</a></h1>
<p>I'm gonna be honest, IterMut is WILD. Which in itself seems like a wild
thing to say; surely it's identical to Iter!</p>
<p>Semantically, yes, but the nature of shared and mutable references means
that Iter is &quot;trivial&quot; while IterMut is Legit Wizard Magic.</p>
<p>The key insight comes from our implementation of Iterator for Iter:</p>
<pre><code class="language-rust ignore">impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {
    type Item = &amp;'a T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; { /* stuff */ }
}
</code></pre>
<p>Which can be desugared to:</p>
<pre><code class="language-rust ignore">impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {
    type Item = &amp;'a T;

    fn next&lt;'b&gt;(&amp;'b mut self) -&gt; Option&lt;&amp;'a T&gt; { /* stuff */ }
}
</code></pre>
<p>The signature of <code>next</code> establishes <em>no</em> constraint between the lifetime
of the input and the output! Why do we care? It means we can call <code>next</code>
over and over unconditionally!</p>
<pre><code class="language-rust ignore">let mut list = List::new();
list.push(1); list.push(2); list.push(3);

let mut iter = list.iter();
let x = iter.next().unwrap();
let y = iter.next().unwrap();
let z = iter.next().unwrap();
</code></pre>
<p>Cool!</p>
<p>This is <em>definitely fine</em> for shared references because the whole point is that
you can have tons of them at once. However mutable references <em>can't</em> coexist.
The whole point is that they're exclusive.</p>
<p>The end result is that it's notably harder to write IterMut using safe
code (and we haven't gotten into what that even means yet...). Surprisingly,
IterMut can actually be implemented for many structures completely safely!</p>
<p>We'll start by just taking the Iter code and changing everything to be mutable:</p>
<pre><code class="language-rust ignore">pub struct IterMut&lt;'a, T&gt; {
    next: Option&lt;&amp;'a mut Node&lt;T&gt;&gt;,
}

impl&lt;T&gt; List&lt;T&gt; {
    pub fn iter_mut(&amp;self) -&gt; IterMut&lt;'_, T&gt; {
        IterMut { next: self.head.as_deref_mut() }
    }
}

impl&lt;'a, T&gt; Iterator for IterMut&lt;'a, T&gt; {
    type Item = &amp;'a mut T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.next.map(|node| {
            self.next = node.next.as_deref_mut();
            &amp;mut node.elem
        })
    }
}
</code></pre>
<pre><code class="language-text">&gt; cargo build
error[E0596]: cannot borrow `self.head` as mutable, as it is behind a `&amp;` reference
  --&gt; src/second.rs:95:25
   |
94 |     pub fn iter_mut(&amp;self) -&gt; IterMut&lt;'_, T&gt; {
   |                     ----- help: consider changing this to be a mutable reference: `&amp;mut self`
95 |         IterMut { next: self.head.as_deref_mut() }
   |                         ^^^^^^^^^ `self` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable

error[E0507]: cannot move out of borrowed content
   --&gt; src/second.rs:103:9
    |
103 |         self.next.map(|node| {
    |         ^^^^^^^^^ cannot move out of borrowed content
</code></pre>
<p>Ok looks like we've got two different errors here. The first one looks really clear
though, it even tells us how to fix it! You can't upgrade a shared reference to a mutable
one, so <code>iter_mut</code> needs to take <code>&amp;mut self</code>. Just a silly copy-paste error.</p>
<pre><code class="language-rust ignore">pub fn iter_mut(&amp;mut self) -&gt; IterMut&lt;'_, T&gt; {
    IterMut { next: self.head.as_deref_mut() }
}
</code></pre>
<p>What about the other one?</p>
<p>Oops! I actually accidentally made an error when writing the <code>iter</code> impl in
the previous section, and we were just getting lucky that it worked!</p>
<p>We have just had our first run in with the magic of Copy. When we introduced <a href="first-ownership.html">ownership</a> we
said that when you move stuff, you can't use it anymore. For some types, this
makes perfect sense. Our good friend Box manages an allocation on the heap for
us, and we certainly don't want two pieces of code to think that they need to
free its memory.</p>
<p>However for other types this is <em>garbage</em>. Integers have no
ownership semantics; they're just meaningless numbers! This is why integers are
marked as Copy. Copy types are known to be perfectly copyable by a bitwise copy.
As such, they have a super power: when moved, the old value <em>is</em> still usable.
As a consequence, you can even move a Copy type out of a reference without
replacement!</p>
<p>All numeric primitives in Rust (i32, u64, bool, f32, char, etc...) are Copy.
You can also declare any user-defined type to be Copy as well, as long as
all its components are Copy.</p>
<p>Critically to why this code was working, shared references are also Copy!
Because <code>&amp;</code> is copy, <code>Option&lt;&amp;&gt;</code> is <em>also</em> Copy. So when we did <code>self.next.map</code> it
was fine because the Option was just copied. Now we can't do that, because
<code>&amp;mut</code> isn't Copy (if you copied an &amp;mut, you'd have two &amp;mut's to the same
location in memory, which is forbidden). Instead, we should properly <code>take</code>
the Option to get it.</p>
<pre><code class="language-rust ignore">fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
    self.next.take().map(|node| {
        self.next = node.next.as_deref_mut();
        &amp;mut node.elem
    })
}
</code></pre>
<pre><code class="language-text">&gt; cargo build

</code></pre>
<p>Uh... wow. Holy shit! IterMut Just Works!</p>
<p>Let's test this:</p>
<pre><code class="language-rust ignore">#[test]
fn iter_mut() {
    let mut list = List::new();
    list.push(1); list.push(2); list.push(3);

    let mut iter = list.iter_mut();
    assert_eq!(iter.next(), Some(&amp;mut 3));
    assert_eq!(iter.next(), Some(&amp;mut 2));
    assert_eq!(iter.next(), Some(&amp;mut 1));
}
</code></pre>
<pre><code class="language-text">&gt; cargo test

     Running target/debug/lists-5c71138492ad4b4a

running 6 tests
test first::test::basics ... ok
test second::test::basics ... ok
test second::test::iter_mut ... ok
test second::test::into_iter ... ok
test second::test::iter ... ok
test second::test::peek ... ok

test result: ok. 7 passed; 0 failed; 0 ignored; 0 measured

</code></pre>
<p>Yep. It works.</p>
<p>Holy shit.</p>
<p>What.</p>
<p>Ok I mean it actually <em>is</em> supposed to work, but there's usually something
stupid that gets in the way! Let's be clear here:</p>
<p>We have just implemented a piece of code that takes a singly-linked list, and
returns a mutable reference to every single element in the list at most once.
And it's statically verified to do that. And it's totally safe. And we didn't
have to do anything wild.</p>
<p>That's kind of a big deal, if you ask me. There are a couple reasons why
this works:</p>
<ul>
<li>We <code>take</code> the <code>Option&lt;&amp;mut&gt;</code> so we have exclusive access to the mutable
reference. No need to worry about someone looking at it again.</li>
<li>Rust understands that it's ok to shard a mutable reference into the subfields
of the pointed-to struct, because there's no way to &quot;go back up&quot;, and they're
definitely disjoint.</li>
</ul>
<p>It turns out that you can apply this basic logic to get a safe IterMut for an
array or a tree as well! You can even make the iterator DoubleEnded, so that
you can consume the iterator from the front <em>and</em> the back at once! Woah!</p>
<h1><a class="header" href="#final-code" id="final-code">Final Code</a></h1>
<p>Alright, that's it for the second list; here's the final code!</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct List&lt;T&gt; {
    head: Link&lt;T&gt;,
}

type Link&lt;T&gt; = Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;;

struct Node&lt;T&gt; {
    elem: T,
    next: Link&lt;T&gt;,
}

impl&lt;T&gt; List&lt;T&gt; {
    pub fn new() -&gt; Self {
        List { head: None }
    }

    pub fn push(&amp;mut self, elem: T) {
        let new_node = Box::new(Node {
            elem: elem,
            next: self.head.take(),
        });

        self.head = Some(new_node);
    }

    pub fn pop(&amp;mut self) -&gt; Option&lt;T&gt; {
        self.head.take().map(|node| {
            self.head = node.next;
            node.elem
        })
    }

    pub fn peek(&amp;self) -&gt; Option&lt;&amp;T&gt; {
        self.head.as_ref().map(|node| {
            &amp;node.elem
        })
    }

    pub fn peek_mut(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt; {
        self.head.as_mut().map(|node| {
            &amp;mut node.elem
        })
    }

    pub fn into_iter(self) -&gt; IntoIter&lt;T&gt; {
        IntoIter(self)
    }

    pub fn iter(&amp;self) -&gt; Iter&lt;'_, T&gt; {
        Iter { next: self.head.as_deref() }
    }

    pub fn iter_mut(&amp;mut self) -&gt; IterMut&lt;'_, T&gt; {
        IterMut { next: self.head.as_deref_mut() }
    }
}

impl&lt;T&gt; Drop for List&lt;T&gt; {
    fn drop(&amp;mut self) {
        let mut cur_link = self.head.take();
        while let Some(mut boxed_node) = cur_link {
            cur_link = boxed_node.next.take();
        }
    }
}

pub struct IntoIter&lt;T&gt;(List&lt;T&gt;);

impl&lt;T&gt; Iterator for IntoIter&lt;T&gt; {
    type Item = T;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        // access fields of a tuple struct numerically
        self.0.pop()
    }
}

pub struct Iter&lt;'a, T&gt; {
    next: Option&lt;&amp;'a Node&lt;T&gt;&gt;,
}

impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {
    type Item = &amp;'a T;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.next.map(|node| {
            self.next = node.next.as_deref();
            &amp;node.elem
        })
    }
}

pub struct IterMut&lt;'a, T&gt; {
    next: Option&lt;&amp;'a mut Node&lt;T&gt;&gt;,
}

impl&lt;'a, T&gt; Iterator for IterMut&lt;'a, T&gt; {
    type Item = &amp;'a mut T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.next.take().map(|node| {
            self.next = node.next.as_deref_mut();
            &amp;mut node.elem
        })
    }
}

#[cfg(test)]
mod test {
    use super::List;

    #[test]
    fn basics() {
        let mut list = List::new();

        // Check empty list behaves right
        assert_eq!(list.pop(), None);

        // Populate list
        list.push(1);
        list.push(2);
        list.push(3);

        // Check normal removal
        assert_eq!(list.pop(), Some(3));
        assert_eq!(list.pop(), Some(2));

        // Push some more just to make sure nothing's corrupted
        list.push(4);
        list.push(5);

        // Check normal removal
        assert_eq!(list.pop(), Some(5));
        assert_eq!(list.pop(), Some(4));

        // Check exhaustion
        assert_eq!(list.pop(), Some(1));
        assert_eq!(list.pop(), None);
    }

    #[test]
    fn peek() {
        let mut list = List::new();
        assert_eq!(list.peek(), None);
        assert_eq!(list.peek_mut(), None);
        list.push(1); list.push(2); list.push(3);

        assert_eq!(list.peek(), Some(&amp;3));
        assert_eq!(list.peek_mut(), Some(&amp;mut 3));

        list.peek_mut().map(|value| {
            *value = 42
        });

        assert_eq!(list.peek(), Some(&amp;42));
        assert_eq!(list.pop(), Some(42));
    }

    #[test]
    fn into_iter() {
        let mut list = List::new();
        list.push(1); list.push(2); list.push(3);

        let mut iter = list.into_iter();
        assert_eq!(iter.next(), Some(3));
        assert_eq!(iter.next(), Some(2));
        assert_eq!(iter.next(), Some(1));
        assert_eq!(iter.next(), None);
    }

    #[test]
    fn iter() {
        let mut list = List::new();
        list.push(1); list.push(2); list.push(3);

        let mut iter = list.iter();
        assert_eq!(iter.next(), Some(&amp;3));
        assert_eq!(iter.next(), Some(&amp;2));
        assert_eq!(iter.next(), Some(&amp;1));
    }

    #[test]
    fn iter_mut() {
        let mut list = List::new();
        list.push(1); list.push(2); list.push(3);

        let mut iter = list.iter_mut();
        assert_eq!(iter.next(), Some(&amp;mut 3));
        assert_eq!(iter.next(), Some(&amp;mut 2));
        assert_eq!(iter.next(), Some(&amp;mut 1));
    }
}

<span class="boring">}
</span></code></pre></pre>
<p>Getting beefier!</p>
<h1><a class="header" href="#a-persistent-singly-linked-stack" id="a-persistent-singly-linked-stack">A Persistent Singly-Linked Stack</a></h1>
<p>Alright, we've mastered the art of mutable singly-linked stacks.</p>
<p>Let's move from <em>single</em> ownership to <em>shared</em> ownership by writing a
<em>persistent</em> immutable singly-linked list. This will be exactly the list
that functional programmers have come to know and love. You can get the
head <em>or</em> the tail and put someone's head on someone else's tail...
and... that's basically it. Immutability is a hell of a drug.</p>
<p>In the process we'll largely just become familiar with Rc and Arc, but this
will set us up for the next list which will <em>change the game</em>.</p>
<p>Let's add a new file called <code>third.rs</code>:</p>
<pre><code class="language-rust ignore">// in lib.rs

pub mod first;
pub mod second;
pub mod third;
</code></pre>
<p>No copy-pasta this time. This is a clean room operation.</p>
<h1><a class="header" href="#layout" id="layout">Layout</a></h1>
<p>Alright, back to the drawing board on layout.</p>
<p>The most important thing about
a persistent list is that you can manipulate the tails of lists basically
for free:</p>
<p>For instance, this isn't an uncommon workload to see with a persistent list:</p>
<pre><code class="language-text">list1 = A -&gt; B -&gt; C -&gt; D
list2 = tail(list1) = B -&gt; C -&gt; D
list3 = push(list2, X) = X -&gt; B -&gt; C -&gt; D
</code></pre>
<p>But at the end we want the memory to look like this:</p>
<pre><code class="language-text">list1 -&gt; A ---+
              |
              v
list2 ------&gt; B -&gt; C -&gt; D
              ^
              |
list3 -&gt; X ---+
</code></pre>
<p>This just can't work with Boxes, because ownership of <code>B</code> is <em>shared</em>. Who
should free it? If I drop list2, does it free B? With boxes we certainly would
expect so!</p>
<p>Functional languages — and indeed almost every other language — get away with
this by using <em>garbage collection</em>. With the magic of garbage collection, B will
be freed only after everyone stops looking at it. Hooray!</p>
<p>Rust doesn't have anything like the garbage collectors these languages have.
They have <em>tracing</em> GC, which will dig through all the memory that's sitting
around at runtime and figure out what's garbage automatically. Instead, all
Rust has today is <em>reference counting</em>. Reference counting can be thought of
as a very simple GC. For many workloads, it has significantly less throughput
than a tracing collector, and it completely falls over if you manage to
build cycles. But hey, it's all we've got! Thankfully, for our usecase we'll never run into cycles
(feel free to try to prove this to yourself — I sure won't).</p>
<p>So how do we do reference-counted garbage collection? <code>Rc</code>! Rc is just like
Box, but we can duplicate it, and its memory will <em>only</em> be freed when <em>all</em>
the Rc's derived from it are dropped. Unfortunately, this flexibility comes at
a serious cost: we can only take a shared reference to its internals. This means
we can't ever really get data out of one of our lists, nor can we mutate them.</p>
<p>So what's our layout gonna look like? Well, previously we had:</p>
<pre><code class="language-rust ignore">pub struct List&lt;T&gt; {
    head: Link&lt;T&gt;,
}

type Link&lt;T&gt; = Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;;

struct Node&lt;T&gt; {
    elem: T,
    next: Link&lt;T&gt;,
}
</code></pre>
<p>Can we just change Box to Rc?</p>
<pre><code class="language-rust ignore">// in third.rs

pub struct List&lt;T&gt; {
    head: Link&lt;T&gt;,
}

type Link&lt;T&gt; = Option&lt;Rc&lt;Node&lt;T&gt;&gt;&gt;;

struct Node&lt;T&gt; {
    elem: T,
    next: Link&lt;T&gt;,
}
</code></pre>
<pre><code class="language-text">cargo build

error[E0412]: cannot find type `Rc` in this scope
 --&gt; src/third.rs:5:23
  |
5 | type Link&lt;T&gt; = Option&lt;Rc&lt;Node&lt;T&gt;&gt;&gt;;
  |                       ^^ not found in this scope
help: possible candidate is found in another module, you can import it into scope
  |
1 | use std::rc::Rc;
  |
</code></pre>
<p>Oh dang, sick burn. Unlike everything we used for our mutable lists, Rc is so
lame that it's not even implicitly imported into every single Rust program.
<em>What a loser</em>.</p>
<pre><code class="language-rust ignore">use std::rc::Rc;
</code></pre>
<pre><code class="language-text">cargo build

warning: field is never used: `head`
 --&gt; src/third.rs:4:5
  |
4 |     head: Link&lt;T&gt;,
  |     ^^^^^^^^^^^^^
  |
  = note: #[warn(dead_code)] on by default

warning: field is never used: `elem`
  --&gt; src/third.rs:10:5
   |
10 |     elem: T,
   |     ^^^^^^^

warning: field is never used: `next`
  --&gt; src/third.rs:11:5
   |
11 |     next: Link&lt;T&gt;,
   |     ^^^^^^^^^^^^^
</code></pre>
<p>Seems legit. Rust continues to be <em>completely</em> trivial to write. I bet we can just
find-and-replace Box with Rc and call it a day!</p>
<p>...</p>
<p>No. No we can't.</p>
<h1><a class="header" href="#basics" id="basics">Basics</a></h1>
<p>We already know a lot of the basics of Rust now, so we can do a lot of the
simple stuff again.</p>
<p>For the constructor, we can again just copy-paste:</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; List&lt;T&gt; {
    pub fn new() -&gt; Self {
        List { head: None }
    }
}
</code></pre>
<p><code>push</code> and <code>pop</code> don't really make sense anymore. Instead we can provide
<code>prepend</code> and <code>tail</code>, which provide approximately the same thing.</p>
<p>Let's start with prepending. It takes a list and an element, and returns a
List. Like the mutable list case, we want to make a new node, that has the old
list as its <code>next</code> value. The only novel thing is how to <em>get</em> that next value,
because we're not allowed to mutate anything.</p>
<p>The answer to our prayers is the Clone trait. Clone is implemented by almost
every type, and provides a generic way to get &quot;another one like this one&quot; that
is logically disjoint, given only a shared reference. It's like a copy
constructor in C++, but it's never implicitly invoked.</p>
<p>Rc in particular uses Clone as the way to increment the reference count. So
rather than moving a Box to be in the sublist, we just clone the head of the
old list. We don't even need to match on the head, because Option exposes a
Clone implementation that does exactly the thing we want.</p>
<p>Alright, let's give it a shot:</p>
<pre><code class="language-rust ignore">pub fn prepend(&amp;self, elem: T) -&gt; List&lt;T&gt; {
    List { head: Some(Rc::new(Node {
        elem: elem,
        next: self.head.clone(),
    }))}
}
</code></pre>
<pre><code class="language-text">&gt; cargo build

warning: field is never used: `elem`
  --&gt; src/third.rs:10:5
   |
10 |     elem: T,
   |     ^^^^^^^
   |
   = note: #[warn(dead_code)] on by default

warning: field is never used: `next`
  --&gt; src/third.rs:11:5
   |
11 |     next: Link&lt;T&gt;,
   |     ^^^^^^^^^^^^^
</code></pre>
<p>Wow, Rust is really hard-nosed about actually using fields. It can tell no
consumer can ever actually observe the use of these fields! Still, we seem good
so far.</p>
<p><code>tail</code> is the logical inverse of this operation. It takes a list and returns the
whole list with the first element removed. All that is is cloning the <em>second</em>
element in the list (if it exists). Let's try this:</p>
<pre><code class="language-rust ignore">pub fn tail(&amp;self) -&gt; List&lt;T&gt; {
    List { head: self.head.as_ref().map(|node| node.next.clone()) }
}
</code></pre>
<pre><code class="language-text">cargo build

error[E0308]: mismatched types
  --&gt; src/third.rs:27:22
   |
27 |         List { head: self.head.as_ref().map(|node| node.next.clone()) }
   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `std::rc::Rc`, found enum `std::option::Option`
   |
   = note: expected type `std::option::Option&lt;std::rc::Rc&lt;_&gt;&gt;`
              found type `std::option::Option&lt;std::option::Option&lt;std::rc::Rc&lt;_&gt;&gt;&gt;`
</code></pre>
<p>Hrm, we messed up. <code>map</code> expects us to return a Y, but here we're returning an
<code>Option&lt;Y&gt;</code>. Thankfully, this is another common Option pattern, and we can just
use <code>and_then</code> to let us return an Option.</p>
<pre><code class="language-rust ignore">pub fn tail(&amp;self) -&gt; List&lt;T&gt; {
    List { head: self.head.as_ref().and_then(|node| node.next.clone()) }
}
</code></pre>
<pre><code class="language-text">&gt; cargo build

</code></pre>
<p>Great.</p>
<p>Now that we have <code>tail</code>, we should probably provide <code>head</code>, which returns a
reference to the first element. That's just <code>peek</code> from the mutable list:</p>
<pre><code class="language-rust ignore">pub fn head(&amp;self) -&gt; Option&lt;&amp;T&gt; {
    self.head.as_ref().map(|node| &amp;node.elem)
}
</code></pre>
<pre><code class="language-text">&gt; cargo build

</code></pre>
<p>Nice.</p>
<p>That's enough functionality that we can test it:</p>
<pre><code class="language-rust ignore">#[cfg(test)]
mod test {
    use super::List;

    #[test]
    fn basics() {
        let list = List::new();
        assert_eq!(list.head(), None);

        let list = list.prepend(1).prepend(2).prepend(3);
        assert_eq!(list.head(), Some(&amp;3));

        let list = list.tail();
        assert_eq!(list.head(), Some(&amp;2));

        let list = list.tail();
        assert_eq!(list.head(), Some(&amp;1));

        let list = list.tail();
        assert_eq!(list.head(), None);

        // Make sure empty tail works
        let list = list.tail();
        assert_eq!(list.head(), None);

    }
}
</code></pre>
<pre><code class="language-text">&gt; cargo test

     Running target/debug/lists-5c71138492ad4b4a

running 5 tests
test first::test::basics ... ok
test second::test::into_iter ... ok
test second::test::basics ... ok
test second::test::iter ... ok
test third::test::basics ... ok

test result: ok. 5 passed; 0 failed; 0 ignored; 0 measured

</code></pre>
<p>Perfect!</p>
<p>Iter is also identical to how it was for our mutable list:</p>
<pre><code class="language-rust ignore">pub struct Iter&lt;'a, T&gt; {
    next: Option&lt;&amp;'a Node&lt;T&gt;&gt;,
}

impl&lt;T&gt; List&lt;T&gt; {
    pub fn iter(&amp;self) -&gt; Iter&lt;'_, T&gt; {
        Iter { next: self.head.as_deref() }
    }
}

impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {
    type Item = &amp;'a T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.next.map(|node| {
            self.next = node.next.as_deref();
            &amp;node.elem
        })
    }
}
</code></pre>
<pre><code class="language-rust ignore">#[test]
fn iter() {
    let list = List::new().prepend(1).prepend(2).prepend(3);

    let mut iter = list.iter();
    assert_eq!(iter.next(), Some(&amp;3));
    assert_eq!(iter.next(), Some(&amp;2));
    assert_eq!(iter.next(), Some(&amp;1));
}
</code></pre>
<pre><code class="language-text">cargo test

     Running target/debug/lists-5c71138492ad4b4a

running 7 tests
test first::test::basics ... ok
test second::test::basics ... ok
test second::test::iter ... ok
test second::test::into_iter ... ok
test second::test::peek ... ok
test third::test::basics ... ok
test third::test::iter ... ok

test result: ok. 6 passed; 0 failed; 0 ignored; 0 measured

</code></pre>
<p>Who ever said dynamic typing was easier?</p>
<p>(chumps did)</p>
<p>Note that we can't implement IntoIter or IterMut for this type. We only have
shared access to elements.</p>
<h1><a class="header" href="#drop-1" id="drop-1">Drop</a></h1>
<p>Like the mutable lists, we have a recursive destructor problem.
Admittedly, this isn't as bad of a problem for the immutable list: if we ever
hit another node that's the head of another list <em>somewhere</em>, we won't
recursively drop it. However it's still a thing we should care about, and
how to deal with isn't as clear. Here's how we solved it before:</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; Drop for List&lt;T&gt; {
    fn drop(&amp;mut self) {
        let mut cur_link = self.head.take();
        while let Some(mut boxed_node) = cur_link {
            cur_link = boxed_node.next.take();
        }
    }
}
</code></pre>
<p>The problem is the body of the loop:</p>
<pre><code class="language-rust ignore">cur_link = boxed_node.next.take();
</code></pre>
<p>This is mutating the Node inside the Box, but we can't do that with Rc; it only
gives us shared access, because any number of other Rc's could be pointing at it.</p>
<p>But if we know that we're the last list that knows about this node, it
<em>would</em> actually be fine to move the Node out of the Rc. Then we could also
know when to stop: whenever we <em>can't</em> hoist out the Node.</p>
<p>And look at that, Rc has a method that does exactly this: <code>try_unwrap</code>:</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; Drop for List&lt;T&gt; {
    fn drop(&amp;mut self) {
        let mut head = self.head.take();
        while let Some(node) = head {
            if let Ok(mut node) = Rc::try_unwrap(node) {
                head = node.next.take();
            } else {
                break;
            }
        }
    }
}
</code></pre>
<pre><code class="language-text">cargo test
   Compiling lists v0.1.0 (/Users/ADesires/dev/too-many-lists/lists)
    Finished dev [unoptimized + debuginfo] target(s) in 1.10s
     Running /Users/ADesires/dev/too-many-lists/lists/target/debug/deps/lists-86544f1d97438f1f

running 8 tests
test first::test::basics ... ok
test second::test::basics ... ok
test second::test::into_iter ... ok
test second::test::iter ... ok
test second::test::iter_mut ... ok
test second::test::peek ... ok
test third::test::basics ... ok
test third::test::iter ... ok

test result: ok. 8 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Great!
Nice.</p>
<h1><a class="header" href="#arc" id="arc">Arc</a></h1>
<p>One reason to use an immutable linked list is to share data across threads.
After all, shared mutable state is the root of all evil, and one way to solve
that is to kill the <em>mutable</em> part forever.</p>
<p>Except our list isn't thread-safe at all. In order to be thread-safe, we need
to fiddle with reference counts <em>atomically</em>. Otherwise, two threads could
try to increment the reference count, <em>and only one would happen</em>. Then the
list could get freed too soon!</p>
<p>In order to get thread safety, we have to use <em>Arc</em>. Arc is completely identical
to Rc except for the fact that reference counts are modified atomically. This
has a bit of overhead if you don't need it, so Rust exposes both.
All we need to do to make our list is replace every reference to Rc with
<code>std::sync::Arc</code>. That's it. We're thread safe. Done!</p>
<p>But this raises an interesting question: how do we <em>know</em> if a type is
thread-safe or not? Can we accidentally mess up?</p>
<p>No! You can't mess up thread-safety in Rust!</p>
<p>The reason this is the case is because Rust models thread-safety in a
first-class way with two traits: <code>Send</code> and <code>Sync</code>.</p>
<p>A type is <em>Send</em> if it's safe to <em>move</em> to another thread. A type is <em>Sync</em> if
it's safe to <em>share</em> between multiple threads. That is, if <code>T</code> is Sync, <code>&amp;T</code> is
Send. Safe in this case means it's impossible to cause <em>data races</em>, (not to
be mistaken with the more general issue of <em>race conditions</em>).</p>
<p>These are marker traits, which is a fancy way of saying they're traits that
provide absolutely no interface. You either <em>are</em> Send, or you aren't. It's just
a property <em>other</em> APIs can require. If you aren't appropriately Send,
then it's statically impossible to be sent to a different thread! Sweet!</p>
<p>Send and Sync are also automatically derived traits based on whether you are
totally composed of Send and Sync types. It's similar to how you can only
implement Copy if you're only made of Copy types, but then we just go ahead
and implement it automatically if you are.</p>
<p>Almost every type is Send and Sync. Most types are Send because they totally
own their data. Most types are Sync because the only way to share data across
threads is to put them behind a shared reference, which makes them immutable!</p>
<p>However there are special types that violate these properties: those that have
<em>interior mutability</em>. So far we've only really interacted with <em>inherited
mutability</em> (AKA external mutability): the mutability of a value is inherited
from the mutability of its container. That is, you can't just randomly mutate
some field of a non-mutable value because you feel like it.</p>
<p>Interior mutability types violate this: they let you mutate through a shared
reference. There are two major classes of interior mutability: cells, which
only work in a single-threaded context; and locks, which work in a
multi-threaded context. For obvious reasons, cells are cheaper when you can
use them. There's also atomics, which are primitives that act like a lock.</p>
<p>So what does all of this have to do with Rc and Arc? Well, they both use
interior mutability for their <em>reference count</em>. Worse, this reference count
is shared between every instance! Rc just uses a cell, which means it's not
thread safe. Arc uses an atomic, which means it <em>is</em> thread safe. Of course,
you can't magically make a type thread safe by putting it in Arc. Arc can only
derive thread-safety like any other type.</p>
<p>I really really really don't want to get into the finer details of atomic
memory models or non-derived Send implementations. Needless to say, as you get
deeper into Rust's thread-safety story, stuff gets more complicated. As a
high-level consumer, it all <em>just works</em> and you don't really need to think
about it.</p>
<h1><a class="header" href="#final-code-1" id="final-code-1">Final Code</a></h1>
<p>That's all I really have to say on the immutable stack. We're getting pretty
good at implementing lists now!</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::Rc;

pub struct List&lt;T&gt; {
    head: Link&lt;T&gt;,
}

type Link&lt;T&gt; = Option&lt;Rc&lt;Node&lt;T&gt;&gt;&gt;;

struct Node&lt;T&gt; {
    elem: T,
    next: Link&lt;T&gt;,
}

impl&lt;T&gt; List&lt;T&gt; {
    pub fn new() -&gt; Self {
        List { head: None }
    }

    pub fn prepend(&amp;self, elem: T) -&gt; List&lt;T&gt; {
        List { head: Some(Rc::new(Node {
            elem: elem,
            next: self.head.clone(),
        }))}
    }

    pub fn tail(&amp;self) -&gt; List&lt;T&gt; {
        List { head: self.head.as_ref().and_then(|node| node.next.clone()) }
    }

    pub fn head(&amp;self) -&gt; Option&lt;&amp;T&gt; {
        self.head.as_ref().map(|node| &amp;node.elem)
    }

    pub fn iter(&amp;self) -&gt; Iter&lt;'_, T&gt; {
        Iter { next: self.head.as_deref() }
    }
}

impl&lt;T&gt; Drop for List&lt;T&gt; {
    fn drop(&amp;mut self) {
        let mut head = self.head.take();
        while let Some(node) = head {
            if let Ok(mut node) = Rc::try_unwrap(node) {
                head = node.next.take();
            } else {
                break;
            }
        }
    }
}

pub struct Iter&lt;'a, T&gt; {
    next: Option&lt;&amp;'a Node&lt;T&gt;&gt;,
}

impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {
    type Item = &amp;'a T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.next.map(|node| {
            self.next = node.next.as_deref();
            &amp;node.elem
        })
    }
}

#[cfg(test)]
mod test {
    use super::List;

    #[test]
    fn basics() {
        let list = List::new();
        assert_eq!(list.head(), None);

        let list = list.prepend(1).prepend(2).prepend(3);
        assert_eq!(list.head(), Some(&amp;3));

        let list = list.tail();
        assert_eq!(list.head(), Some(&amp;2));

        let list = list.tail();
        assert_eq!(list.head(), Some(&amp;1));

        let list = list.tail();
        assert_eq!(list.head(), None);

        // Make sure empty tail works
        let list = list.tail();
        assert_eq!(list.head(), None);
    }

    #[test]
    fn iter() {
        let list = List::new().prepend(1).prepend(2).prepend(3);

        let mut iter = list.iter();
        assert_eq!(iter.next(), Some(&amp;3));
        assert_eq!(iter.next(), Some(&amp;2));
        assert_eq!(iter.next(), Some(&amp;1));
    }
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#a-bad-but-safe-doubly-linked-deque" id="a-bad-but-safe-doubly-linked-deque">A Bad but Safe Doubly-Linked Deque</a></h1>
<p>Now that we've seen Rc and heard about interior mutability, this gives an
interesting thought... maybe we <em>can</em> mutate through an Rc. And if <em>that's</em>
the case, maybe we can implement a <em>doubly-linked</em> list totally safely!</p>
<p>In the process we'll become familiar with <em>interior mutability</em>, and probably
learn the hard way that safe doesn't mean <em>correct</em>. Doubly-linked lists are
hard, and I always make a mistake somewhere.</p>
<p>Let's add a new file called <code>fourth.rs</code>:</p>
<pre><code class="language-rust ignore">// in lib.rs

pub mod first;
pub mod second;
pub mod third;
pub mod fourth;
</code></pre>
<p>This will be another clean-room operation, though as usual we'll probably find
some logic that applies verbatim again.</p>
<p>Disclaimer: this chapter is basically a demonstration that this is a very bad idea.</p>
<h1><a class="header" href="#layout-1" id="layout-1">Layout</a></h1>
<p>The key to our design is the <code>RefCell</code> type. The heart of
RefCell is a pair of methods:</p>
<pre><code class="language-rust ignore">fn borrow(&amp;self) -&gt; Ref&lt;'_, T&gt;;
fn borrow_mut(&amp;self) -&gt; RefMut&lt;'_, T&gt;;
</code></pre>
<p>The rules for <code>borrow</code> and <code>borrow_mut</code> are exactly those of <code>&amp;</code> and <code>&amp;mut</code>:
you can call <code>borrow</code> as many times as you want, but <code>borrow_mut</code> requires
exclusivity.</p>
<p>Rather than enforcing this statically, RefCell enforces them at runtime.
If you break the rules, RefCell will just panic and crash the program.
Why does it return these Ref and RefMut things? Well, they basically behave
like <code>Rc</code>s but for borrowing. They also keep the RefCell borrowed until they go out
of scope. We'll get to that later.</p>
<p>Now with Rc and RefCell we can become... an incredibly verbose pervasively
mutable garbage collected language that can't collect cycles! Y-yaaaaay...</p>
<p>Alright, we want to be <em>doubly-linked</em>. This means each node has a pointer to
the previous and next node. Also, the list itself has a pointer to the
first and last node. This gives us fast insertion and removal on <em>both</em>
ends of the list.</p>
<p>So we probably want something like:</p>
<pre><code class="language-rust ignore">use std::rc::Rc;
use std::cell::RefCell;

pub struct List&lt;T&gt; {
    head: Link&lt;T&gt;,
    tail: Link&lt;T&gt;,
}

type Link&lt;T&gt; = Option&lt;Rc&lt;RefCell&lt;Node&lt;T&gt;&gt;&gt;&gt;;

struct Node&lt;T&gt; {
    elem: T,
    next: Link&lt;T&gt;,
    prev: Link&lt;T&gt;,
}
</code></pre>
<pre><code class="language-text">&gt; cargo build

warning: field is never used: `head`
 --&gt; src/fourth.rs:5:5
  |
5 |     head: Link&lt;T&gt;,
  |     ^^^^^^^^^^^^^
  |
  = note: #[warn(dead_code)] on by default

warning: field is never used: `tail`
 --&gt; src/fourth.rs:6:5
  |
6 |     tail: Link&lt;T&gt;,
  |     ^^^^^^^^^^^^^

warning: field is never used: `elem`
  --&gt; src/fourth.rs:12:5
   |
12 |     elem: T,
   |     ^^^^^^^

warning: field is never used: `next`
  --&gt; src/fourth.rs:13:5
   |
13 |     next: Link&lt;T&gt;,
   |     ^^^^^^^^^^^^^

warning: field is never used: `prev`
  --&gt; src/fourth.rs:14:5
   |
14 |     prev: Link&lt;T&gt;,
   |     ^^^^^^^^^^^^^
</code></pre>
<p>Hey, it built! Lots of dead code warnings, but it built! Let's try to use it.</p>
<h1><a class="header" href="#building-up" id="building-up">Building Up</a></h1>
<p>Alright, we'll start with building the list. That's pretty straight-forward
with this new system. <code>new</code> is still trivial, just None out all the fields.
Also because it's getting a bit unwieldy, let's break out a Node constructor
too:</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; Node&lt;T&gt; {
    fn new(elem: T) -&gt; Rc&lt;RefCell&lt;Self&gt;&gt; {
        Rc::new(RefCell::new(Node {
            elem: elem,
            prev: None,
            next: None,
        }))
    }
}

impl&lt;T&gt; List&lt;T&gt; {
    pub fn new() -&gt; Self {
        List { head: None, tail: None }
    }
}
</code></pre>
<pre><code class="language-text">&gt; cargo build

**A BUNCH OF DEAD CODE WARNINGS BUT IT BUILT**
</code></pre>
<p>Yay!</p>
<p>Now let's try to write pushing onto the front of the list. Because
doubly-linked lists are significantly more complicated, we're going to need
to do a fair bit more work. Where singly-linked list operations could be
reduced to an easy one-liner, doubly-linked list ops are fairly complicated.</p>
<p>In particular we now need to specially handle some boundary cases around
empty lists. Most operations will only touch the <code>head</code> or <code>tail</code> pointer.
However when transitioning to or from the empty list, we need to edit
<em>both</em> at once.</p>
<p>An easy way for us to validate if our methods make sense is if we maintain
the following invariant: each node should have exactly two pointers to it.
Each node in the middle of the list is pointed at by its predecessor and
successor, while the nodes on the ends are pointed to by the list itself.</p>
<p>Let's take a crack at it:</p>
<pre><code class="language-rust ignore">pub fn push_front(&amp;mut self, elem: T) {
    // new node needs +2 links, everything else should be +0
    let new_head = Node::new(elem);
    match self.head.take() {
        Some(old_head) =&gt; {
            // non-empty list, need to connect the old_head
            old_head.prev = Some(new_head.clone()); // +1 new_head
            new_head.next = Some(old_head);         // +1 old_head
            self.head = Some(new_head);             // +1 new_head, -1 old_head
            // total: +2 new_head, +0 old_head -- OK!
        }
        None =&gt; {
            // empty list, need to set the tail
            self.tail = Some(new_head.clone());     // +1 new_head
            self.head = Some(new_head);             // +1 new_head
            // total: +2 new_head -- OK!
        }
    }
}
</code></pre>
<pre><code class="language-text">cargo build

error[E0609]: no field `prev` on type `std::rc::Rc&lt;std::cell::RefCell&lt;fourth::Node&lt;T&gt;&gt;&gt;`
  --&gt; src/fourth.rs:39:26
   |
39 |                 old_head.prev = Some(new_head.clone()); // +1 new_head
   |                          ^^^^ unknown field

error[E0609]: no field `next` on type `std::rc::Rc&lt;std::cell::RefCell&lt;fourth::Node&lt;T&gt;&gt;&gt;`
  --&gt; src/fourth.rs:40:26
   |
40 |                 new_head.next = Some(old_head);         // +1 old_head
   |                          ^^^^ unknown field
</code></pre>
<p>Alright. Compiler error. Good start. Good start.</p>
<p>Why can't we access the <code>prev</code> and <code>next</code> fields on our nodes? It worked before
when we just had an <code>Rc&lt;Node&gt;</code>. Seems like the <code>RefCell</code> is getting in the way.</p>
<p>We should probably check the docs.</p>
<p><em>Google's &quot;rust refcell&quot;</em></p>
<p><em><a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html">clicks first link</a></em></p>
<blockquote>
<p>A mutable memory location with dynamically checked borrow rules</p>
<p>See the <a href="https://doc.rust-lang.org/std/cell/index.html">module-level documentation</a> for more.</p>
</blockquote>
<p><em>clicks link</em></p>
<blockquote>
<p>Shareable mutable containers.</p>
<p>Values of the <code>Cell&lt;T&gt;</code> and <code>RefCell&lt;T&gt;</code> types may be mutated through shared references (i.e.
the common <code>&amp;T</code> type), whereas most Rust types can only be mutated through unique (<code>&amp;mut T</code>)
references. We say that <code>Cell&lt;T&gt;</code> and <code>RefCell&lt;T&gt;</code> provide 'interior mutability', in contrast
with typical Rust types that exhibit 'inherited mutability'.</p>
<p>Cell types come in two flavors: <code>Cell&lt;T&gt;</code> and <code>RefCell&lt;T&gt;</code>. <code>Cell&lt;T&gt;</code> provides <code>get</code> and <code>set</code>
methods that change the interior value with a single method call. <code>Cell&lt;T&gt;</code> though is only
compatible with types that implement <code>Copy</code>. For other types, one must use the <code>RefCell&lt;T&gt;</code>
type, acquiring a write lock before mutating.</p>
<p><code>RefCell&lt;T&gt;</code> uses Rust's lifetimes to implement 'dynamic borrowing', a process whereby one can
claim temporary, exclusive, mutable access to the inner value. Borrows for <code>RefCell&lt;T&gt;</code>s are
tracked 'at runtime', unlike Rust's native reference types which are entirely tracked
statically, at compile time. Because <code>RefCell&lt;T&gt;</code> borrows are dynamic it is possible to attempt
to borrow a value that is already mutably borrowed; when this happens it results in thread
panic.</p>
<h1><a class="header" href="#when-to-choose-interior-mutability" id="when-to-choose-interior-mutability">When to choose interior mutability</a></h1>
<p>The more common inherited mutability, where one must have unique access to mutate a value, is
one of the key language elements that enables Rust to reason strongly about pointer aliasing,
statically preventing crash bugs. Because of that, inherited mutability is preferred, and
interior mutability is something of a last resort. Since cell types enable mutation where it
would otherwise be disallowed though, there are occasions when interior mutability might be
appropriate, or even <em>must</em> be used, e.g.</p>
<ul>
<li>Introducing inherited mutability roots to shared types.</li>
<li>Implementation details of logically-immutable methods.</li>
<li>Mutating implementations of <code>Clone</code>.</li>
</ul>
<h2><a class="header" href="#introducing-inherited-mutability-roots-to-shared-types" id="introducing-inherited-mutability-roots-to-shared-types">Introducing inherited mutability roots to shared types</a></h2>
<p>Shared smart pointer types, including <code>Rc&lt;T&gt;</code> and <code>Arc&lt;T&gt;</code>, provide containers that can be
cloned and shared between multiple parties. Because the contained values may be
multiply-aliased, they can only be borrowed as shared references, not mutable references.
Without cells it would be impossible to mutate data inside of shared boxes at all!</p>
<p>It's very common then to put a <code>RefCell&lt;T&gt;</code> inside shared pointer types to reintroduce
mutability:</p>
<pre><code class="language-rust ignore">use std::collections::HashMap;
use std::cell::RefCell;
use std::rc::Rc;

fn main() {
    let shared_map: Rc&lt;RefCell&lt;_&gt;&gt; = Rc::new(RefCell::new(HashMap::new()));
    shared_map.borrow_mut().insert(&quot;africa&quot;, 92388);
    shared_map.borrow_mut().insert(&quot;kyoto&quot;, 11837);
    shared_map.borrow_mut().insert(&quot;piccadilly&quot;, 11826);
    shared_map.borrow_mut().insert(&quot;marbles&quot;, 38);
}
</code></pre>
<p>Note that this example uses <code>Rc&lt;T&gt;</code> and not <code>Arc&lt;T&gt;</code>. <code>RefCell&lt;T&gt;</code>s are for single-threaded
scenarios. Consider using <code>Mutex&lt;T&gt;</code> if you need shared mutability in a multi-threaded
situation.</p>
</blockquote>
<p>Hey, Rust's docs continue to be incredibly awesome.</p>
<p>The meaty bit we care about is this line:</p>
<pre><code class="language-rust ignore">shared_map.borrow_mut().insert(&quot;africa&quot;, 92388);
</code></pre>
<p>In particular, the <code>borrow_mut</code> thing. Seems we need to explicitly borrow a
RefCell. The <code>.</code> operator's not going to do it for us. Weird. Let's try:</p>
<pre><code class="language-rust ignore">pub fn push_front(&amp;mut self, elem: T) {
    let new_head = Node::new(elem);
    match self.head.take() {
        Some(old_head) =&gt; {
            old_head.borrow_mut().prev = Some(new_head.clone());
            new_head.borrow_mut().next = Some(old_head);
            self.head = Some(new_head);
        }
        None =&gt; {
            self.tail = Some(new_head.clone());
            self.head = Some(new_head);
        }
    }
}
</code></pre>
<pre><code class="language-text">&gt; cargo build

warning: field is never used: `elem`
  --&gt; src/fourth.rs:12:5
   |
12 |     elem: T,
   |     ^^^^^^^
   |
   = note: #[warn(dead_code)] on by default
</code></pre>
<p>Hey, it built! Docs win again.</p>
<h1><a class="header" href="#breaking-down" id="breaking-down">Breaking Down</a></h1>
<p><code>pop_front</code> should be the same basic logic as <code>push_front</code>, but backwards. Let's
try:</p>
<pre><code class="language-rust ignore">pub fn pop_front(&amp;mut self) -&gt; Option&lt;T&gt; {
    // need to take the old head, ensuring it's -2
    self.head.take().map(|old_head| {                         // -1 old
        match old_head.borrow_mut().next.take() {
            Some(new_head) =&gt; {                               // -1 new
                // not emptying list
                new_head.borrow_mut().prev.take();            // -1 old
                self.head = Some(new_head);                   // +1 new
                // total: -2 old, +0 new
            }
            None =&gt; {
                // emptying list
                self.tail.take();                             // -1 old
                // total: -2 old, (no new)
            }
        }
        old_head.elem
    })
}
</code></pre>
<pre><code class="language-text">&gt; cargo build

error[E0609]: no field `elem` on type `std::rc::Rc&lt;std::cell::RefCell&lt;fourth::Node&lt;T&gt;&gt;&gt;`
  --&gt; src/fourth.rs:64:22
   |
64 |             old_head.elem
   |                      ^^^^ unknown field
</code></pre>
<p>ACK. <em>RefCells</em>. Gotta <code>borrow_mut</code> again I guess...</p>
<pre><code class="language-rust ignore">pub fn pop_front(&amp;mut self) -&gt; Option&lt;T&gt; {
    self.head.take().map(|old_head| {
        match old_head.borrow_mut().next.take() {
            Some(new_head) =&gt; {
                new_head.borrow_mut().prev.take();
                self.head = Some(new_head);
            }
            None =&gt; {
                self.tail.take();
            }
        }
        old_head.borrow_mut().elem
    })
}
</code></pre>
<pre><code class="language-text">cargo build

error[E0507]: cannot move out of borrowed content
  --&gt; src/fourth.rs:64:13
   |
64 |             old_head.borrow_mut().elem
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot move out of borrowed content
</code></pre>
<p><em>sigh</em></p>
<blockquote>
<p>cannot move out of borrowed content</p>
</blockquote>
<p>Hrm... It seems that Box was <em>really</em> spoiling us. <code>borrow_mut</code> only gets us
an <code>&amp;mut Node&lt;T&gt;</code>, but we can't move out of that!</p>
<p>We need something that takes a <code>RefCell&lt;T&gt;</code> and gives us a <code>T</code>. Let's check
<a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html">the docs</a> for something like that:</p>
<blockquote>
<p><code>fn into_inner(self) -&gt; T</code></p>
<p>Consumes the RefCell, returning the wrapped value.</p>
</blockquote>
<p>That looks promising!</p>
<pre><code class="language-rust ignore">old_head.into_inner().elem
</code></pre>
<pre><code class="language-text">&gt; cargo build

error[E0507]: cannot move out of an `Rc`
  --&gt; src/fourth.rs:64:13
   |
64 |             old_head.into_inner().elem
   |             ^^^^^^^^ cannot move out of an `Rc`
</code></pre>
<p>Ah dang. <code>into_inner</code> wants to move out the RefCell, but we can't, because it's
in an <code>Rc</code>. As we saw in the previous chapter, <code>Rc&lt;T&gt;</code> only lets us get shared references
into its internals. That makes sense, because that's <em>the whole point</em> of
reference counted pointers: they're shared!</p>
<p>This was a problem for us when we wanted to implement Drop for our reference
counted list, and the solution is the same: <code>Rc::try_unwrap</code>, which moves out
the contents of an Rc if its refcount is 1.</p>
<pre><code class="language-rust ignore">Rc::try_unwrap(old_head).unwrap().into_inner().elem
</code></pre>
<p><code>Rc::try_unwrap</code> returns a <code>Result&lt;T, Rc&lt;T&gt;&gt;</code>. Results are basically a
generalized <code>Option</code>, where the <code>None</code> case has data associated with it. In
this case, the <code>Rc</code> you tried to unwrap. Since we don't care about the case
where it fails (if we wrote our program correctly, it <em>has</em> to succeed), we
just call <code>unwrap</code> on it.</p>
<p>Anyway, let's see what compiler error we get next (let's face it, there's going
to be one).</p>
<pre><code class="language-text">&gt; cargo build

error[E0599]: no method named `unwrap` found for type `std::result::Result&lt;std::cell::RefCell&lt;fourth::Node&lt;T&gt;&gt;, std::rc::Rc&lt;std::cell::RefCell&lt;fourth::Node&lt;T&gt;&gt;&gt;&gt;` in the current scope
  --&gt; src/fourth.rs:64:38
   |
64 |             Rc::try_unwrap(old_head).unwrap().into_inner().elem
   |                                      ^^^^^^
   |
   = note: the method `unwrap` exists but the following trait bounds were not satisfied:
           `std::rc::Rc&lt;std::cell::RefCell&lt;fourth::Node&lt;T&gt;&gt;&gt; : std::fmt::Debug`
</code></pre>
<p>UGH. <code>unwrap</code> on Result requires that you can debug-print the error case.
<code>RefCell&lt;T&gt;</code> only implements <code>Debug</code> if <code>T</code> does. <code>Node</code> doesn't implement Debug.</p>
<p>Rather than doing that, let's just work around it by converting the Result to
an Option with <code>ok</code>:</p>
<pre><code class="language-rust ignore">Rc::try_unwrap(old_head).ok().unwrap().into_inner().elem
</code></pre>
<p>PLEASE.</p>
<pre><code class="language-text">cargo build

</code></pre>
<p>YES.</p>
<p><em>phew</em></p>
<p>We did it.</p>
<p>We implemented <code>push</code> and <code>pop</code>.</p>
<p>Let's test by stealing the old <code>stack</code> basic test (because that's all that
we've implemented so far):</p>
<pre><code class="language-rust ignore">#[cfg(test)]
mod test {
    use super::List;

    #[test]
    fn basics() {
        let mut list = List::new();

        // Check empty list behaves right
        assert_eq!(list.pop_front(), None);

        // Populate list
        list.push_front(1);
        list.push_front(2);
        list.push_front(3);

        // Check normal removal
        assert_eq!(list.pop_front(), Some(3));
        assert_eq!(list.pop_front(), Some(2));

        // Push some more just to make sure nothing's corrupted
        list.push_front(4);
        list.push_front(5);

        // Check normal removal
        assert_eq!(list.pop_front(), Some(5));
        assert_eq!(list.pop_front(), Some(4));

        // Check exhaustion
        assert_eq!(list.pop_front(), Some(1));
        assert_eq!(list.pop_front(), None);
    }
}
</code></pre>
<pre><code class="language-text">cargo test

     Running target/debug/lists-5c71138492ad4b4a

running 9 tests
test first::test::basics ... ok
test fourth::test::basics ... ok
test second::test::iter_mut ... ok
test second::test::basics ... ok
test fifth::test::iter_mut ... ok
test third::test::basics ... ok
test second::test::iter ... ok
test third::test::iter ... ok
test second::test::into_iter ... ok

test result: ok. 9 passed; 0 failed; 0 ignored; 0 measured

</code></pre>
<p><em>Nailed it</em>.</p>
<p>Now that we can properly remove things from the list, we can implement Drop.
Drop is a little more conceptually interesting this time around. Where
previously we bothered to implement Drop for our stacks just to avoid unbounded
recursion, now we need to implement Drop to get <em>anything</em> to happen at all.</p>
<p><code>Rc</code> can't deal with cycles. If there's a cycle, everything will keep everything
else alive. A doubly-linked list, as it turns out, is just a big chain of tiny
cycles! So when we drop our list, the two end nodes will have their refcounts
decremented down to 1... and then nothing else will happen. Well, if our list
contains exactly one node we're good to go. But ideally a list should work right
if it contains multiple elements. Maybe that's just me.</p>
<p>As we saw, removing elements was a bit painful. So the easiest thing for us to
do is just <code>pop</code> until we get None:</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; Drop for List&lt;T&gt; {
    fn drop(&amp;mut self) {
        while self.pop_front().is_some() {}
    }
}
</code></pre>
<pre><code class="language-text">cargo build

</code></pre>
<p>(We actually could have done this with our mutable stacks, but shortcuts are for
people who understand things!)</p>
<p>We could look at implementing the <code>_back</code> versions of <code>push</code> and <code>pop</code>, but
they're just copy-paste jobs which we'll defer to later in the chapter. For now
let's look at more interesting things!</p>
<h1><a class="header" href="#peeking" id="peeking">Peeking</a></h1>
<p>Alright, we made it through <code>push</code> and <code>pop</code>. I'm not gonna lie, it got a
bit emotional there. Compile-time correctness is a hell of a drug.</p>
<p>Let's cool off by doing something simple: let's just implement <code>peek_front</code>.
That was always really easy before. Gotta still be easy, right?</p>
<p>Right?</p>
<p>In fact, I think I can just copy-paste it!</p>
<pre><code class="language-rust ignore">pub fn peek_front(&amp;self) -&gt; Option&lt;&amp;T&gt; {
    self.head.as_ref().map(|node| {
        &amp;node.elem
    })
}
</code></pre>
<p>Wait. Not this time.</p>
<pre><code class="language-rust ignore">pub fn peek_front(&amp;self) -&gt; Option&lt;&amp;T&gt; {
    self.head.as_ref().map(|node| {
        // BORROW!!!!
        &amp;node.borrow().elem
    })
}
</code></pre>
<p>HAH.</p>
<pre><code class="language-text">cargo build

error[E0515]: cannot return value referencing temporary value
  --&gt; src/fourth.rs:66:13
   |
66 |             &amp;node.borrow().elem
   |             ^   ----------^^^^^
   |             |   |
   |             |   temporary value created here
   |             |
   |             returns a value referencing data owned by the current function
</code></pre>
<p>Ok I'm just burning my computer.</p>
<p>This is exactly the same logic as our singly-linked stack. Why are things
different. WHY.</p>
<p>The answer is really the whole moral of this chapter: RefCells make everything
sadness. Up until now, RefCells have just been a nuisance. Now they're going to
become a nightmare.</p>
<p>So what's going on? To understand that, we need to go back to the definition of
<code>borrow</code>:</p>
<pre><code class="language-rust ignore">fn borrow&lt;'a&gt;(&amp;'a self) -&gt; Ref&lt;'a, T&gt;
fn borrow_mut&lt;'a&gt;(&amp;'a self) -&gt; RefMut&lt;'a, T&gt;
</code></pre>
<p>In the layout section we said:</p>
<blockquote>
<p>Rather than enforcing this statically, RefCell enforces them at runtime.
If you break the rules, RefCell will just panic and crash the program.
Why does it return these Ref and RefMut things? Well, they basically behave
like <code>Rc</code>s but for borrowing. Also they keep the RefCell borrowed until they go out
of scope. <strong>We'll get to that later.</strong></p>
</blockquote>
<p>It's later.</p>
<p><code>Ref</code> and <code>RefMut</code> implement <code>Deref</code> and <code>DerefMut</code> respectively. So for most
intents and purposes they behave <em>exactly</em> like <code>&amp;T</code> and <code>&amp;mut T</code>. However,
because of how those traits work, the reference that's returned is connected
to the lifetime of the Ref, and not the actual RefCell. This means that the Ref
has to be sitting around as long as we keep the reference around.</p>
<p>This is in fact necessary for correctness. When a Ref gets dropped, it tells
the RefCell that it's not borrowed anymore. So if we <em>did</em> manage to hold onto our
reference longer than the Ref existed, we could get a RefMut while a reference
was kicking around and totally break Rust's type system in half.</p>
<p>So where does that leave us? We only want to return a reference, but we need
to keep this Ref thing around. But as soon as we return the reference from
<code>peek</code>, the function is over and the <code>Ref</code> goes out of scope.</p>
<p>😖</p>
<p>As far as I know, we're actually totally dead in the water here. You can't
totally encapsulate the use of RefCells like that.</p>
<p>But... what if we just give up on totally hiding our implementation details?
What if we returns Refs?</p>
<pre><code class="language-rust ignore">pub fn peek_front(&amp;self) -&gt; Option&lt;Ref&lt;T&gt;&gt; {
    self.head.as_ref().map(|node| {
        node.borrow()
    })
}
</code></pre>
<pre><code class="language-text">&gt; cargo build

error[E0412]: cannot find type `Ref` in this scope
  --&gt; src/fourth.rs:63:40
   |
63 |     pub fn peek_front(&amp;self) -&gt; Option&lt;Ref&lt;T&gt;&gt; {
   |                                        ^^^ not found in this scope
help: possible candidates are found in other modules, you can import them into scope
   |
1  | use core::cell::Ref;
   |
1  | use std::cell::Ref;
   |
</code></pre>
<p>Blurp. Gotta import some stuff.</p>
<pre><code class="language-rust ignore">use std::cell::{Ref, RefCell};
</code></pre>
<pre><code class="language-text">&gt; cargo build

error[E0308]: mismatched types
  --&gt; src/fourth.rs:64:9
   |
64 | /         self.head.as_ref().map(|node| {
65 | |             node.borrow()
66 | |         })
   | |__________^ expected type parameter, found struct `fourth::Node`
   |
   = note: expected type `std::option::Option&lt;std::cell::Ref&lt;'_, T&gt;&gt;`
              found type `std::option::Option&lt;std::cell::Ref&lt;'_, fourth::Node&lt;T&gt;&gt;&gt;`
</code></pre>
<p>Hmm... that's right. We have a <code>Ref&lt;Node&lt;T&gt;&gt;</code>, but we want a <code>Ref&lt;T&gt;</code>. We could
abandon all hope of encapsulation and just return that. We could also make
things even more complicated and wrap <code>Ref&lt;Node&lt;T&gt;&gt;</code> in a new type to only
expose access to an <code>&amp;T</code>.</p>
<p>Both of those options are <em>kinda</em> lame.</p>
<p>Instead, we're going to go deeper down. Let's
have some <em>fun</em>. Our source of fun is <em>this beast</em>:</p>
<pre><code class="language-rust ignore">map&lt;U, F&gt;(orig: Ref&lt;'b, T&gt;, f: F) -&gt; Ref&lt;'b, U&gt;
    where F: FnOnce(&amp;T) -&gt; &amp;U,
          U: ?Sized
</code></pre>
<blockquote>
<p>Make a new Ref for a component of the borrowed data.</p>
</blockquote>
<p>Yes: just like you can map over an Option, you can map over a Ref.</p>
<p>I'm sure someone somewhere is really excited because <em>monads</em> or whatever but
I don't care about any of that. Also I don't think it's a proper monad since
there's no None-like case, but I digress.</p>
<p>It's cool and that's all that matters to me. <em>I need this</em>.</p>
<pre><code class="language-rust ignore">pub fn peek_front(&amp;self) -&gt; Option&lt;Ref&lt;T&gt;&gt; {
    self.head.as_ref().map(|node| {
        Ref::map(node.borrow(), |node| &amp;node.elem)
    })
}
</code></pre>
<pre><code class="language-text">&gt; cargo build
</code></pre>
<p>Awww yissss</p>
<p>Let's make sure this is working by munging up the test from our stack. We need
to do some munging to deal with the fact that Refs don't implement comparisons.</p>
<pre><code class="language-rust ignore">#[test]
fn peek() {
    let mut list = List::new();
    assert!(list.peek_front().is_none());
    list.push_front(1); list.push_front(2); list.push_front(3);

    assert_eq!(&amp;*list.peek_front().unwrap(), &amp;3);
}
</code></pre>
<pre><code class="language-text">&gt; cargo test

     Running target/debug/lists-5c71138492ad4b4a

running 10 tests
test first::test::basics ... ok
test fourth::test::basics ... ok
test second::test::basics ... ok
test fourth::test::peek ... ok
test second::test::iter_mut ... ok
test second::test::into_iter ... ok
test third::test::basics ... ok
test second::test::peek ... ok
test second::test::iter ... ok
test third::test::iter ... ok

test result: ok. 10 passed; 0 failed; 0 ignored; 0 measured

</code></pre>
<p>Great!</p>
<h1><a class="header" href="#symmetric-junk" id="symmetric-junk">Symmetric Junk</a></h1>
<p>Alright let's get all that combinatoric symmetry over with.</p>
<p>All we have to do is some basic text replacement:</p>
<pre><code class="language-text">tail &lt;-&gt; head
next &lt;-&gt; prev
front -&gt; back
</code></pre>
<p>Oh, also we need to add <code>_mut</code> variants for peeking.</p>
<pre><code class="language-rust ignore">use std::cell::{Ref, RefCell, RefMut};

//..

pub fn push_back(&amp;mut self, elem: T) {
    let new_tail = Node::new(elem);
    match self.tail.take() {
        Some(old_tail) =&gt; {
            old_tail.borrow_mut().next = Some(new_tail.clone());
            new_tail.borrow_mut().prev = Some(old_tail);
            self.tail = Some(new_tail);
        }
        None =&gt; {
            self.head = Some(new_tail.clone());
            self.tail = Some(new_tail);
        }
    }
}

pub fn pop_back(&amp;mut self) -&gt; Option&lt;T&gt; {
    self.tail.take().map(|old_tail| {
        match old_tail.borrow_mut().prev.take() {
            Some(new_tail) =&gt; {
                new_tail.borrow_mut().next.take();
                self.tail = Some(new_tail);
            }
            None =&gt; {
                self.head.take();
            }
        }
        Rc::try_unwrap(old_tail).ok().unwrap().into_inner().elem
    })
}

pub fn peek_back(&amp;self) -&gt; Option&lt;Ref&lt;T&gt;&gt; {
    self.tail.as_ref().map(|node| {
        Ref::map(node.borrow(), |node| &amp;node.elem)
    })
}

pub fn peek_back_mut(&amp;mut self) -&gt; Option&lt;RefMut&lt;T&gt;&gt; {
    self.tail.as_ref().map(|node| {
        RefMut::map(node.borrow_mut(), |node| &amp;mut node.elem)
    })
}

pub fn peek_front_mut(&amp;mut self) -&gt; Option&lt;RefMut&lt;T&gt;&gt; {
    self.head.as_ref().map(|node| {
        RefMut::map(node.borrow_mut(), |node| &amp;mut node.elem)
    })
}
</code></pre>
<p>And massively flesh out our tests:</p>
<pre><code class="language-rust ignore">#[test]
fn basics() {
    let mut list = List::new();

    // Check empty list behaves right
    assert_eq!(list.pop_front(), None);

    // Populate list
    list.push_front(1);
    list.push_front(2);
    list.push_front(3);

    // Check normal removal
    assert_eq!(list.pop_front(), Some(3));
    assert_eq!(list.pop_front(), Some(2));

    // Push some more just to make sure nothing's corrupted
    list.push_front(4);
    list.push_front(5);

    // Check normal removal
    assert_eq!(list.pop_front(), Some(5));
    assert_eq!(list.pop_front(), Some(4));

    // Check exhaustion
    assert_eq!(list.pop_front(), Some(1));
    assert_eq!(list.pop_front(), None);

    // ---- back -----

    // Check empty list behaves right
    assert_eq!(list.pop_back(), None);

    // Populate list
    list.push_back(1);
    list.push_back(2);
    list.push_back(3);

    // Check normal removal
    assert_eq!(list.pop_back(), Some(3));
    assert_eq!(list.pop_back(), Some(2));

    // Push some more just to make sure nothing's corrupted
    list.push_back(4);
    list.push_back(5);

    // Check normal removal
    assert_eq!(list.pop_back(), Some(5));
    assert_eq!(list.pop_back(), Some(4));

    // Check exhaustion
    assert_eq!(list.pop_back(), Some(1));
    assert_eq!(list.pop_back(), None);
}

#[test]
fn peek() {
    let mut list = List::new();
    assert!(list.peek_front().is_none());
    assert!(list.peek_back().is_none());
    assert!(list.peek_front_mut().is_none());
    assert!(list.peek_back_mut().is_none());

    list.push_front(1); list.push_front(2); list.push_front(3);

    assert_eq!(&amp;*list.peek_front().unwrap(), &amp;3);
    assert_eq!(&amp;mut *list.peek_front_mut().unwrap(), &amp;mut 3);
    assert_eq!(&amp;*list.peek_back().unwrap(), &amp;1);
    assert_eq!(&amp;mut *list.peek_back_mut().unwrap(), &amp;mut 1);
}
</code></pre>
<p>Are there some cases we're not testing? Probably. The combinatoric space
has really blown up here. Our code is at very least not <em>obviously wrong</em>.</p>
<pre><code class="language-text">&gt; cargo test

     Running target/debug/lists-5c71138492ad4b4a

running 10 tests
test first::test::basics ... ok
test fourth::test::basics ... ok
test second::test::basics ... ok
test fourth::test::peek ... ok
test second::test::iter ... ok
test third::test::iter ... ok
test second::test::into_iter ... ok
test second::test::iter_mut ... ok
test second::test::peek ... ok
test third::test::basics ... ok

test result: ok. 10 passed; 0 failed; 0 ignored; 0 measured

</code></pre>
<p>Nice. Copy-pasting is the best kind of programming.</p>
<h1><a class="header" href="#iteration" id="iteration">Iteration</a></h1>
<p>Let's take a crack at iterating this bad-boy.</p>
<h2><a class="header" href="#intoiter-1" id="intoiter-1">IntoIter</a></h2>
<p>IntoIter, as always, is going to be the easiest. Just wrap the stack and
call <code>pop</code>:</p>
<pre><code class="language-rust ignore">pub struct IntoIter&lt;T&gt;(List&lt;T&gt;);

impl&lt;T&gt; List&lt;T&gt; {
    pub fn into_iter(self) -&gt; IntoIter&lt;T&gt; {
        IntoIter(self)
    }
}

impl&lt;T&gt; Iterator for IntoIter&lt;T&gt; {
    type Item = T;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.0.pop_front()
    }
}
</code></pre>
<p>But we have an interesting new development. Where previously there was only
ever one &quot;natural&quot; iteration order for our lists, a Deque is inherently
bi-directional. What's so special about front-to-back? What if someone wants
to iterate in the other direction?</p>
<p>Rust actually has an answer to this: <code>DoubleEndedIterator</code>. DoubleEndedIterator
<em>inherits</em> from Iterator (meaning all DoubleEndedIterator are Iterators) and
requires one new method: <code>next_back</code>. It has the exact same signature as
<code>next</code>, but it's supposed to yield elements from the other end. The semantics
of DoubleEndedIterator are super convenient for us: the iterator becomes a
deque. You can consume elements from the front and back until the two ends
converge, at which point the iterator is empty.</p>
<p>Much like Iterator and <code>next</code>, it turns out that <code>next_back</code> isn't really
something consumers of the DoubleEndedIterator really care about. Rather, the
best part of this interface is that it exposes the <code>rev</code> method, which wraps
up the iterator to make a new one that yields the elements in reverse order.
The semantics of this are fairly straight-forward: calls to <code>next</code> on the
reversed iterator are just calls to <code>next_back</code>.</p>
<p>Anyway, because we're already a deque providing this API is pretty easy:</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; DoubleEndedIterator for IntoIter&lt;T&gt; {
    fn next_back(&amp;mut self) -&gt; Option&lt;T&gt; {
        self.0.pop_back()
    }
}
</code></pre>
<p>And let's test it out:</p>
<pre><code class="language-rust ignore">#[test]
fn into_iter() {
    let mut list = List::new();
    list.push_front(1); list.push_front(2); list.push_front(3);

    let mut iter = list.into_iter();
    assert_eq!(iter.next(), Some(3));
    assert_eq!(iter.next_back(), Some(1));
    assert_eq!(iter.next(), Some(2));
    assert_eq!(iter.next_back(), None);
    assert_eq!(iter.next(), None);
}
</code></pre>
<pre><code class="language-text">cargo test

     Running target/debug/lists-5c71138492ad4b4a

running 11 tests
test fourth::test::basics ... ok
test fourth::test::peek ... ok
test fourth::test::into_iter ... ok
test first::test::basics ... ok
test second::test::basics ... ok
test second::test::iter ... ok
test second::test::iter_mut ... ok
test third::test::iter ... ok
test third::test::basics ... ok
test second::test::into_iter ... ok
test second::test::peek ... ok

test result: ok. 11 passed; 0 failed; 0 ignored; 0 measured

</code></pre>
<p>Nice.</p>
<h2><a class="header" href="#iter-1" id="iter-1">Iter</a></h2>
<p>Iter will be a bit less forgiving. We'll have to deal with those awful <code>Ref</code>
things again! Because of Refs, we can't store <code>&amp;Node</code>s like we did before.
Instead, let's try to store <code>Ref&lt;Node&gt;</code>s:</p>
<pre><code class="language-rust ignore">pub struct Iter&lt;'a, T&gt;(Option&lt;Ref&lt;'a, Node&lt;T&gt;&gt;&gt;);

impl&lt;T&gt; List&lt;T&gt; {
    pub fn iter(&amp;self) -&gt; Iter&lt;T&gt; {
        Iter(self.head.as_ref().map(|head| head.borrow()))
    }
}
</code></pre>
<pre><code class="language-text">&gt; cargo build

</code></pre>
<p>So far so good. Implementing <code>next</code> is going to be a bit hairy, but I think
it's the same basic logic as the old stack IterMut but with extra RefCell
madness:</p>
<pre><code class="language-rust ignore">impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {
    type Item = Ref&lt;'a, T&gt;;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.0.take().map(|node_ref| {
            self.0 = node_ref.next.as_ref().map(|head| head.borrow());
            Ref::map(node_ref, |node| &amp;node.elem)
        })
    }
}
</code></pre>
<pre><code class="language-text">cargo build

error[E0521]: borrowed data escapes outside of closure
   --&gt; src/fourth.rs:155:13
    |
153 |     fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
    |             --------- `self` is declared here, outside of the closure body
154 |         self.0.take().map(|node_ref| {
155 |             self.0 = node_ref.next.as_ref().map(|head| head.borrow());
    |             ^^^^^^   -------- borrow is only valid in the closure body
    |             |
    |             reference to `node_ref` escapes the closure body here

error[E0505]: cannot move out of `node_ref` because it is borrowed
   --&gt; src/fourth.rs:156:22
    |
153 |     fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
    |             --------- lifetime `'1` appears in the type of `self`
154 |         self.0.take().map(|node_ref| {
155 |             self.0 = node_ref.next.as_ref().map(|head| head.borrow());
    |             ------   -------- borrow of `node_ref` occurs here
    |             |
    |             assignment requires that `node_ref` is borrowed for `'1`
156 |             Ref::map(node_ref, |node| &amp;node.elem)
    |                      ^^^^^^^^ move out of `node_ref` occurs here
</code></pre>
<p>Shoot.</p>
<p><code>node_ref</code> doesn't live long enough. Unlike normal references, Rust doesn't let
us just split Refs up like that. The Ref we get out of <code>head.borrow()</code> is only
allowed to live as long as <code>node_ref</code>, but we end up trashing that in our
<code>Ref::map</code> call.</p>
<p>The function we want exists, and it's called <em>[map_split][]</em>:</p>
<pre><code class="language-rust ignore">pub fn map_split&lt;U, V, F&gt;(orig: Ref&lt;'b, T&gt;, f: F) -&gt; (Ref&lt;'b, U&gt;, Ref&lt;'b, V&gt;) where
    F: FnOnce(&amp;T) -&gt; (&amp;U, &amp;V),
    U: ?Sized,
    V: ?Sized,
</code></pre>
<p>Woof. Let's give it a try...</p>
<pre><code class="language-rust ignore">fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
    self.0.take().map(|node_ref| {
        let (next, elem) = Ref::map_split(node_ref, |node| {
            (&amp;node.next, &amp;node.elem)
        });

        self.0 = next.as_ref().map(|head| head.borrow());

        elem
    })
}
</code></pre>
<pre><code class="language-text">cargo build
   Compiling lists v0.1.0 (/Users/ADesires/dev/temp/lists)
error[E0521]: borrowed data escapes outside of closure
   --&gt; src/fourth.rs:159:13
    |
153 |     fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
    |             --------- `self` is declared here, outside of the closure body
...
159 |             self.0 = next.as_ref().map(|head| head.borrow());
    |             ^^^^^^   ---- borrow is only valid in the closure body
    |             |
    |             reference to `next` escapes the closure body here
</code></pre>
<p>Ergh. We need to <code>Ref::Map</code> again to get our lifetimes right. But <code>Ref::Map</code>
returns a <code>Ref</code> and we need an <code>Option&lt;Ref&gt;</code>, but we need to go through the
Ref to map over our Option...</p>
<p><strong>stares into distance for a long time</strong></p>
<p>??????</p>
<pre><code class="language-rust ignore">fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
    self.0.take().map(|node_ref| {
        let (next, elem) = Ref::map_split(node_ref, |node| {
            (&amp;node.next, &amp;node.elem)
        });

        self.0 = if next.is_some() {
            Some(Ref::map(next, |next| &amp;**next.as_ref().unwrap()))
        } else {
            None
        };

        elem
    })
}
</code></pre>
<pre><code class="language-text">error[E0308]: mismatched types
   --&gt; src/fourth.rs:162:22
    |
162 |                 Some(Ref::map(next, |next| &amp;**next.as_ref().unwrap()))
    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `fourth::Node`, found struct `std::cell::RefCell`
    |
    = note: expected type `std::cell::Ref&lt;'_, fourth::Node&lt;_&gt;&gt;`
               found type `std::cell::Ref&lt;'_, std::cell::RefCell&lt;fourth::Node&lt;_&gt;&gt;&gt;`
</code></pre>
<p>Oh. Right. There's multiple RefCells. The deeper we walk into the list, the more
nested we become under each RefCell. We would need to maintain, like, a stack of
Refs to represent all the outstanding loans we're holding, because if we stop
looking at an element we need to decrement the borrow-count on every RefCell that
comes before it.................</p>
<p>I don't think there's anything we can do here. It's a dead end. Let's try
getting out of the RefCells.</p>
<p>What about our <code>Rc</code>s. Who said we even needed to store references?
Why can't we just Clone the whole Rc to get a nice owning handle into the middle
of the list?</p>
<pre><code class="language-rust ignore">pub struct Iter&lt;T&gt;(Option&lt;Rc&lt;Node&lt;T&gt;&gt;&gt;);

impl&lt;T&gt; List&lt;T&gt; {
    pub fn iter(&amp;self) -&gt; Iter&lt;T&gt; {
        Iter(self.head.as_ref().map(|head| head.clone()))
    }
}

impl&lt;T&gt; Iterator for Iter&lt;T&gt; {
    type Item =
</code></pre>
<p>Uh... Wait what do we return now? <code>&amp;T</code>? <code>Ref&lt;T&gt;</code>?</p>
<p>No, none of those work... our Iter doesn't have a lifetime anymore! Both <code>&amp;T</code>
and <code>Ref&lt;T&gt;</code> require us to declare some lifetime up front before we get into
<code>next</code>. But anything we manage to get out of our Rc would be borrowing the
Iterator... brain... hurt... aaaaaahhhhhh</p>
<p>Maybe we can... map... the Rc... to get an <code>Rc&lt;T&gt;</code>? Is that a thing? Rc's docs
don't seem to have anything like that. Actually someone made <a href="https://crates.io/crates/owning_ref">a crate</a>
that lets you do that.</p>
<p>But wait, even if we do <em>that</em> then we've got an even bigger problem: the
dreaded spectre of iterator invalidation. Previously we've been totally immune
to iterator invalidation, because the Iter borrowed the list, leaving it totally
immutable. However if our Iter was yielding Rcs, they wouldn't borrow the list
at all! That means people can start calling <code>push</code> and <code>pop</code> on the list while
they hold pointers into it!</p>
<p>Oh lord, what will that do?!</p>
<p>Well, pushing is actually fine. We've got a view into some sub-range of the
list, and the list will just grow beyond our sights. No biggie.</p>
<p>However <code>pop</code> is another story. If they're popping elements outside of our
range, it should <em>still</em> be fine. We can't see those nodes so nothing will
happen. However if they try to pop off the node we're pointing at... everything
will blow up! In particular when they go to <code>unwrap</code> the result of the
<code>try_unwrap</code>, it will actually fail, and the whole program will panic.</p>
<p>That's actually pretty cool. We can get tons of interior owning pointers into
the list and mutate it at the same time <em>and it will just work</em> until they
try to remove the nodes that we're pointing at. And even then we don't get
dangling pointers or anything, the program will deterministically panic!</p>
<p>But having to deal with iterator invalidation on top of mapping Rcs just
seems... bad. <code>Rc&lt;RefCell&gt;</code> has really truly finally failed us. Interestingly,
we've experienced an inversion of the persistent stack case. Where the
persistent stack struggled to ever reclaim ownership of the data but could get
references all day every day, our list had no problem gaining ownership, but
really struggled to loan our references.</p>
<p>Although to be fair, most of our struggles revolved around wanting to hide the
implementation details and have a decent API. We <em>could</em> do everything fine
if we wanted to just pass around Nodes all over the place.</p>
<p>Heck, we could make multiple concurrent IterMuts that were runtime checked to
not be mutable accessing the same element!</p>
<p>Really, this design is more appropriate for an internal data structure that
never makes it out to consumers of the API. Interior mutability is great for
writing safe <em>applications</em>. Not so much safe <em>libraries</em>.</p>
<p>Anyway, that's me giving up on Iter and IterMut. We could do them, but <em>ugh</em>.</p>
<h1><a class="header" href="#final-code-2" id="final-code-2">Final Code</a></h1>
<p>Alright, so that's implementing a 100% safe doubly-linked list in Rust. It was
a nightmare to implement, leaks implementation details, and doesn't support several
fundamental operations.</p>
<p>But, it exists.</p>
<p>Oh, I guess it's also riddled with tons of &quot;unnecessary&quot; runtime checks for
correctness between <code>Rc</code> and <code>RefCell</code>. I put unnecessary in quotes because
they're actually necessary to guarantee the whole <em>actually being safe</em> thing.
We encountered a few places where those checks actually <em>were</em> necessary.
Doubly-linked lists have a horribly tangled aliasing and ownership story!</p>
<p>Still, it's a thing we can do. Especially if we don't care about exposing
internal data structures to our consumers.</p>
<p>From here on out, we're going to be focusing on other side of this coin:
getting back all the control by making our implementation <em>unsafe</em>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::Rc;
use std::cell::{Ref, RefMut, RefCell};

pub struct List&lt;T&gt; {
    head: Link&lt;T&gt;,
    tail: Link&lt;T&gt;,
}

type Link&lt;T&gt; = Option&lt;Rc&lt;RefCell&lt;Node&lt;T&gt;&gt;&gt;&gt;;

struct Node&lt;T&gt; {
    elem: T,
    next: Link&lt;T&gt;,
    prev: Link&lt;T&gt;,
}


impl&lt;T&gt; Node&lt;T&gt; {
    fn new(elem: T) -&gt; Rc&lt;RefCell&lt;Self&gt;&gt; {
        Rc::new(RefCell::new(Node {
            elem: elem,
            prev: None,
            next: None,
        }))
    }
}

impl&lt;T&gt; List&lt;T&gt; {
    pub fn new() -&gt; Self {
        List { head: None, tail: None }
    }

    pub fn push_front(&amp;mut self, elem: T) {
        let new_head = Node::new(elem);
        match self.head.take() {
            Some(old_head) =&gt; {
                old_head.borrow_mut().prev = Some(new_head.clone());
                new_head.borrow_mut().next = Some(old_head);
                self.head = Some(new_head);
            }
            None =&gt; {
                self.tail = Some(new_head.clone());
                self.head = Some(new_head);
            }
        }
    }

    pub fn push_back(&amp;mut self, elem: T) {
        let new_tail = Node::new(elem);
        match self.tail.take() {
            Some(old_tail) =&gt; {
                old_tail.borrow_mut().next = Some(new_tail.clone());
                new_tail.borrow_mut().prev = Some(old_tail);
                self.tail = Some(new_tail);
            }
            None =&gt; {
                self.head = Some(new_tail.clone());
                self.tail = Some(new_tail);
            }
        }
    }

    pub fn pop_back(&amp;mut self) -&gt; Option&lt;T&gt; {
        self.tail.take().map(|old_tail| {
            match old_tail.borrow_mut().prev.take() {
                Some(new_tail) =&gt; {
                    new_tail.borrow_mut().next.take();
                    self.tail = Some(new_tail);
                }
                None =&gt; {
                    self.head.take();
                }
            }
            Rc::try_unwrap(old_tail).ok().unwrap().into_inner().elem
        })
    }

    pub fn pop_front(&amp;mut self) -&gt; Option&lt;T&gt; {
        self.head.take().map(|old_head| {
            match old_head.borrow_mut().next.take() {
                Some(new_head) =&gt; {
                    new_head.borrow_mut().prev.take();
                    self.head = Some(new_head);
                }
                None =&gt; {
                    self.tail.take();
                }
            }
            Rc::try_unwrap(old_head).ok().unwrap().into_inner().elem
        })
    }

    pub fn peek_front(&amp;self) -&gt; Option&lt;Ref&lt;T&gt;&gt; {
        self.head.as_ref().map(|node| {
            Ref::map(node.borrow(), |node| &amp;node.elem)
        })
    }

    pub fn peek_back(&amp;self) -&gt; Option&lt;Ref&lt;T&gt;&gt; {
        self.tail.as_ref().map(|node| {
            Ref::map(node.borrow(), |node| &amp;node.elem)
        })
    }

    pub fn peek_back_mut(&amp;mut self) -&gt; Option&lt;RefMut&lt;T&gt;&gt; {
        self.tail.as_ref().map(|node| {
            RefMut::map(node.borrow_mut(), |node| &amp;mut node.elem)
        })
    }

    pub fn peek_front_mut(&amp;mut self) -&gt; Option&lt;RefMut&lt;T&gt;&gt; {
        self.head.as_ref().map(|node| {
            RefMut::map(node.borrow_mut(), |node| &amp;mut node.elem)
        })
    }

    pub fn into_iter(self) -&gt; IntoIter&lt;T&gt; {
        IntoIter(self)
    }
}

impl&lt;T&gt; Drop for List&lt;T&gt; {
    fn drop(&amp;mut self) {
        while self.pop_front().is_some() {}
    }
}

pub struct IntoIter&lt;T&gt;(List&lt;T&gt;);

impl&lt;T&gt; Iterator for IntoIter&lt;T&gt; {
    type Item = T;

    fn next(&amp;mut self) -&gt; Option&lt;T&gt; {
        self.0.pop_front()
    }
}

impl&lt;T&gt; DoubleEndedIterator for IntoIter&lt;T&gt; {
    fn next_back(&amp;mut self) -&gt; Option&lt;T&gt; {
        self.0.pop_back()
    }
}

#[cfg(test)]
mod test {
    use super::List;

    #[test]
    fn basics() {
        let mut list = List::new();

        // Check empty list behaves right
        assert_eq!(list.pop_front(), None);

        // Populate list
        list.push_front(1);
        list.push_front(2);
        list.push_front(3);

        // Check normal removal
        assert_eq!(list.pop_front(), Some(3));
        assert_eq!(list.pop_front(), Some(2));

        // Push some more just to make sure nothing's corrupted
        list.push_front(4);
        list.push_front(5);

        // Check normal removal
        assert_eq!(list.pop_front(), Some(5));
        assert_eq!(list.pop_front(), Some(4));

        // Check exhaustion
        assert_eq!(list.pop_front(), Some(1));
        assert_eq!(list.pop_front(), None);

        // ---- back -----

        // Check empty list behaves right
        assert_eq!(list.pop_back(), None);

        // Populate list
        list.push_back(1);
        list.push_back(2);
        list.push_back(3);

        // Check normal removal
        assert_eq!(list.pop_back(), Some(3));
        assert_eq!(list.pop_back(), Some(2));

        // Push some more just to make sure nothing's corrupted
        list.push_back(4);
        list.push_back(5);

        // Check normal removal
        assert_eq!(list.pop_back(), Some(5));
        assert_eq!(list.pop_back(), Some(4));

        // Check exhaustion
        assert_eq!(list.pop_back(), Some(1));
        assert_eq!(list.pop_back(), None);
    }

    #[test]
    fn peek() {
        let mut list = List::new();
        assert!(list.peek_front().is_none());
        assert!(list.peek_back().is_none());
        assert!(list.peek_front_mut().is_none());
        assert!(list.peek_back_mut().is_none());

        list.push_front(1); list.push_front(2); list.push_front(3);

        assert_eq!(&amp;*list.peek_front().unwrap(), &amp;3);
        assert_eq!(&amp;mut *list.peek_front_mut().unwrap(), &amp;mut 3);
        assert_eq!(&amp;*list.peek_back().unwrap(), &amp;1);
        assert_eq!(&amp;mut *list.peek_back_mut().unwrap(), &amp;mut 1);
    }

    #[test]
    fn into_iter() {
        let mut list = List::new();
        list.push_front(1); list.push_front(2); list.push_front(3);

        let mut iter = list.into_iter();
        assert_eq!(iter.next(), Some(3));
        assert_eq!(iter.next_back(), Some(1));
        assert_eq!(iter.next(), Some(2));
        assert_eq!(iter.next_back(), None);
        assert_eq!(iter.next(), None);
    }
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#an-ok-unsafe-singly-linked-queue" id="an-ok-unsafe-singly-linked-queue">An Ok Unsafe Singly-Linked Queue</a></h1>
<p>Ok that reference-counted interior mutability stuff got a little out of
control. Surely Rust doesn't really expect you to do that sort of thing
in general? Well, yes and no. Rc and Refcell can be great for handling
simple cases, but they can get unwieldy. Especially if you
want to hide that it's happening. There's gotta be a better way!</p>
<p>In this chapter we're going to roll back to singly-linked lists and
implement a singly-linked queue to dip our toes into <em>raw pointers</em>
and <em>Unsafe Rust</em>.</p>
<blockquote>
<p><strong>NARRATOR:</strong> And I will point out the mistakes.</p>
</blockquote>
<p>And we won't make <em>any</em> mistakes.</p>
<p>Let's add a new file called <code>fifth.rs</code>:</p>
<pre><code class="language-rust ignore">// in lib.rs

pub mod first;
pub mod second;
pub mod third;
pub mod fourth;
pub mod fifth;
</code></pre>
<p>Our code is largely going to be derived from second.rs, since a queue is
mostly an augmentation of a stack in the world of linked lists. Still, we're
going to go from scratch because there's some fundamental issues we want to
address with layout and what-not.</p>
<h1><a class="header" href="#layout-2" id="layout-2">Layout</a></h1>
<p>So what's a singly-linked queue like? Well, when we had a singly-linked stack
we pushed onto one end of the list, and then popped off the same end. The only
difference between a stack and a queue is that a queue pops off the <em>other</em>
end. So from our stack implementation we have:</p>
<pre><code class="language-text">input list:
[Some(ptr)] -&gt; (A, Some(ptr)) -&gt; (B, None)

stack push X:
[Some(ptr)] -&gt; (X, Some(ptr)) -&gt; (A, Some(ptr)) -&gt; (B, None)

stack pop:
[Some(ptr)] -&gt; (A, Some(ptr)) -&gt; (B, None)
</code></pre>
<p>To make a queue, we just need to decide which operation to move to the
end of the list: push, or pop? Since our list is singly-linked, we can
actually move <em>either</em> operation to the end with the same amount of effort.</p>
<p>To move <code>push</code> to the end, we just walk all the way to the <code>None</code> and set it
to Some with the new element.</p>
<pre><code class="language-text">input list:
[Some(ptr)] -&gt; (A, Some(ptr)) -&gt; (B, None)

flipped push X:
[Some(ptr)] -&gt; (A, Some(ptr)) -&gt; (B, Some(ptr)) -&gt; (X, None)
</code></pre>
<p>To move <code>pop</code> to the end, we just walk all the way to the node <em>before</em> the
None, and <code>take</code> it:</p>
<pre><code class="language-text">input list:
[Some(ptr)] -&gt; (A, Some(ptr)) -&gt; (B, Some(ptr)) -&gt; (X, None)

flipped pop:
[Some(ptr)] -&gt; (A, Some(ptr)) -&gt; (B, None)
</code></pre>
<p>We could do this today and call it quits, but that would stink! Both of these
operations walk over the <em>entire</em> list. Some would argue that such a queue
implementation is indeed a queue because it exposes the right interface. However
I believe that performance guarantees are part of the interface. I don't care
about precise asymptotic bounds, just &quot;fast&quot; vs &quot;slow&quot;. Queues guarantee
that push and pop are fast, and walking over the whole list is definitely <em>not</em>
fast.</p>
<p>One key observation is that we're wasting a ton of work doing <em>the same thing</em>
over and over. Can we &quot;cache&quot; all that work and reuse it? Why, yes! We can store a pointer to
the end of the list, and just jump straight to there!</p>
<p>It turns out that only one inversion of <code>push</code> and <code>pop</code> works with this.
To invert <code>pop</code> we would have to move the &quot;tail&quot; pointer backwards, but
because our list is singly-linked, we can't do that efficiently.
If we instead invert <code>push</code> we only have to move the &quot;head&quot; pointer
forward, which is easy.</p>
<p>Let's try that:</p>
<pre><code class="language-rust ignore">use std::mem;

pub struct List&lt;T&gt; {
    head: Link&lt;T&gt;,
    tail: Link&lt;T&gt;, // NEW!
}

type Link&lt;T&gt; = Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;;

struct Node&lt;T&gt; {
    elem: T,
    next: Link&lt;T&gt;,
}

impl&lt;T&gt; List&lt;T&gt; {
    pub fn new() -&gt; Self {
        List { head: None, tail: None }
    }

    pub fn push(&amp;mut self, elem: T) {
        let new_tail = Box::new(Node {
            elem: elem,
            // When you push onto the tail, your next is always None
            next: None,
        });

        // swap the old tail to point to the new tail
        let old_tail = mem::replace(&amp;mut self.tail, Some(new_tail));

        match old_tail {
            Some(mut old_tail) =&gt; {
                // If the old tail existed, update it to point to the new tail
                old_tail.next = Some(new_tail);
            }
            None =&gt; {
                // Otherwise, update the head to point to it
                self.head = Some(new_tail);
            }
        }
    }
}
</code></pre>
<p>I'm going a bit faster with the impl details now since we should be pretty
comfortable with this sort of thing. Not that you should necessarily expect
to produce this code on the first try. I'm just skipping over some of the
trial-and-error we've had to deal with before. I actually made a ton of mistakes
writing this code that I'm not showing, but you can only see me leave off a <code>mut</code> or
<code>;</code> so many times before it stops being instructive. Don't worry, we'll see
plenty of <em>other</em> error messages!</p>
<pre><code class="language-text">&gt; cargo build

error[E0382]: use of moved value: `new_tail`
  --&gt; src/fifth.rs:38:38
   |
26 |         let new_tail = Box::new(Node {
   |             -------- move occurs because `new_tail` has type `std::boxed::Box&lt;fifth::Node&lt;T&gt;&gt;`, which does not implement the `Copy` trait
...
33 |         let old_tail = mem::replace(&amp;mut self.tail, Some(new_tail));
   |                                                          -------- value moved here
...
38 |                 old_tail.next = Some(new_tail);
   |                                      ^^^^^^^^ value used here after move
</code></pre>
<p>Shoot!</p>
<blockquote>
<p>use of moved value: <code>new_tail</code></p>
</blockquote>
<p>Box doesn't implement Copy, so we can't just assign it to two locations. More
importantly, Box <em>owns</em> the thing it points to, and will try to free it when
it's dropped. If our <code>push</code> implementation compiled, we'd double-free the tail
of our list! Actually, as written, our code would free the old_tail on every
push. Yikes! 🙀</p>
<p>Alright, well we know how to make a non-owning pointer. That's just a reference!</p>
<pre><code class="language-rust ignore">pub struct List&lt;T&gt; {
    head: Link&lt;T&gt;,
    tail: Option&lt;&amp;mut Node&lt;T&gt;&gt;, // NEW!
}

type Link&lt;T&gt; = Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;;

struct Node&lt;T&gt; {
    elem: T,
    next: Link&lt;T&gt;,
}

impl&lt;T&gt; List&lt;T&gt; {
    pub fn new() -&gt; Self {
        List { head: None, tail: None }
    }

    pub fn push(&amp;mut self, elem: T) {
        let new_tail = Box::new(Node {
            elem: elem,
            // When you push onto the tail, your next is always None
            next: None,
        });

        // Put the box in the right place, and then grab a reference to its Node
        let new_tail = match self.tail.take() {
            Some(old_tail) =&gt; {
                // If the old tail existed, update it to point to the new tail
                old_tail.next = Some(new_tail);
                old_tail.next.as_deref_mut()
            }
            None =&gt; {
                // Otherwise, update the head to point to it
                self.head = Some(new_tail);
                self.head.as_deref_mut()
            }
        };

        self.tail = new_tail;
    }
}
</code></pre>
<p>Nothing too tricky here. Same basic idea as the previous code, except we're
using some of that implicit return goodness to extract the tail reference from
wherever we stuff the actual Box.</p>
<pre><code class="language-text">&gt; cargo build

error[E0106]: missing lifetime specifier
 --&gt; src/fifth.rs:3:18
  |
3 |     tail: Option&lt;&amp;mut Node&lt;T&gt;&gt;, // NEW!
  |                  ^ expected lifetime parameter
</code></pre>
<p>Oh right, we need to give lifetimes to references in types. Hmm... what's the
lifetime of this reference? Well, this seems like IterMut, right? Let's try
what we did for IterMut, and just add a generic <code>'a</code>:</p>
<pre><code class="language-rust ignore">pub struct List&lt;'a, T&gt; {
    head: Link&lt;T&gt;,
    tail: Option&lt;&amp;'a mut Node&lt;T&gt;&gt;, // NEW!
}

type Link&lt;T&gt; = Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;;

struct Node&lt;T&gt; {
    elem: T,
    next: Link&lt;T&gt;,
}

impl&lt;'a, T&gt; List&lt;'a, T&gt; {
    pub fn new() -&gt; Self {
        List { head: None, tail: None }
    }

    pub fn push(&amp;mut self, elem: T) {
        let new_tail = Box::new(Node {
            elem: elem,
            // When you push onto the tail, your next is always None
            next: None,
        });

        // Put the box in the right place, and then grab a reference to its Node
        let new_tail = match self.tail.take() {
            Some(old_tail) =&gt; {
                // If the old tail existed, update it to point to the new tail
                old_tail.next = Some(new_tail);
                old_tail.next.as_deref_mut()
            }
            None =&gt; {
                // Otherwise, update the head to point to it
                self.head = Some(new_tail);
                self.head.as_deref_mut()
            }
        };

        self.tail = new_tail;
    }
}
</code></pre>
<pre><code class="language-text">cargo build

error[E0495]: cannot infer an appropriate lifetime for autoref due to conflicting requirements
  --&gt; src/fifth.rs:35:27
   |
35 |                 self.head.as_deref_mut()
   |                           ^^^^^^^^^^^^
   |
note: first, the lifetime cannot outlive the anonymous lifetime #1 defined on the method body at 18:5...
  --&gt; src/fifth.rs:18:5
   |
18 | /     pub fn push(&amp;mut self, elem: T) {
19 | |         let new_tail = Box::new(Node {
20 | |             elem: elem,
21 | |             // When you push onto the tail, your next is always None
...  |
39 | |         self.tail = new_tail;
40 | |     }
   | |_____^
note: ...so that reference does not outlive borrowed content
  --&gt; src/fifth.rs:35:17
   |
35 |                 self.head.as_deref_mut()
   |                 ^^^^^^^^^
note: but, the lifetime must be valid for the lifetime 'a as defined on the impl at 13:6...
  --&gt; src/fifth.rs:13:6
   |
13 | impl&lt;'a, T&gt; List&lt;'a, T&gt; {
   |      ^^
   = note: ...so that the expression is assignable:
           expected std::option::Option&lt;&amp;'a mut fifth::Node&lt;T&gt;&gt;
              found std::option::Option&lt;&amp;mut fifth::Node&lt;T&gt;&gt;


</code></pre>
<p>Woah, that's a really detailed error message. That's a bit concerning, because it
suggests we're doing something really messed up. Here's an interesting part:</p>
<blockquote>
<p>the lifetime must be valid for the lifetime <code>'a</code> as defined on the impl</p>
</blockquote>
<p>We're borrowing from <code>self</code>, but the compiler wants us to last as long as <code>'a</code>,
what if we tell it <code>self</code> <em>does</em> last that long..?</p>
<pre><code class="language-rust ignore">    pub fn push(&amp;'a mut self, elem: T) {
</code></pre>
<pre><code class="language-text">cargo build

warning: field is never used: `elem`
 --&gt; src/fifth.rs:9:5
  |
9 |     elem: T,
  |     ^^^^^^^
  |
  = note: #[warn(dead_code)] on by default
</code></pre>
<p>Oh, hey, that worked! Great!</p>
<p>Let's just do <code>pop</code> too:</p>
<pre><code class="language-rust ignore">pub fn pop(&amp;'a mut self) -&gt; Option&lt;T&gt; {
    // Grab the list's current head
    self.head.take().map(|head| {
        let head = *head;
        self.head = head.next;

        // If we're out of `head`, make sure to set the tail to `None`.
        if self.head.is_none() {
            self.tail = None;
        }

        head.elem
    })
}
</code></pre>
<p>And write a quick test for that:</p>
<pre><code class="language-rust ignore">#[cfg(test)]
mod test {
    use super::List;
    #[test]
    fn basics() {
        let mut list = List::new();

        // Check empty list behaves right
        assert_eq!(list.pop(), None);

        // Populate list
        list.push(1);
        list.push(2);
        list.push(3);

        // Check normal removal
        assert_eq!(list.pop(), Some(1));
        assert_eq!(list.pop(), Some(2));

        // Push some more just to make sure nothing's corrupted
        list.push(4);
        list.push(5);

        // Check normal removal
        assert_eq!(list.pop(), Some(3));
        assert_eq!(list.pop(), Some(4));

        // Check exhaustion
        assert_eq!(list.pop(), Some(5));
        assert_eq!(list.pop(), None);
    }
}
</code></pre>
<pre><code class="language-text">cargo test

error[E0499]: cannot borrow `list` as mutable more than once at a time
  --&gt; src/fifth.rs:68:9
   |
65 |         assert_eq!(list.pop(), None);
   |                    ---- first mutable borrow occurs here
...
68 |         list.push(1);
   |         ^^^^
   |         |
   |         second mutable borrow occurs here
   |         first borrow later used here

error[E0499]: cannot borrow `list` as mutable more than once at a time
  --&gt; src/fifth.rs:69:9
   |
65 |         assert_eq!(list.pop(), None);
   |                    ---- first mutable borrow occurs here
...
69 |         list.push(2);
   |         ^^^^
   |         |
   |         second mutable borrow occurs here
   |         first borrow later used here

error[E0499]: cannot borrow `list` as mutable more than once at a time
  --&gt; src/fifth.rs:70:9
   |
65 |         assert_eq!(list.pop(), None);
   |                    ---- first mutable borrow occurs here
...
70 |         list.push(3);
   |         ^^^^
   |         |
   |         second mutable borrow occurs here
   |         first borrow later used here


....

** WAY MORE LINES OF ERRORS **

....

error: aborting due to 11 previous errors
</code></pre>
<p>🙀🙀🙀🙀🙀🙀🙀🙀🙀🙀🙀🙀🙀🙀🙀🙀🙀🙀🙀🙀🙀🙀🙀</p>
<p>Oh my goodness.</p>
<p>The compiler's not wrong for vomiting all over us. We just committed a
cardinal Rust sin: we stored a reference to ourselves <em>inside ourselves</em>.
Somehow, we managed to convince Rust that this totally made sense in our
<code>push</code> and <code>pop</code> implementations (I was legitimately shocked we did). </p>
<p>The reason this <em>sort of</em> works is that Rust doesn't really have the notion
of a pointer into yourself at all. Each part of the code is <em>technically</em> correct
in isolation (we <em>can</em> call push and pop <em>once</em>) but then the absurdity of what
we created takes affect and everything just <em>locks up</em>. </p>
<p>I'm sure there is <em>some</em> use for what we've written, but as far as <em>I'm</em> concerned it's
just syntatically valid <em>gibberish</em>. We're saying we contain something with
lifetime <code>'a</code>,  and that <code>push</code> and <code>pop</code> borrows <em>self</em> for that lifetime. 
That's <em>weird</em> but Rust can look at each part of our code <em>individually</em> and
it doesn't see any rules being broken.</p>
<p>But as soon as we try to actually <em>use</em> the list, the compiler quickly goes 
&quot;yep you've borrowed <code>self</code> mutably for <code>'a</code>, so you can't use <code>self</code> anymore
until the end of <code>'a</code>&quot; but <em>also</em> &quot;because you contain <code>'a</code>, it must be valid
for the entire list's existence&quot;.</p>
<p>It's <em>nearly</em> a contradiction but there <em>is</em> one solution: as soon as you <code>push</code>
or <code>pop</code>, the list &quot;pins&quot; itself in place and can't be accessed anymore. It has
swallowed its own proverbial tail, and ascended to a world of dreams.</p>
<blockquote>
<p><strong>NARRATOR</strong>: it didn't exist when this book was first written, but Rust
actually <a href="https://doc.rust-lang.org/std/pin/index.html">formalized the notion of a <em>pin</em> into something useful</a>! 
This was probably the most complex addition to the language since 
<em>the borrowchecker</em>. We don't <em>want</em> our list to be pinned though!</p>
<p>Pins <em>are</em> necessary and useful for async-await/futures/coroutines because
the compiler needs to be able to bundle up all the local variables of a
function into some kind of struct and store them somewhere until the 
future/coroutine is ready to be resumed. Since local variables can reference
other local variables, and we want that to <em>work</em>, these structs can end
up containing references to themselves!</p>
<p>So to <code>await</code> or <code>yield</code> Rust needs a way to be able to properly describe
and manipulate pinned values. Thankfully all of this stuff is <em>largely</em>
just hidden away in automatic compiler machinery and no one actually has to
think about <code>Pin</code> (or even <em>Futures</em>) under normal circumstances. The main
exception is that this stuff is very important for the folks building and
designing async <em>runtimes</em> like tokio.</p>
<p>We will not be implementing an async runtime in this book. I know my friends
know all sorts of &quot;cool&quot; (messed up) <em>tricks</em> you can do with <code>Pin</code>,
but from what I can tell, I'd be happier to just not know them. I will
continue to tell myself that Pinned types aren't real and they can't hurt me. </p>
</blockquote>
<p>Our <code>pop</code> implementation hints at why storing a reference to ourselves
<em>inside</em> ourselves could be really dangerous:</p>
<pre><code class="language-rust ignore">// ...
if self.head.is_none() {
    self.tail = None;
}
</code></pre>
<p>What if we forgot to do this? Then our tail would point to some node <em>that
had been removed from the list</em>. Such a node would be instantly freed, and we'd
have a dangling pointer which Rust was supposed to protect us from!</p>
<p>And indeed Rust is protecting us from that kind of danger. Just in a very...
<strong>roundabout</strong> way.</p>
<p>So what can we do? Go back to <code>Rc&lt;RefCell&gt;&gt;</code> hell?</p>
<p>Please. No.</p>
<p>No, instead we're going to go off the rails and use <em>raw pointers</em>.
Our layout is going to look like this:</p>
<pre><code class="language-rust ignore">pub struct List&lt;T&gt; {
    head: Link&lt;T&gt;,
    tail: *mut Node&lt;T&gt;, // DANGER DANGER
}

type Link&lt;T&gt; = Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;;

struct Node&lt;T&gt; {
    elem: T,
    next: Link&lt;T&gt;,
}
</code></pre>
<p>And that's that. None of this wimpy reference-counted-dynamic-borrow-checking
nonsense! Real. Hard. Unchecked. Pointers.</p>
<blockquote>
<p><strong>NARRATOR:</strong> This implementation was in fact still dangerously wrong, but it wasn't yet time to learn that lesson. The next section will learn that the hard way, as usual.</p>
</blockquote>
<p>Let's be C everyone. Let's be C all day.</p>
<p>I'm home. I'm ready.</p>
<p>Hello <code>unsafe</code>.</p>
<blockquote>
<p><strong>NARRATOR:</strong> Wow, just incredible hubris from the author here.</p>
</blockquote>
<h1><a class="header" href="#unsafe-rust" id="unsafe-rust">Unsafe Rust</a></h1>
<p>This is a serious, big, complicated, and dangerous topic.
It's so serious that I wrote <a href="https://doc.rust-lang.org/nightly/nomicon/">an entire other book</a> on it.</p>
<p>The long and the short of it is that <em>every</em> language is actually unsafe as soon
as you allow calling into other languages, because you can just have C do
arbitrarily bad things. Yes: Java, Python, Ruby, Haskell... everyone is wildly
unsafe in the face of Foreign Function Interfaces (FFI).</p>
<p>Rust embraces this truth by splitting itself into two languages: Safe Rust, and
Unsafe Rust. So far we've only worked with Safe Rust. It's completely 100%
safe... except that it can FFI into Unsafe Rust.</p>
<p>Unsafe Rust is a <em>superset</em> of Safe Rust. It's completely the same as Safe Rust in all its
semantics and rules, you're just allowed to do a few <em>extra</em> things that are
wildly unsafe and can cause the dreaded Undefined Behaviour that haunts C.</p>
<p>Again, this is a really huge topic that has a lot of interesting corner cases.
I <em>really</em> don't want to go really deep into it (well, I do. I did. <a href="https://doc.rust-lang.org/nightly/nomicon/">Read that
book</a>). That's ok, because with linked lists we can actually ignore almost
all of it.</p>
<blockquote>
<p><strong>NARRATOR:</strong> This was a lie, but it did seem true in 2015.</p>
</blockquote>
<p>The main Unsafe tool we'll be using are <em>raw pointers</em>. Raw pointers are
basically C's pointers. They have no inherent aliasing rules. They have no
lifetimes. They can be null. They can be misaligned. They can be dangling. They can point to
uninitialized memory. They can be cast to and from integers. They can be cast
to point to a different type. Mutability? Cast it. Pretty much everything goes,
and that means pretty much anything can go wrong.</p>
<blockquote>
<p><strong>NARRATOR:</strong> no inherent aliasing rules, eh? Ah, the innocence of youth.</p>
</blockquote>
<p>This is some bad stuff and honestly you'll live a happier life never having
to touch these. Unfortunately, we want to write linked lists, and linked lists
are awful. That means we're going to have to use unsafe pointers.</p>
<p>There are two kinds of raw pointer: <code>*const T</code> and <code>*mut T</code>. These are meant to
be <code>const T*</code> and <code>T*</code> from C, but we really don't care about what C thinks they
mean that much. You can only dereference a <code>*const T</code> to an <code>&amp;T</code>, but much like
the mutability of a variable, this is just a lint against incorrect usage. At
most it just means you have to cast the <code>*const</code> to a <code>*mut</code> first. Although if
you don't actually have permission to mutate the referent of the pointer,
you're gonna have a bad time.</p>
<p>Anyway, we'll get a better feel for this as we write some code. For now,
<code>*mut T == &amp;unchecked mut T</code>!</p>
<h1><a class="header" href="#basics-1" id="basics-1">Basics</a></h1>
<blockquote>
<p><strong>NARRATOR:</strong> This section has a looming fundamental error in it, because that's the whole point of the book. However once we start using <code>unsafe</code> it's possible to do things wrong and still have everything compile and <em>seemingly</em> work. The fundamental mistake will be identified in the next section. Don't actually use the contents of this section in production code!</p>
</blockquote>
<p>Alright, back to basics. How do we construct our list?</p>
<p>Before we just did:</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; List&lt;T&gt; {
    pub fn new() -&gt; Self {
        List { head: None, tail: None }
    }
}
</code></pre>
<p>But we're not using Option for the <code>tail</code> anymore:</p>
<pre><code class="language-text">&gt; cargo build

error[E0308]: mismatched types
  --&gt; src/fifth.rs:15:34
   |
15 |         List { head: None, tail: None }
   |                                  ^^^^ expected *-ptr, found 
   |                                       enum `std::option::Option`
   |
   = note: expected type `*mut fifth::Node&lt;T&gt;`
              found type `std::option::Option&lt;_&gt;`
</code></pre>
<p>We <em>could</em> use an Option, but unlike Box, <code>*mut</code> <em>is</em> nullable. This means it
can't benefit from the null pointer optimization. Instead, we'll be using <code>null</code>
to represent None.</p>
<p>So how do we get a null pointer? There's a few ways, but I prefer to use
<code>std::ptr::null_mut()</code>. If you want, you can also use <code>0 as *mut _</code>, but that
just seems so <em>messy</em>.</p>
<pre><code class="language-rust ignore">use std::ptr;

// defns...

impl&lt;T&gt; List&lt;T&gt; {
    pub fn new() -&gt; Self {
        List { head: None, tail: ptr::null_mut() }
    }
}
</code></pre>
<pre><code class="language-text">cargo build

warning: field is never used: `head`
 --&gt; src/fifth.rs:4:5
  |
4 |     head: Link&lt;T&gt;,
  |     ^^^^^^^^^^^^^
  |
  = note: #[warn(dead_code)] on by default

warning: field is never used: `tail`
 --&gt; src/fifth.rs:5:5
  |
5 |     tail: *mut Node&lt;T&gt;,
  |     ^^^^^^^^^^^^^^^^^^

warning: field is never used: `elem`
  --&gt; src/fifth.rs:11:5
   |
11 |     elem: T,
   |     ^^^^^^^

warning: field is never used: `head`
  --&gt; src/fifth.rs:12:5
   |
12 |     head: Link&lt;T&gt;,
   |     ^^^^^^^^^^^^^
</code></pre>
<p><em>shush</em> compiler, we will use them soon.</p>
<p>Alright, let's move on to writing <code>push</code> again. This time, instead of grabbing
an <code>Option&lt;&amp;mut Node&lt;T&gt;&gt;</code> after we insert, we're just going to grab a
<code>*mut Node&lt;T&gt;</code> to the insides of the Box right away. We know we can soundly do
this because the contents of a Box has a stable address, even if we move the
Box around. Of course, this isn't <em>safe</em>, because if we just drop the Box we'll
have a pointer to freed memory.</p>
<p>How do we make a raw pointer from a normal pointer? Coercions! If a variable
is declared to be a raw pointer, a normal reference will coerce into it:</p>
<pre><code class="language-rust ignore">let raw_tail: *mut _ = &amp;mut *new_tail;
</code></pre>
<p>We have all the info we need. We can translate our code into, approximately,
the previous reference version:</p>
<pre><code class="language-rust ignore">pub fn push(&amp;mut self, elem: T) {
    let mut new_tail = Box::new(Node {
        elem: elem,
        next: None,
    });

    let raw_tail: *mut _ = &amp;mut *new_tail;

    // .is_null checks for null, equivalent to checking for None
    if !self.tail.is_null() {
        // If the old tail existed, update it to point to the new tail
        self.tail.next = Some(new_tail);
    } else {
        // Otherwise, update the head to point to it
        self.head = Some(new_tail);
    }

    self.tail = raw_tail;
}
</code></pre>
<pre><code class="language-text">&gt; cargo build

error[E0609]: no field `next` on type `*mut fifth::Node&lt;T&gt;`
  --&gt; src/fifth.rs:31:23
   |
31 |             self.tail.next = Some(new_tail);
   |             ----------^^^^
   |             |
   |             help: `self.tail` is a raw pointer; 
   |             try dereferencing it: `(*self.tail).next`
</code></pre>
<p>Huh? We have a pointer to a Node, why can't we get the <code>next</code> field?</p>
<p>Rust is kinda a jerk when you use raw pointers. To access the contents of a
raw pointer, it insists that we manually deref them, because it's such an unsafe
operation. So let's do that:</p>
<pre><code class="language-rust ignore">*self.tail.next = Some(new_tail);
</code></pre>
<pre><code class="language-text">&gt; cargo build

error[E0609]: no field `next` on type `*mut fifth::Node&lt;T&gt;`
  --&gt; src/fifth.rs:31:23
   |
31 |             *self.tail.next = Some(new_tail);
   |             -----------^^^^
   |             |
   |             help: `self.tail` is a raw pointer; 
   |             try dereferencing it: `(*self.tail).next`
</code></pre>
<p>Uuuugh operator precedence.</p>
<pre><code class="language-rust ignore">(*self.tail).next = Some(new_tail);
</code></pre>
<pre><code class="language-text">&gt; cargo build

error[E0133]: dereference of raw pointer is unsafe and requires 
              unsafe function or block

  --&gt; src/fifth.rs:31:13
   |
31 |             (*self.tail).next = Some(new_tail);
   |             ^^^^^^^^^^^^^^^^^ dereference of raw pointer
   |
   = note: raw pointers may be NULL, dangling or unaligned; 
     they can violate aliasing rules and cause data races: 
     all of these are undefined behavior
</code></pre>
<p>THIS. SHOULDN'T. BE. THIS. HARD.</p>
<p>Remember how I said Unsafe Rust is like an FFI language for Safe Rust? Well, the
compiler wants us to explicitly delimit where we're doing this FFI-ing. We have
two options. First, we can mark our <em>entire</em> function as unsafe, in which case
it becomes an Unsafe Rust function and can only be called in an <code>unsafe</code>
context. This isn't great, because we want our list to be safe to use. Second,
we can write an <code>unsafe</code> block inside our function, to delimit the FFI boundary.
This declares the overall function to be safe. Let's do that one:</p>
<pre><code class="language-rust ignore">pub fn push(&amp;mut self, elem: T) {
    let mut new_tail = Box::new(Node {
        elem: elem,
        next: None,
    });

    let raw_tail: *mut _ = &amp;mut *new_tail;

    if !self.tail.is_null() {
        // Hello Compiler, I Know I Am Doing Something Dangerous And
        // I Promise To Be A Good Programmer Who Never Makes Mistakes.
        unsafe {
            (*self.tail).next = Some(new_tail);
        }
    } else {
        self.head = Some(new_tail);
    }

    self.tail = raw_tail;
}
</code></pre>
<pre><code class="language-text">&gt; cargo build
warning: field is never used: `elem`
  --&gt; src/fifth.rs:11:5
   |
11 |     elem: T,
   |     ^^^^^^^
   |
   = note: #[warn(dead_code)] on by default
</code></pre>
<p>Yay!</p>
<p>It's kind've interesting that that's the <em>only</em> place we've had to write an
unsafe block so far. We do raw pointer stuff all over the place, what's up with
that?</p>
<p>It turns out that Rust is a massive rules-lawyer pedant when it comes to
<code>unsafe</code>. We quite reasonably want to maximize the set of Safe Rust programs,
because those are programs we can be much more confident in. To accomplish this,
Rust carefully carves out a minimal surface area for unsafety. Note that all
the other places we've worked with raw pointers has been <em>assigning</em> them, or
just observing whether they're null or not.</p>
<p>If you never actually dereference a raw pointer <em>those are totally safe things
to do</em>. You're just reading and writing an integer! The only time you can
actually get into trouble with a raw pointer is if you actually dereference it.
So Rust says <em>only</em> that operation is unsafe, and everything else is totally
safe.</p>
<p>Super. Pedantic. But technically correct.</p>
<blockquote>
<p><strong>NARRATOR:</strong> Somewhere on the other side of the world, a hardware engineer
feels a shiver down her spine — someone must be insisting pointers
are just integers again. She looks down at her proposal for a new hardware
pointer authentication scheme and sheds a single tear. The compiler engineer
next door feels nothing — they long ago learned to always wear a heavy
sweater.</p>
</blockquote>
<p>Having only some of the pointer operations be <em>actually</em> unsafe raises an
interesting problem: although we're supposed to delimit the scope of the
unsafety with the <code>unsafe</code> block, it actually depends on state that was
established outside of the block. Outside of the function, even!</p>
<p>This is what I call unsafe <em>taint</em>. As soon as you use <code>unsafe</code> in a module,
that whole module is tainted with unsafety. Everything has to be correctly
written in order to make sure all invariants are upheld for the unsafe code.</p>
<p>This taint is manageable because of <em>privacy</em>. Outside of our module, all of our
struct fields are totally private, so no one else can mess with our state in
arbitrary ways. As long as no combination of the APIs we expose causes bad stuff
to happen, as far as an outside observer is concerned, all of our code is safe!
And really, this is no different from the FFI case. No one needs to care
if some python math library shells out to C as long as it exposes a safe
interface.</p>
<p>Anyway, let's move on to <code>pop</code>, which is pretty much verbatim the reference
version:</p>
<pre><code class="language-rust ignore">pub fn pop(&amp;mut self) -&gt; Option&lt;T&gt; {
    self.head.take().map(|head| {
        let head = *head;
        self.head = head.next;

        if self.head.is_none() {
            self.tail = ptr::null_mut();
        }

        head.elem
    })
}
</code></pre>
<p>Again we see another case where safety is stateful. If we fail to null out the
tail pointer in <em>this</em> function, we'll see no problems at all. However
subsequent calls to <code>push</code> will start writing to the dangling tail!</p>
<p>Let's test it out:</p>
<pre><code class="language-rust ignore">#[cfg(test)]
mod test {
    use super::List;
    #[test]
    fn basics() {
        let mut list = List::new();

        // Check empty list behaves right
        assert_eq!(list.pop(), None);

        // Populate list
        list.push(1);
        list.push(2);
        list.push(3);

        // Check normal removal
        assert_eq!(list.pop(), Some(1));
        assert_eq!(list.pop(), Some(2));

        // Push some more just to make sure nothing's corrupted
        list.push(4);
        list.push(5);

        // Check normal removal
        assert_eq!(list.pop(), Some(3));
        assert_eq!(list.pop(), Some(4));

        // Check exhaustion
        assert_eq!(list.pop(), Some(5));
        assert_eq!(list.pop(), None);

        // Check the exhaustion case fixed the pointer right
        list.push(6);
        list.push(7);

        // Check normal removal
        assert_eq!(list.pop(), Some(6));
        assert_eq!(list.pop(), Some(7));
        assert_eq!(list.pop(), None);
    }
}
</code></pre>
<p>This is just the stack test, but with the expected <code>pop</code> results flipped around.
I also added some extra steps at the end to make sure that tail-pointer
corruption case in <code>pop</code> doesn't occur.</p>
<pre><code class="language-text">cargo test

running 12 tests
test fifth::test::basics ... ok
test first::test::basics ... ok
test fourth::test::basics ... ok
test fourth::test::peek ... ok
test second::test::basics ... ok
test fourth::test::into_iter ... ok
test second::test::into_iter ... ok
test second::test::iter ... ok
test second::test::iter_mut ... ok
test second::test::peek ... ok
test third::test::basics ... ok
test third::test::iter ... ok

test result: ok. 12 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Gold Star!</p>
<blockquote>
<p><strong>NARRATOR:</strong> Here it comes...</p>
</blockquote>
<h1><a class="header" href="#miri" id="miri">Miri</a></h1>
<p><em>nervously laughs</em> This unsafe stuff is so easy, I don't know why everyone says otherwise. Our program works perfectly.</p>
<blockquote>
<p><strong>NARRATOR:</strong> 🙂</p>
</blockquote>
<p>...right?</p>
<blockquote>
<p><strong>NARRATOR:</strong> 🙂</p>
</blockquote>
<p>Well, we're writing <code>unsafe</code> code now, so the compiler can't help us catch mistakes as well. It could be that the tests <em>happened</em> to work, but were actually doing something non-deterministic. Something Undefined Behavioury.</p>
<p>But what can we do? We've pried open the windows and snuck out of rustc's classroom. No one can help us now.</p>
<p>...Wait, who's that sketchy looking person in the alleyway?</p>
<p><em>&quot;Hey kid, you wanna interpret some Rust code?&quot;</em></p>
<p>Wh- no? Why,</p>
<p><em>&quot;It's wild man, it can validate that the actual dynamic execution of your program conforms to the semantics of Rust's memory model. Blows your mind...&quot;</em></p>
<p>What?</p>
<p><em>&quot;It checks if you Do An Undefined Behaviour.&quot;</em></p>
<p>I guess I could try interpretters just <em>once</em>.</p>
<p><em>&quot;You've got rustup installed right?&quot;</em></p>
<p>Of course I do, it's <em>the</em> tool for having an up to date Rust toolchain!</p>
<pre><code class="language-text">&gt; rustup +nightly-2022-01-21 component add miri

info: syncing channel updates for 'nightly-2022-01-21-x86_64-pc-windows-msvc'
info: latest update on 2022-01-21, rust version 1.60.0-nightly (777bb86bc 2022-01-20)
info: downloading component 'cargo'
info: downloading component 'clippy'
info: downloading component 'rust-docs'
info: downloading component 'rust-std'
info: downloading component 'rustc'
info: downloading component 'rustfmt'
info: installing component 'cargo'
info: installing component 'clippy'
info: installing component 'rust-docs'
info: installing component 'rust-std'
info: installing component 'rustc'
info: installing component 'rustfmt'
info: downloading component 'miri'
info: installing component 'miri'
</code></pre>
<p>What did you just install on my computer!?</p>
<p><em>&quot;The Good Stuff&quot;</em></p>
<blockquote>
<p><strong>NARRATOR:</strong> Some weird stuff going on with toolchain versions:</p>
<p>The tool we're installing, <code>miri</code>, works closely with rustc's internals, 
so it's only available for nightly toolchains.</p>
<p><code>+nightly-2022-01-21</code> tells <code>rustup</code> we want to install miri with the rust 
nightly toolchain for that date. I'm giving a specific date because sometimes
miri falls behind and can't be built for a few nightlies. rustup will
automatically download whatever toolchain we specify with <code>+</code> if we don't
have it installed yet.</p>
<p>2022-01-21 is just a nightly I know has miri support, which you can check 
<a href="https://rust-lang.github.io/rustup-components-history/">on this status page</a>.
You can just use <code>+nightly</code> if you're feeling lucky.</p>
<p>Whenever we invoke miri via <code>cargo miri</code> we will also use this <code>+</code> syntax to
specify the toolchain we installed miri on. If you don't want to have to
specify it every time, you can use <a href="https://rust-lang.github.io/rustup/overrides.html"><code>rustup override set</code></a>.</p>
</blockquote>
<pre><code class="language-text">&gt; cargo +nightly-2022-01-21 miri test

I will run `&quot;cargo.exe&quot; &quot;install&quot; &quot;xargo&quot;` to install
a recent enough xargo. Proceed? [Y/n]
</code></pre>
<p>UH WHAT ON EARTH IS XARGO?</p>
<p><em>&quot;It's fine, don't worry about it.&quot;</em></p>
<pre><code class="language-text">&gt; y

    Updating crates.io index
  Installing xargo v0.3.24
...
    Finished release [optimized] target(s) in 10.65s
  Installing C:\Users\ninte\.cargo\bin\xargo-check.exe
  Installing C:\Users\ninte\.cargo\bin\xargo.exe
   Installed package `xargo v0.3.24` (executables `xargo-check.exe`, `xargo.exe`)

I will run `&quot;rustup&quot; &quot;component&quot; &quot;add&quot; &quot;rust-src&quot;` to install 
the `rust-src` component for the selected toolchain. Proceed? [Y/n]
</code></pre>
<p>UH???</p>
<p><em>&quot;Who doesn't love having a copy of Rust's source code?&quot;</em></p>
<pre><code class="language-text">&gt; y

info: downloading component 'rust-src'
info: installing component 'rust-src'
</code></pre>
<p><em>&quot;Aw yeah it's ready, here's the good part.&quot;</em></p>
<pre><code class="language-text">   Compiling lists v0.1.0 (C:\Users\ninte\dev\tmp\lists)
    Finished test [unoptimized + debuginfo] target(s) in 0.25s
     Running unittests (lists-5cc11d9ee5c3e924.exe)

error: Undefined Behavior: trying to reborrow for Unique at alloc84055, 
       but parent tag &lt;209678&gt; does not have an appropriate item in 
       the borrow stack

   --&gt; \lib\rustlib\src\rust\library\core\src\option.rs:846:18
    |
846 |             Some(x) =&gt; Some(f(x)),
    |                  ^ trying to reborrow for Unique at alloc84055, 
    |                    but parent tag &lt;209678&gt; does not have an 
    |                    appropriate item in the borrow stack
    |
    = help: this indicates a potential bug in the program: 
      it performed an invalid operation, but the rules it 
      violated are still experimental
    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md 
      for further information

    = note: inside `std::option::Option::&lt;std::boxed::Box&lt;fifth::Node&lt;i32&gt;&gt;&gt;::map::&lt;i32, [closure@src\fifth.rs:31:30: 40:10]&gt;` at \lib\rustlib\src\rust\library\core\src\option.rs:846:18

note: inside `fifth::List::&lt;i32&gt;::pop` at src\fifth.rs:31:9
   --&gt; src\fifth.rs:31:9
    |
31  | /         self.head.take().map(|head| {
32  | |             let head = *head;
33  | |             self.head = head.next;
34  | |
...   |
39  | |             head.elem
40  | |         })
    | |__________^
note: inside `fifth::test::basics` at src\fifth.rs:74:20
   --&gt; src\fifth.rs:74:20
    |
74  |         assert_eq!(list.pop(), Some(1));
    |                    ^^^^^^^^^^
note: inside closure at src\fifth.rs:62:5
   --&gt; src\fifth.rs:62:5
    |
61  |       #[test]
    |       ------- in this procedural macro expansion
62  | /     fn basics() {
63  | |         let mut list = List::new();
64  | |
65  | |         // Check empty list behaves right
...   |
96  | |         assert_eq!(list.pop(), None);
97  | |     }
    | |_____^
 ...
error: aborting due to previous error
</code></pre>
<p>Woah. That's one heck of an error.</p>
<p><em>&quot;Yeah, look at that shit. You love to see it.&quot;</em></p>
<p>Thank you?</p>
<p><em>&quot;Here take the bottle of estradiol too, you're gonna need it later.&quot;</em></p>
<p>Wait why?</p>
<p><em>&quot;You're about to think about memory models, trust me.&quot;</em></p>
<blockquote>
<p><strong>NARRATOR:</strong> The mysterious person then proceeded to transform into a fox and scampered through a hole in the wall. The author then stared into the middle distance for several minutes while they tried to process everything that just happened.</p>
</blockquote>
<hr />
<p>The mysterious fox in the alleyway was right about more than just my gender: miri really is The Good Shit.</p>
<p>Ok so what <em>is</em> <a href="https://github.com/rust-lang/miri">miri</a>?</p>
<blockquote>
<p>An experimental interpreter for Rust's mid-level intermediate representation (MIR). It can run binaries and test suites of cargo projects and detect certain classes of undefined behavior, for example:</p>
<ul>
<li>Out-of-bounds memory accesses and use-after-free</li>
<li>Invalid use of uninitialized data</li>
<li>Violation of intrinsic preconditions (an unreachable_unchecked being reached, calling copy_nonoverlapping with overlapping ranges, ...)</li>
<li>Not sufficiently aligned memory accesses and references</li>
<li>Violation of some basic type invariants (a bool that is not 0 or 1, for example, or an invalid enum discriminant)</li>
<li>Experimental: Violations of the Stacked Borrows rules governing aliasing for reference types</li>
<li>Experimental: Data races (but no weak memory effects)</li>
</ul>
<p>On top of that, Miri will also tell you about memory leaks: when there is memory still allocated at the end of the execution, and that memory is not reachable from a global static, Miri will raise an error.</p>
<p>...</p>
<p>However, be aware that Miri will not catch all cases of undefined behavior in your program, and cannot run all programs</p>
</blockquote>
<p>TL;DR: it interprets your program and notices if you break the rules <em>at runtime</em> and Do An Undefined Behaviour. This is necessary because Undefined Behaviour is <em>generally</em> a thing that happens at runtime. If the issue could be found at compile time, the compiler would just make it an error!</p>
<p>If you're familiar with tools like ubsan and tsan: it's basically that but all together and more extreme.</p>
<hr />
<p>Miri is now hanging outside the classroom window with a knife. A learning knife.</p>
<p>If we ever want miri to check our work, we can ask them to interpret our test suite with</p>
<pre><code class="language-text">&gt; cargo +nightly-2022-01-21 miri test
</code></pre>
<p>Now let's take a closer look at what they carved into our desk:</p>
<pre><code class="language-text">error: Undefined Behavior: trying to reborrow for Unique at alloc84055, but parent tag &lt;209678&gt; does not have an appropriate item in the borrow stack

   --&gt; \lib\rustlib\src\rust\library\core\src\option.rs:846:18
    |
846 |             Some(x) =&gt; Some(f(x)),
    |                  ^ trying to reborrow for Unique at alloc84055, 
    |                    but parent tag &lt;209678&gt; does not have an 
    |                    appropriate item in the borrow stack
    |

    = help: this indicates a potential bug in the program: it 
      performed an invalid operation, but the rules it 
      violated are still experimental
    
    = help: see 
      https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md 
      for further information
</code></pre>
<p>Well I can see we made an error, but that's a confusing error message. What's the &quot;borrow stack&quot;?</p>
<p>We'll try to figure that out in the next section.</p>
<h1><a class="header" href="#attempting-to-understand-stacked-borrows" id="attempting-to-understand-stacked-borrows">Attempting To Understand Stacked Borrows</a></h1>
<p>In the previous section we tried running our unsafe singly-linked queue under miri, and it said we had broken the rules of <em>stacked borrows</em>, and linked us some documentation.</p>
<p>Normally I'd give a guided tour of the docs, but we're not really the target audience of that documentation. It's more designed for compiler developers and academics who are working on the semantics of Rust. </p>
<p>So I'm going to just give you the high level <em>idea</em> of &quot;stacked borrows&quot;, and then give you a simple strategy for following the rules.</p>
<blockquote>
<p><strong>NARRATOR:</strong> Stacked borrows are still &quot;experimental&quot; as a semantic model for Rust, so breaking these rules may not actually mean your program is &quot;wrong&quot;. But unless you literally work on the compiler, you should just fix your program when miri complains. Better safe than sorry when it comes to Undefined Behaviour.</p>
</blockquote>
<h1><a class="header" href="#the-motivation-pointer-aliasing" id="the-motivation-pointer-aliasing">The Motivation: Pointer Aliasing</a></h1>
<p>Before we get into <em>what</em> rules we've broken, it will help to understand <em>why</em> the rules exist in the first place. There are a few different motivating problems, but I think the most important one is <em>pointer aliasing</em>.</p>
<p>We say two pointers <em>alias</em> when the pieces of memory they point to overlap. Just as someone who &quot;goes by an alias&quot; can be referred to by two different names, that overlapping piece of memory can be referred to by two different pointers. This can lead to problems.</p>
<p>The compiler uses information about pointer aliasing to optimize accesses to memory, so if the information it has is <em>wrong</em> then the program will be miscompiled and do random garbage. </p>
<blockquote>
<p><strong>NARRATOR:</strong> Practically speaking, aliasing is more concerned with memory accesses than the pointers themselves, and only really matters when one of the accesses is mutating. Pointers are emphasized because they're a convenient thing to attach rules to.</p>
</blockquote>
<p>To understand why pointer aliasing information is important, let's consider <em>The Parable of the Tiny Angry Man</em>. </p>
<hr />
<p>Michiel was looking through their bookshelf one day when they saw a book they didn't remember. They pulled it from the bookcase and looked at the cover. </p>
<p>&quot;Oh yes, my old copy of <em>War and Peace</em>, a book I definitely have read. I loved the part with all the Peace.&quot;</p>
<p>Suddenly there was a knock at the door. Michiel returned the book to its shelf and opened the door -- it was their sworn nemesis <strong>Hamslaw</strong>. As Hamslaw prepared a devastating remark about Michiel's clearly inferior codegolfing skills, they sensed an opening: </p>
<p>&quot;Hey Hamslaw, have you ever read War and Peace?&quot;</p>
<p>&quot;Pfft, no one's <em>actually</em> read War and Peace.&quot;</p>
<p>&quot;Well I have, look it's right there in my bookcase, which <em>obviously</em> means I've read it.&quot;</p>
<p>Hamslaw couldn't believe it. Her face shifted from its usual smug demeanor to an iron mask of rage and determination. Hamslaw pushed Michiel aside and power-walked to the book shelf, cleaving the tome from its resting place with the fury of a thousand Valkyries. She turned the ancient text over in her hands, and the instant she saw the cover she began to shake.</p>
<p>Michiel prepared to boast of their clearly unparalleled brilliance, but was interrupted by the sudden laughter of Hamslaw.</p>
<p>&quot;This isn't War and Peace, this is War and <em>Feet</em>!&quot;</p>
<p>Tears were rolling down Hamslaw's face. This was clearly the greatest moment of her life.</p>
<p>&quot;N-no! I just looked at it!&quot;</p>
<p>They grabbed the book from Hamslaw and checked the cover. Indeed, the word &quot;Peace&quot; had been scratched out and replaced with &quot;Feet&quot;. Michiel was mortified. This was clearly the worst moment of their life.</p>
<p>They fell to their knees and stared blankly at the bookcase. How could this have happened? They had checked the cover only a moment ago!</p>
<p>And then they saw a bit of motion in the bookcase. It was a tiny man. A tiny many with the angriest scowl Michiel had ever seen. The tiny man flipped Michiel off and mouthed the words &quot;no one will believe you&quot; and disappeared back between the books.</p>
<p>Michiel's plan <em>had</em> been perfect, but they had failed to account for the possibility of a tiny angry man with a sharpie and the desire for destruction. They thought they knew what the cover of the book said, and they thought that no one could have possibly changed it. But alas, they were wrong.</p>
<p>Hamslaw was already working on a zine commemorating her incredible victory — Michiel's reputation at the local Internet Cafe would never recover.</p>
<hr />
<p>No one wants to be like Michiel, but no one wants to live in constant fear of the tiny angry man either. We want to know when the tiny angry man could be playing tricks on us. When he is, we will be very careful and paranoid about checking everything before we use it. But when the tiny angry man is gone, we want to be able to remember things.</p>
<p>That's the (very simplified) crux of pointer aliasing: when can the compiler assume it's safe to &quot;remember&quot; (cache) values instead of loading them over and over? To know that, the compiler needs to know whenever there <em>could</em> be little angry men mutating the memory behind your back.</p>
<blockquote>
<p><strong>NARRATOR:</strong> the compiler also uses this information to cache stores, which just means it can avoid committing things to memory if it thinks no one will notice. In this case the problem is still tiny angry men, but they only need to read the memory for it to be a problem.</p>
</blockquote>
<h1><a class="header" href="#safe-stacked-borrows" id="safe-stacked-borrows">Safe Stacked Borrows</a></h1>
<p>Ok so we want the compiler to have good pointer aliasing information, can we do that? Well, seemingly Rust is <em>designed</em> for it. Mutable references aren't aliased by definition, and although shared references <em>can</em> alias eachother, they can't mutate. Perfect! Ship it!</p>
<p>Except it's more complicated than that. We can &quot;reborrow&quot; mutable pointers like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut data = 10;
let ref1 = &amp;mut data;
let ref2 = &amp;mut *ref1;

*ref2 += 2;
*ref1 += 1;

println!(&quot;{}&quot;, data);
<span class="boring">}
</span></code></pre></pre>
<p>The compiles and runs fine. What's the deal? </p>
<p>Well we can see what's going on by swapping the two uses:</p>
<pre><code class="language-rust ignore">let mut data = 10;
let ref1 = &amp;mut data;
let ref2 = &amp;mut *ref1;

// ORDER SWAPPED!
*ref1 += 1;
*ref2 += 2;

println!(&quot;{}&quot;, data);
</code></pre>
<pre><code class="language-text">error[E0503]: cannot use `*ref1` because it was mutably borrowed
 --&gt; src/main.rs:6:5
  |
4 |     let ref2 = &amp;mut *ref1;
  |                ---------- borrow of `*ref1` occurs here
5 |     
6 |     *ref1 += 1;
  |     ^^^^^^^^^^ use of borrowed `*ref1`
7 |     *ref2 += 2;
  |     ---------- borrow later used here

For more information about this error, try `rustc --explain E0503`.
error: could not compile `playground` due to previous error
</code></pre>
<p>It's suddenly a compiler error!</p>
<p>When we reborrow a mutable pointer, the original pointer can't be used anymore until the borrower is done with it (no more uses). </p>
<p>In the code that works, there's a nice little nesting of the uses. We reborrow the pointer, use the new pointer for a while, and then stop using it before using the older pointer again. In the code that <em>doesn't</em> work, that doesn't happen. We just interleave the uses arbitrarily.</p>
<p>This is how we can have reborrows and still have aliasing information: all of our reborrows clearly nest, so we can consider only one of them &quot;live&quot; at any given time.</p>
<p>Hey, you know what's a great way to represent cleanly nested things? A stack. A stack of borrows.</p>
<p>Oh hey it's <em>Stacked Borrows</em>!</p>
<p>Whatever's at the top of the borrow stack is &quot;live&quot; and knows it's effectively unaliased. When you reborrow a pointer, the new pointer is pushed onto the stack, becoming <em>the</em> live pointer. When you use an older pointer it's brought back to life by popping everything on the borrow stack above it. At this point the pointer &quot;knows&quot; it was reborrowed and that the memory might have been modified, but that it once more has exclusive access -- no need to worry about little angry men.</p>
<p>So it's actually <em>always</em> ok to access a reborrowed pointer, because we can always pop everything above it. The real trouble is accessing a pointer that has already been popped off of the borrow stack -- then you've messed up.</p>
<p>Thankfully the design of the borrowchecker ensures that safe Rust programs follow these rules, as we saw in the above example, but the compiler generally views this problem &quot;backwards&quot; from the stacked borrows perspective. Instead of saying using <code>ref1</code> invalidates <code>ref2</code>, it insists that <code>ref2</code> <em>must</em> be valid for all its uses, and that <code>ref1</code> is the one messing things up by going out of turn.</p>
<p>Hence &quot;cannot use <code>*ref1</code> because it was mutably borrowed&quot;. It's the same result (especially with non-lexical lifetimes), but framed in a way that's probably more intuitive.</p>
<p>But the borrowchecker can't help us when we start using unsafe pointers!</p>
<h1><a class="header" href="#unsafe-stacked-borrows" id="unsafe-stacked-borrows">Unsafe Stacked Borrows</a></h1>
<p>So we want to somehow have a way for unsafe pointers to participate in this stacked borrows system, even though the compiler can't track them properly. And we also want the system to be fairly permissive so that it's not <em>too</em> easy to mess it up and cause UB.</p>
<p>That's a hard problem, and I don't know how to solve it, but the folks who worked on Stacked Borrows came up with something plausible, and miri tries to implement it.</p>
<p>The very high-level concept is that when you convert a reference (or any other safe pointer) into an raw pointer it's <em>basically</em> like taking a reborrow. So now the raw pointer is allowed to do whatever it wants with that memory, and when the reborrow expires it's just like when that happens with normal reborrows.</p>
<p>But the question is, when does that reborrow expire? Well, probably a good time to expire it is when you start using the original reference again. Otherwise things aren't a nice nested stack.</p>
<p>But wait, you can turn a raw pointer <em>into</em> a reference! And you can copy raw pointers! What if you go <code>&amp;mut -&gt; *mut -&gt; &amp;mut -&gt; *mut</code> and then access the first <code>*mut</code>? How the heck do the stacked borrows work then?</p>
<p>I genuinely don't know! That's why things are complicated. In fact they're <em>extra</em> complicated because stacked borrows are <em>trying</em> to be more permissive and let more unsafe code work the way you'd expect it to. This is why I run things under miri to try to help me catch mistakes.</p>
<p>In fact, this messiness is why there is an extra-experimental extra-strict mode of miri: <code>-Zmiri-tag-raw-pointers</code>.</p>
<p>To enable it, we need to pass it via a MIRIFLAGS environment variable like this:</p>
<pre><code class="language-text">MIRIFLAGS=&quot;-Zmiri-tag-raw-pointers&quot; cargo +nightly-2022-01-21 miri test
</code></pre>
<p>Or like this on Windows, where you need to just set the variable globally:</p>
<pre><code class="language-text">$env:MIRIFLAGS=&quot;-Zmiri-tag-raw-pointers&quot;
cargo +nightly-2022-01-21 miri test
</code></pre>
<p>We'll generally be trying to conform to this extra-strict mode just to be <em>extra</em> confident in our work. It's also in some sense &quot;simpler&quot;, so it's actually better for messing around and getting an intuition for stacked borrows.</p>
<h1><a class="header" href="#managing-stacked-borrows" id="managing-stacked-borrows">Managing Stacked Borrows</a></h1>
<p>So when using raw pointers we're going to try to stick to a heuristic that's simple and blunt and will hopefully have a large margin of error: </p>
<p><strong>Once you start using raw pointers, try to ONLY use raw pointers.</strong></p>
<p>This makes it as unlikely as possible to accidentally lose the raw pointer's &quot;permission&quot; to access the memory.</p>
<blockquote>
<p><strong>NARRATOR:</strong> this is oversimplified in two regards:</p>
<ol>
<li>
<p>Safe pointers often assert more properties than just aliasing: the memory is allocated, it's aligned, it's large enough to fit the type of the pointee, the pointee is properly initialized, etc. So it's even more dangerous to wildly throw them around when things are in a dubious state.</p>
</li>
<li>
<p>Even if you stay in raw pointer land, you can't just wildly alias any memory. Pointers are conceptually tied to specific &quot;allocations&quot; (which can be as granular as a local variable on the stack), and you're not supposed to take a pointer from one allocation, offset it, and then access memory in a different allocation. If this was allowed, there would <em>always</em> be the threat of tiny angry men <em>everywhere</em>. This is part of the reason &quot;pointers are just integers&quot; is a <em>problematic</em> viewpoint.</p>
</li>
</ol>
</blockquote>
<p>Now, we still want safe references in our <em>interface</em>, because we want to build a nice <em>safe abstraction</em> so the user of our list doesn't have to know or worry about. </p>
<p>So what we're going to do is:</p>
<ol>
<li>At the start of a method, use the input references to get our raw pointers</li>
<li>Do our best to only use unsafe pointers from this point on</li>
<li>Convert our raw pointers back to safe pointers at the end if needed</li>
</ol>
<p>But the fields of our types are private so we're going to keep those <em>entirely</em> as raw pointers.</p>
<p>In fact, part of the big mistake we made was continuing to use Box! Box has a special annotation in it that tells the compiler &quot;hey this is a lot like <code>&amp;mut</code>, because it uniquely owns that pointer&quot;. Which is true!</p>
<p>But the raw pointer we were keeping to the end of the list was pointing into a Box, so whenever we access the Box normally we're probably invalidating that raw pointer's &quot;reborrow&quot;! ☠</p>
<p>In the next section we'll return to our true form and hit our heads against a bunch of examples.</p>
<h1><a class="header" href="#testing-stacked-borrows" id="testing-stacked-borrows">Testing Stacked Borrows</a></h1>
<blockquote>
<p>TL;DR of the previous section's (simplified) memory model for Rust:</p>
<ul>
<li>Rust conceptually handles reborrows by maintaining a &quot;borrow stack&quot;</li>
<li>Only the one on the top of the stack is &quot;live&quot; (has exclusive access)</li>
<li>When you access a lower one it becomes &quot;live&quot; and the ones above it get popped</li>
<li>You're not allowed to use pointers that have been popped from the borrow stack</li>
<li>The borrowchecker ensures safe code code obeys this</li>
<li>Miri theoretically checks that raw pointers obey this at runtime</li>
</ul>
</blockquote>
<p>That was a lot of theory and ideas -- let's move on to the true heart and soul of this book: writing some bad code and getting our tools to scream at us. We're going to go through a <em>ton</em> of examples to try to see if our mental model makes sense, and to try to get an intuitive feel for stacked borrows.</p>
<blockquote>
<p><strong>NARRATOR:</strong> Catching Undefined Behaviour in practice is a hairy business. After all, you're dealing with situations that the compiler literally <em>assumes</em> don't happen.</p>
<p>If you're lucky, things will &quot;seem to work&quot; today, but they'll be a ticking time bomb for a Smarter Compiler or slight change to the code. If you're <em>really</em> lucky things will reliably crash so you can just catch the mistake and fix it. But if you're unlucky, then things will be broken in weird and baffling ways.</p>
<p>Miri tries to work around this by getting rustc's most naive and unoptimized view of the program and tracking extra state as it interprets. As far as &quot;sanitizers&quot; go, this is a fairly deterministic and robust approach but it will never be <em>perfect</em>. You need your test program to actually have an execution with that UB, and for a large enough program it's very easy to introduce all sorts of non-determinism (HashMaps use RNG by default!).</p>
<p>We can never take miri approving of our program's execution as an absolute certain statement there's no UB. It's also possible for miri to <em>think</em> something's UB when it really isn't. But if we have a mental model of how things work, and miri seems to agree with us, that's a good sign that we're on the right track.</p>
</blockquote>
<h1><a class="header" href="#basic-borrows" id="basic-borrows">Basic Borrows</a></h1>
<p>In previous sections we saw that the borrowchecker didn't like this code:</p>
<pre><code class="language-rust ignore">let mut data = 10;
let ref1 = &amp;mut data;
let ref2 = &amp;mut *ref1;

// ORDER SWAPPED!
*ref1 += 1;
*ref2 += 2;

println!(&quot;{}&quot;, data);
</code></pre>
<p>Let's see what happens when we replace <code>ref2</code> with <code>*mut</code>:</p>
<pre><code class="language-rust ignore">unsafe {
    let mut data = 10;
    let ref1 = &amp;mut data;
    let ptr2 = ref1 as *mut _;

    // ORDER SWAPPED!
    *ref1 += 1;
    *ptr2 += 2;

    println!(&quot;{}&quot;, data);
}
</code></pre>
<pre><code class="language-text">cargo run
   Compiling miri-sandbox v0.1.0
    Finished dev [unoptimized + debuginfo] target(s) in 0.71s
     Running `target\debug\miri-sandbox.exe`
13
</code></pre>
<p>Rustc seems perfectly happy with this: no warnings and the program produced the result we expected! Now let's look at what miri (in strict mode) thinks of it: </p>
<pre><code class="language-text">MIRIFLAGS=&quot;-Zmiri-tag-raw-pointers&quot; cargo +nightly-2022-01-21 miri run

    Finished dev [unoptimized + debuginfo] target(s) in 0.00s
     Running cargo-miri.exe target\miri

error: Undefined Behavior: no item granting read access 
to tag &lt;untagged&gt; at alloc748 found in borrow stack.

 --&gt; src\main.rs:9:9
  |
9 |         *ptr2 += 2;
  |         ^^^^^^^^^^ no item granting read access to tag &lt;untagged&gt; 
  |                    at alloc748 found in borrow stack.
  |
  = help: this indicates a potential bug in the program: 
    it performed an invalid operation, but the rules it 
    violated are still experimental
 
</code></pre>
<p>Nice! Our intuitive model of how things work held up: although the compiler couldn't catch the issue for us, miri did.</p>
<p>Let's try something more complicated, the <code>&amp;mut -&gt; *mut -&gt; &amp;mut -&gt; *mut</code> case we alluded to before:</p>
<pre><code class="language-rust ignore">unsafe {
    let mut data = 10;
    let ref1 = &amp;mut data;
    let ptr2 = ref1 as *mut _;
    let ref3 = &amp;mut *ptr2;
    let ptr4 = ref3 as *mut _;

    // Access the first raw pointer first
    *ptr2 += 2;

    // Then access things in &quot;borrow stack&quot; order
    *ptr4 += 4;
    *ref3 += 3;
    *ptr2 += 2;
    *ref1 += 1;

    println!(&quot;{}&quot;, data);
}
</code></pre>
<pre><code class="language-text">cargo run
22

MIRIFLAGS=&quot;-Zmiri-tag-raw-pointers&quot; cargo +nightly-2022-01-21 miri run

error: Undefined Behavior: no item granting read access 
to tag &lt;1621&gt; at alloc748 found in borrow stack.

  --&gt; src\main.rs:13:5
   |
13 |     *ptr4 += 4;
   |     ^^^^^^^^^^ no item granting read access to tag &lt;1621&gt; 
   |                at alloc748 found in borrow stack.
   |
</code></pre>
<p>Wow yep! In strict mode miri can &quot;tell apart&quot; the two raw pointers and have using the second one invalidate the first one. Let's see if everything works when we remove the first use that messes everything up:</p>
<pre><code class="language-rust ignore">unsafe {
    let mut data = 10;
    let ref1 = &amp;mut data;
    let ptr2 = ref1 as *mut _;
    let ref3 = &amp;mut *ptr2;
    let ptr4 = ref3 as *mut _;

    // Access things in &quot;borrow stack&quot; order
    *ptr4 += 4;
    *ref3 += 3;
    *ptr2 += 2;
    *ref1 += 1;

    println!(&quot;{}&quot;, data);
}
</code></pre>
<pre><code class="language-text">cargo run
20

MIRIFLAGS=&quot;-Zmiri-tag-raw-pointers&quot; cargo +nightly-2022-01-21 miri run
20
</code></pre>
<p>NICE.</p>
<p>Yeah I'm pretty sure at this point we can all get PhD's in programming language memory model design and implementation. Who even <em>needs</em> compilers, this stuff is <em>easy</em>.</p>
<blockquote>
<p><strong>NARRATOR:</strong> it was not, but I'm proud of you nonetheless.</p>
</blockquote>
<h1><a class="header" href="#testing-arrays" id="testing-arrays">Testing Arrays</a></h1>
<p>Let's mess with some arrays and pointer offsets (<code>add</code> and <code>sub</code>). This should work, right?</p>
<pre><code class="language-rust ignore">unsafe {
    let mut data = [0; 10];
    let ref1_at_0 = &amp;mut data[0];           // Reference to 0th element
    let ptr2_at_0 = ref1_at_0 as *mut i32;  // Ptr to 0th element
    let ptr3_at_1 = ptr2_at_0.add(1);       // Ptr to 1st element

    *ptr3_at_1 += 3;
    *ptr2_at_0 += 2;
    *ref1_at_0 += 1;

    // Should be [3, 3, 0, ...]
    println!(&quot;{:?}&quot;, &amp;data[..]);
}
</code></pre>
<pre><code class="language-text">cargo run
[3, 3, 0, 0, 0, 0, 0, 0, 0, 0]

MIRIFLAGS=&quot;-Zmiri-tag-raw-pointers&quot; cargo +nightly-2022-01-21 miri run

error: Undefined Behavior: no item granting read access 
to tag &lt;1619&gt; at alloc748+0x4 found in borrow stack.
 --&gt; src\main.rs:8:5
  |
8 |     *ptr3_at_1 += 3;
  |     ^^^^^^^^^^^^^^^ no item granting read access to tag &lt;1619&gt;
  |                     at alloc748+0x4 found in borrow stack.
</code></pre>
<p><em>Rips up gradschool application</em></p>
<p>What happened? We're using the borrow stack perfectly fine! Does something weird happen when we go <code>ptr -&gt; ptr</code>? What if we just copy the pointer so they all go to the same location:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe {
    let mut data = [0; 10];
    let ref1_at_0 = &amp;mut data[0];           // Reference to 0th element
    let ptr2_at_0 = ref1_at_0 as *mut i32;  // Ptr to 0th element
    let ptr3_at_0 = ptr2_at_0;              // Ptr to 0th element

    *ptr3_at_0 += 3;
    *ptr2_at_0 += 2;
    *ref1_at_0 += 1;

    // Should be [6, 0, 0, ...]
    println!(&quot;{:?}&quot;, &amp;data[..]);
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-text">cargo run
[6, 0, 0, 0, 0, 0, 0, 0, 0, 0]

MIRIFLAGS=&quot;-Zmiri-tag-raw-pointers&quot; cargo +nightly-2022-01-21 miri run
[6, 0, 0, 0, 0, 0, 0, 0, 0, 0]
</code></pre>
<p>Nope, that works fine. Maybe we're getting lucky, let's just make a real big mess of pointers:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe {
    let mut data = [0; 10];
    let ref1_at_0 = &amp;mut data[0];            // Reference to 0th element
    let ptr2_at_0 = ref1_at_0 as *mut i32;   // Ptr to 0th element
    let ptr3_at_0 = ptr2_at_0;               // Ptr to 0th element
    let ptr4_at_0 = ptr2_at_0.add(0);        // Ptr to 0th element
    let ptr5_at_0 = ptr3_at_0.add(1).sub(1); // Ptr to 0th element

    // An absolute jumbled hash of ptr usages
    *ptr3_at_0 += 3;
    *ptr2_at_0 += 2;
    *ptr4_at_0 += 4;
    *ptr5_at_0 += 5;
    *ptr3_at_0 += 3;
    *ptr2_at_0 += 2;
    *ref1_at_0 += 1;

    // Should be [20, 0, 0, ...]
    println!(&quot;{:?}&quot;, &amp;data[..]);
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-text">cargo run
[20, 0, 0, 0, 0, 0, 0, 0, 0, 0]

MIRIFLAGS=&quot;-Zmiri-tag-raw-pointers&quot; cargo +nightly-2022-01-21 miri run
[20, 0, 0, 0, 0, 0, 0, 0, 0, 0]
</code></pre>
<p>Nope! Miri is actually <em>way</em> more permissive when it comes to raw pointers that are derived from other raw pointers. They all share the same &quot;borrow&quot; (or miri calls it, a <em>tag</em>).</p>
<p>Once you start using raw pointers they can freely split into their own tiny angry men and mess with themselves. This is ok because the compiler understands that and won't optimize the reads and writes the same it does with references.</p>
<blockquote>
<p><strong>NARRATOR:</strong> If the code is simple enough, the compiler can keep track of all the derived pointers and still optimize things where possible, but it's going to be a lot more brittle than the reasoning it can use for references.</p>
</blockquote>
<p>So what's the <em>real</em> problem?</p>
<p>Even though <code>data</code> is one &quot;allocation&quot; (local variable), <code>ref1_at_0</code> is only borrowing the first element. Rust allows borrows to be broken up so that they only apply to particular parts of the allocation! Let's try it out:</p>
<pre><code class="language-rust ignore">unsafe {
    let mut data = [0; 10];
    let ref1_at_0 = &amp;mut data[0];           // Reference to 0th element
    let ref2_at_1 = &amp;mut data[1];           // Reference to 1th element
    let ptr3_at_0 = ref1_at_0 as *mut i32;  // Ptr to 0th element
    let ptr4_at_1 = ref2_at_1 as *mut i32;   // Ptr to 1th element

    *ptr4_at_1 += 4;
    *ptr3_at_0 += 3;
    *ref2_at_1 += 2;
    *ref1_at_0 += 1;

    // Should be [3, 3, 0, ...]
    println!(&quot;{:?}&quot;, &amp;data[..]);
}
</code></pre>
<pre><code class="language-text">error[E0499]: cannot borrow `data[_]` as mutable more than once at a time
 --&gt; src\main.rs:5:21
  |
4 |     let ref1_at_0 = &amp;mut data[0];           // Reference to 0th element
  |                     ------------ first mutable borrow occurs here
5 |     let ref2_at_1 = &amp;mut data[1];           // Reference to 1th element
  |                     ^^^^^^^^^^^^ second mutable borrow occurs here
6 |     let ptr3_at_0 = ref1_at_0 as *mut i32;  // Ptr to 0th element
  |                     --------- first borrow later used here
  |
  = help: consider using `.split_at_mut(position)` or similar method 
    to obtain two mutable non-overlapping sub-slices
</code></pre>
<p>Shoot! Rust doesn't track array indices to prove these borrows are disjoint, but it does give us <code>split_at_mut</code> to break a slice into multiple parts in a way that is safe to assume works:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe {
    let mut data = [0; 10];

    let slice1 = &amp;mut data[..];
    let (slice2_at_0, slice3_at_1) = slice1.split_at_mut(1); 
    
    let ref4_at_0 = &amp;mut slice2_at_0[0];    // Reference to 0th element
    let ref5_at_1 = &amp;mut slice3_at_1[0];    // Reference to 1th element
    let ptr6_at_0 = ref4_at_0 as *mut i32;  // Ptr to 0th element
    let ptr7_at_1 = ref5_at_1 as *mut i32;  // Ptr to 1th element

    *ptr7_at_1 += 7;
    *ptr6_at_0 += 6;
    *ref5_at_1 += 5;
    *ref4_at_0 += 4;

    // Should be [10, 12, 0, ...]
    println!(&quot;{:?}&quot;, &amp;data[..]);
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-text">cargo run
[10, 12, 0, 0, 0, 0, 0, 0, 0, 0]

MIRIFLAGS=&quot;-Zmiri-tag-raw-pointers&quot; cargo +nightly-2022-01-21 miri run
[10, 12, 0, 0, 0, 0, 0, 0, 0, 0]
</code></pre>
<p>Hey, that works! Slices properly tell the compiler and miri &quot;hey I'm taking a huge loan on all of the memory in my range&quot;, so they know all of the elements can be mutated.</p>
<p>Also note that operations like <code>split_at_mut</code> being allowed tells us that borrows can be less of a <em>stack</em> and more of a <em>tree</em>, because we can break one big borrow into a bunch of disjoint smaller ones, and everything still works.</p>
<p>(I think in the actual stacked borrows model everything's still stacks because the stacks are conceptually tracking permissions for each byte of the program..?)</p>
<p>What if we <em>directly</em> turn a slice into a pointer? Will that pointer have access to the full slice?</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe {
    let mut data = [0; 10];

    let slice1_all = &amp;mut data[..];         // Slice for the entire array
    let ptr2_all = slice1_all.as_mut_ptr(); // Pointer for the entire array
    
    let ptr3_at_0 = ptr2_all;               // Pointer to 0th elem (the same)
    let ptr4_at_1 = ptr2_all.add(1);        // Pointer to 1th elem
    let ref5_at_0 = &amp;mut *ptr3_at_0;        // Reference to 0th elem
    let ref6_at_1 = &amp;mut *ptr4_at_1;        // Reference to 1th elem

    *ref6_at_1 += 6;
    *ref5_at_0 += 5;
    *ptr4_at_1 += 4;
    *ptr3_at_0 += 3;

    // Just for fun, modify all the elements in a loop
    // (Could use any of the raw pointers for this, they share a borrow!)
    for idx in 0..10 {
        *ptr2_all.add(idx) += idx;
    }

    // Safe version of this same code for fun
    for (idx, elem_ref) in slice1_all.iter_mut().enumerate() {
        *elem_ref += idx; 
    }

    // Should be [8, 12, 4, 6, 8, 10, 12, 14, 16, 18]
    println!(&quot;{:?}&quot;, &amp;data[..]);
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-text">cargo run
[8, 12, 4, 6, 8, 10, 12, 14, 16, 18]

MIRIFLAGS=&quot;-Zmiri-tag-raw-pointers&quot; cargo +nightly-2022-01-21 miri run
[8, 12, 4, 6, 8, 10, 12, 14, 16, 18]
</code></pre>
<p>Nice! Pointers aren't just integers: they have a range of memory associated with them, and with Rust we're allowed to narrow that range!</p>
<h1><a class="header" href="#testing-shared-references" id="testing-shared-references">Testing Shared References</a></h1>
<p>In all of these examples I have been very carefully only using mutable references and doing read-modify-write operations (<code>+=</code>) to keep things as simple as possible.</p>
<p>But Rust has shared references that are read-only and can be freely copied, how should those work? Well we've seen that raw pointers can be freely copied and we can handle that by saying they &quot;share&quot; a single borrow. Maybe we think of shared references the same way?</p>
<p>Let's test that out with a function that reads a value (<code>println!</code> can be a little magical with auto-ref/deref stuff, so I'm wrapping it in a function to make sure we're testing what we want to be):</p>
<pre><code class="language-rust ignore">fn opaque_read(val: &amp;i32) {
    println!(&quot;{}&quot;, val);
}

unsafe {
    let mut data = 10;
    let mref1 = &amp;mut data;
    let sref2 = &amp;mref1;
    let sref3 = sref2;
    let sref4 = &amp;*sref2;

    // Random hash of shared reference reads
    opaque_read(sref3);
    opaque_read(sref2);
    opaque_read(sref4);
    opaque_read(sref2);
    opaque_read(sref3);

    *mref1 += 1;

    opaque_read(&amp;data);
}
</code></pre>
<pre><code class="language-text">cargo run

warning: unnecessary `unsafe` block
 --&gt; src\main.rs:6:1
  |
6 | unsafe {
  | ^^^^^^ unnecessary `unsafe` block
  |
  = note: `#[warn(unused_unsafe)]` on by default

warning: `miri-sandbox` (bin &quot;miri-sandbox&quot;) generated 1 warning

10
10
10
10
10
11
</code></pre>
<p>Oh yeah we forgot to do anything with raw pointers, but at least we can see that it's fine for all the shared references to be used interchangeably. Now let's mix in some raw pointers:</p>
<pre><code class="language-rust ignore">fn opaque_read(val: &amp;i32) {
    println!(&quot;{}&quot;, val);
}

unsafe {
    let mut data = 10;
    let mref1 = &amp;mut data;
    let ptr2 = mref1 as *mut i32;
    let sref3 = &amp;mref1;
    let ptr4 = sref3 as *mut i32;

    *ptr4 += 4;
    opaque_read(sref3);
    *ptr2 += 2;
    *mref1 += 1;

    opaque_read(&amp;data);
}
</code></pre>
<pre><code class="language-text">cargo run

error[E0606]: casting `&amp;&amp;mut i32` as `*mut i32` is invalid
  --&gt; src\main.rs:11:16
   |
11 |     let ptr4 = sref3 as *mut i32;
   |                ^^^^^^^^^^^^^^^^^
</code></pre>
<p>Oh whoops, we were actually messing around with <code>&amp; &amp;mut</code> instead of <code>&amp;</code>! Rust is very good at papering over that when it doesn't matter. Let's properly reborrow it with <code>let sref3 = &amp;*mref1</code>:</p>
<pre><code class="language-text">cargo run

error[E0606]: casting `&amp;i32` as `*mut i32` is invalid
  --&gt; src\main.rs:11:16
   |
11 |     let ptr4 = sref3 as *mut i32;
   |                ^^^^^^^^^^^^^^^^^
</code></pre>
<p>Nope, Rust still doesn't like that! You can only cast a shared reference to a <code>*const</code> which can only read. But what if we just... do... this...?</p>
<pre><code class="language-rust ignore">    let ptr4 = sref3 as *const i32 as *mut i32;
</code></pre>
<pre><code class="language-text">cargo run

14
17
</code></pre>
<p>WHAT. OK SURE FINE? Great cast system there Rust. It's almost like the <code>*const</code> is a pretty useless type that only really exists to describe C APIs and to vaguely suggest correct usage (it is, it does). What does miri think?</p>
<pre><code class="language-text">MIRIFLAGS=&quot;-Zmiri-tag-raw-pointers&quot; cargo +nightly-2022-01-21 miri run

error: Undefined Behavior: no item granting write access to 
tag &lt;1621&gt; at alloc742 found in borrow stack.
  --&gt; src\main.rs:13:5
   |
13 |     *ptr4 += 4;
   |     ^^^^^^^^^^ no item granting write access to tag &lt;1621&gt;
   |                at alloc742 found in borrow stack.
</code></pre>
<p>Alas, though we can get around the compiler complaining with a double cast, it doesn't actually make this operation <em>allowed</em>. When we take the shared reference, we're promising not to modify the value. </p>
<p>This is important because that means when the shared borrow is popped off the borrow stack, the mutable pointers below it <em>can</em> assume the memory hasn't changed. There may have been some tiny angry men <em>reading</em> the memory (so writes had to be comitted) but they weren't able to modify it and the mutable pointers can assume the last value they wrote is still there!</p>
<p><strong>Once a shared reference is on the borrow-stack, everything that gets pushed on top of it only has read permissions.</strong></p>
<p>We can however do this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn opaque_read(val: &amp;i32) {
    println!(&quot;{}&quot;, val);
}

unsafe {
    let mut data = 10;
    let mref1 = &amp;mut data;
    let ptr2 = mref1 as *mut i32;
    let sref3 = &amp;*mref1;
    let ptr4 = sref3 as *const i32 as *mut i32;

    opaque_read(&amp;*ptr4);
    opaque_read(sref3);
    *ptr2 += 2;
    *mref1 += 1;

    opaque_read(&amp;data);
}
<span class="boring">}
</span></code></pre></pre>
<p>Note how it was still &quot;fine&quot; to create a mutable raw pointer as long as we only actually read from it!</p>
<pre><code class="language-text">cargo run
10
10
13

MIRIFLAGS=&quot;-Zmiri-tag-raw-pointers&quot; cargo +nightly-2022-01-21 miri run
10
10
13
</code></pre>
<p>And just to be sure, let's check that a shared reference gets popped like normal:</p>
<pre><code class="language-rust ignore">fn opaque_read(val: &amp;i32) {
    println!(&quot;{}&quot;, val);
}

unsafe {
    let mut data = 10;
    let mref1 = &amp;mut data;
    let ptr2 = mref1 as *mut i32;
    let sref3 = &amp;*mref1;

    *ptr2 += 2;
    opaque_read(sref3); // Read in the wrong order?
    *mref1 += 1;

    opaque_read(&amp;data);
}
</code></pre>
<pre><code class="language-text">cargo run
12
13

MIRIFLAGS=&quot;-Zmiri-tag-raw-pointers&quot; cargo +nightly-2022-01-21 miri run

error: Undefined Behavior: trying to reborrow for SharedReadOnly 
at alloc742, but parent tag &lt;1620&gt; does not have an appropriate 
item in the borrow stack

  --&gt; src\main.rs:13:17
   |
13 |     opaque_read(sref3); // Read in the wrong order?
   |                 ^^^^^ trying to reborrow for SharedReadOnly 
   |                       at alloc742, but parent tag &lt;1620&gt; 
   |                       does not have an appropriate item 
   |                       in the borrow stack
   |
</code></pre>
<p>Hey, we even got a slightly different error message about SharedReadOnly instead of some specific tag. That makes sense: once there's <em>any</em> shared references, basically everything else is just a big SharedReadOnly soup so there's no need to distinguish any of them!</p>
<h1><a class="header" href="#testing-interior-mutability" id="testing-interior-mutability">Testing Interior Mutability</a></h1>
<p>Remember that really horrible chapter of the book where we tried to make a linked list with RefCell and Rc and everything was even worse than usual when trying to write this godforsaken linked lists?</p>
<p>We've been insisting shared references can't be used for mutation but that chapter was all about how you could actually mutate through shared references with <em>interior mutability</em>. Let's try the nice and simple <a href="https://doc.rust-lang.org/std/cell/struct.Cell.html">std::cell::Cell</a> type:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cell::Cell;

unsafe {
    let mut data = Cell::new(10);
    let mref1 = &amp;mut data;
    let ptr2 = mref1 as *mut Cell&lt;i32&gt;;
    let sref3 = &amp;*mref1;

    sref3.set(sref3.get() + 3);
    (*ptr2).set((*ptr2).get() + 2);
    mref1.set(mref1.get() + 1);

    println!(&quot;{}&quot;, data.get());
}
<span class="boring">}
</span></code></pre></pre>
<p>Ah, such a beautiful mess. It will be lovely to see miri spit on it.</p>
<pre><code class="language-text">cargo run
16

MIRIFLAGS=&quot;-Zmiri-tag-raw-pointers&quot; cargo +nightly-2022-01-21 miri run
16
</code></pre>
<p>Wait, really? <em>That's</em> fine? Why? How? What even is a <em>Cell</em>?</p>
<p><em>Smashes the padlock on the stdlib</em></p>
<pre><code class="language-rust ignore">pub struct Cell&lt;T: ?Sized&gt; {
    value: UnsafeCell&lt;T&gt;,
}
</code></pre>
<p>What the heck is <code>UnsafeCell</code>?</p>
<p><em>Smashes another padlock just to really show the stdlib we mean business</em></p>
<pre><code class="language-rust ignore">#[lang = &quot;unsafe_cell&quot;]
#[repr(transparent)]
#[repr(no_niche)]
pub struct UnsafeCell&lt;T: ?Sized&gt; {
    value: T,
}
</code></pre>
<p>Oh it's wizard magic. Ok. I guess. <code>#[lang = &quot;unsafe_cell&quot;]</code> is literally just saying UnsafeCell is UnsafeCell. Let's stop breaking locks and check the actual documentation of <a href="https://doc.rust-lang.org/std/cell/struct.UnsafeCell.html">std::cell::UnsafeCell</a>.</p>
<blockquote>
<p>The core primitive for interior mutability in Rust.</p>
<p>If you have a reference <code>&amp;T</code>, then normally in Rust the compiler performs optimizations based on the knowledge that <code>&amp;T</code> points to immutable data. Mutating that data, for example through an alias or by transmuting an <code>&amp;T</code> into an <code>&amp;mut T</code>, is considered undefined behavior. <code>UnsafeCell&lt;T&gt;</code> opts-out of the immutability guarantee for <code>&amp;T</code>: a shared reference <code>&amp;UnsafeCell&lt;T&gt;</code> may point to data that is being mutated. This is called “interior mutability”.</p>
</blockquote>
<p>Oh it <em>really is</em> just wizard magic.</p>
<p>UnsafeCell basically tells the compiler &quot;hey listen, we're gonna get goofy with this memory, don't make any of the usual aliasing assumptions about it&quot;. Like putting up a big &quot;CAUTION: TINY ANGRY MEN CROSSING&quot; sign.</p>
<p>Let's see how adding UnsafeCell makes miri happy:</p>
<pre><code class="language-rust ignore">use std::cell::UnsafeCell;

fn opaque_read(val: &amp;i32) {
    println!(&quot;{}&quot;, val);
}

unsafe {
    let mut data = UnsafeCell::new(10);
    let mref1 = data.get_mut();      // Get a mutable ref to the contents
    let ptr2 = mref1 as *mut i32;
    let sref3 = &amp;*ptr2;

    *ptr2 += 2;
    opaque_read(sref3);
    *mref1 += 1;

    println!(&quot;{}&quot;, *data.get());
}
</code></pre>
<pre><code class="language-text">cargo run
12
13

MIRIFLAGS=&quot;-Zmiri-tag-raw-pointers&quot; cargo +nightly-2022-01-21 miri run

error: Undefined Behavior: trying to reborrow for SharedReadOnly
at alloc748, but parent tag &lt;1629&gt; does not have an appropriate
item in the borrow stack

  --&gt; src\main.rs:15:17
   |
15 |     opaque_read(sref3);
   |                 ^^^^^ trying to reborrow for SharedReadOnly 
   |                       at alloc748, but parent tag &lt;1629&gt; does
   |                       not have an appropriate item in the
   |                       borrow stack
   |

</code></pre>
<p>Wait, what? We spoke the magic words! What am I going to do with all this federally approved ritual-enhancing goat blood?</p>
<p>Well, we did, but then we completely discarded the spell by using <code>get_mut</code> which peeks inside the UnsafeCell and makes a proper <code>&amp;mut i32</code> to it anyway!</p>
<p>Think about it: if the compiler had to assume <code>&amp;mut i32</code> <em>could</em> be looking inside an <code>UnsafeCell</code>, then it would never be able to make any assumptions about aliasing at all! Everything could be full of tiny angry men.</p>
<p>So what we need to do is keep the <code>UnsafeCell</code> in our pointer types so that the compiler understands what we're doing.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cell::UnsafeCell;

fn opaque_read(val: &amp;i32) {
    println!(&quot;{}&quot;, val);
}

unsafe {
    let mut data = UnsafeCell::new(10);
    let mref1 = &amp;mut data;              // Mutable ref to the *outside*
    let ptr2 = mref1.get();             // Get a raw pointer to the insides
    let sref3 = &amp;*mref1;                // Get a shared ref to the *outside*

    *ptr2 += 2;                         // Mutate with the raw pointer
    opaque_read(&amp;*sref3.get());         // Read from the shared ref
    *sref3.get() += 3;                  // Write through the shared ref
    *mref1.get() += 1;                  // Mutate with the mutable ref

    println!(&quot;{}&quot;, *data.get());
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-text">cargo run
12
16

MIRIFLAGS=&quot;-Zmiri-tag-raw-pointers&quot; cargo +nightly-2022-01-21 miri run
12
16
</code></pre>
<p>It works! I won't have to throw out all this blood after all.</p>
<p>Actually, hey wait. We're still being a bit goofy with the order here. We made ptr2 first, and then made sref3 from the mutable pointer. And then we used the raw pointer before the shared pointer. That all seems... wrong.</p>
<p>Actually wait we did that with the Cell example too. HMMM.</p>
<p>We're forced to conclude one of two things:</p>
<ul>
<li>Miri is imperfect and this is actually still UB.</li>
<li>Our simplified model is in fact an oversimplication.</li>
</ul>
<p>I'd put my money on the second one, but just to be safe let's make a version that's definitely airtight in our simplified model of stacked borrows:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cell::UnsafeCell;

fn opaque_read(val: &amp;i32) {
    println!(&quot;{}&quot;, val);
}

unsafe {
    let mut data = UnsafeCell::new(10);
    let mref1 = &amp;mut data;
    // These two are swapped so the borrows are *definitely* totally stacked
    let sref2 = &amp;*mref1;
    // Derive the ptr from the shared ref to be super safe!
    let ptr3 = sref2.get();             

    *ptr3 += 3;
    opaque_read(&amp;*sref2.get());
    *sref2.get() += 2;
    *mref1.get() += 1;

    println!(&quot;{}&quot;, *data.get());
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-text">cargo run
13
16

MIRIFLAGS=&quot;-Zmiri-tag-raw-pointers&quot; cargo +nightly-2022-01-21 miri run
13
16
</code></pre>
<p>Now, one reason why the first implementation we had <em>might</em> actually be correct is because if you <em>really</em> think about it <code>&amp;UnsafeCell&lt;T&gt;</code> really is no different from <code>*mut T</code> as far as aliasing is concerned. You can infinitely copy it and mutate through it!</p>
<p>So in some sense we just created two raw pointers and used them interchangeably like normal. It's <em>a little</em> sketchy that both were derived from the mutable reference, so maybe the second one's creation should still pop the first one off the borrow stack, but that's not really necessary since we're not <em>actually</em> accessing the contents of the mutable reference, just copying its address.</p>
<p>A line like <code>let sref2 = &amp;*mref1</code> is a tricksy thing. <em>Syntactically</em> it looks like we're dereferencing it, but dereferencing on it's own isn't actually a <em>thing</em>? Consider <code>&amp;my_tuple.0</code>: you aren't actually doing anything to <code>my_tuple</code> or <code>.0</code>, you're just using them to refer to a location in memory and putting <code>&amp;</code> in front of it that says &quot;don't load this, just write the address down&quot;. </p>
<p><code>&amp;*</code> is the same thing: the <code>*</code> is just saying &quot;hey let's talk about the location this pointer points to&quot; and the <code>&amp;</code> is just saying &quot;now write that address down&quot;. Which is of course the same value the original pointer had. But the type of the pointer has changed, because, uh, types!</p>
<p>That said, if you do <code>&amp;**</code> then you are in fact loading a value with the first <code>*</code>! <code>*</code> is weird!</p>
<blockquote>
<p><strong>NARRATOR:</strong> No one cares that you know the word &quot;lvalue&quot;, <em>Jonathan</em>. In Rust we call them <em>places</em>, which is totally different and <em>so</em> much cooler?</p>
</blockquote>
<h1><a class="header" href="#testing-box" id="testing-box">Testing Box</a></h1>
<p>Hey remember why we started this extremely long aside? You don't? Weird.</p>
<p>Well it was because we mixed Box and raw pointers. Box is <em>kind of</em> like <code>&amp;mut</code>, because it claims unique ownership of the memory it points to. Let's test that claim out:</p>
<pre><code class="language-rust ignore">unsafe {
    let mut data = Box::new(10);
    let ptr1 = (&amp;mut *data) as *mut i32;

    *data += 10;
    *ptr1 += 1;

    // Should be 21
    println!(&quot;{}&quot;, data);
}
</code></pre>
<pre><code class="language-text">cargo run
21

MIRIFLAGS=&quot;-Zmiri-tag-raw-pointers&quot; cargo +nightly-2022-01-21 miri run

error: Undefined Behavior: no item granting read access 
       to tag &lt;1707&gt; at alloc763 found in borrow stack.

 --&gt; src\main.rs:7:5
  |
7 |     *ptr1 += 1;
  |     ^^^^^^^^^^ no item granting read access to tag &lt;1707&gt; 
  |                at alloc763 found in borrow stack.
  |
</code></pre>
<p>Yep, miri hates that. Let's check that doing things in the right order is ok:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe {
    let mut data = Box::new(10);
    let ptr1 = (&amp;mut *data) as *mut i32;

    *ptr1 += 1;
    *data += 10;

    // Should be 21
    println!(&quot;{}&quot;, data);
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-text">cargo run
21

MIRIFLAGS=&quot;-Zmiri-tag-raw-pointers&quot; cargo +nightly-2022-01-21 miri run
21
</code></pre>
<p>Yep!</p>
<p>Whelp that's all folks, we're finally done talking and thinking about stacked borrows!</p>
<p>...wait how do we solve this problem with Box? Like, sure we can write toy programs like this but we need to store the Box somewhere and hold onto our raw pointers for a potentially long time. Surely stuff will get mixed up and invalidated?</p>
<p>Great question! To answer that we'll finally be returning to our true calling: writing some god damn linked lists.</p>
<p>Wait, I need to write linked lists again? Let's not be hasty folks. Be reasonable. Just hold on I'm sure there's some other interesting issues for me to discu—</p>
<h1><a class="header" href="#layout-and-basics-2-getting-raw" id="layout-and-basics-2-getting-raw">Layout and Basics 2: Getting Raw</a></h1>
<blockquote>
<p>TL;DR on the previous three sections: randomly mixing safe pointers like <code>&amp;</code>, <code>&amp;mut</code>, and <code>Box</code> with unsafe pointers like <code>*mut</code> and <code>*const</code> is a recipe for Undefined Behaviour because the safe pointers introduce extra constraints that we aren't obeying with the raw pointers.</p>
</blockquote>
<p>Oh god I need to write linked lists again. Fine. FINE. It's Fine. We're fine.</p>
<p>We're gonna knock a lot of this section out real quick since we already discussed the design in the first try around, and everything we did <em>was</em> basically correct except for how we mixed together safe and unsafe pointers.</p>
<h1><a class="header" href="#layout-3" id="layout-3">Layout</a></h1>
<p>So in the new layout we're only going to only use raw pointers and everything will be perfect and we'll never make mistakes again.</p>
<p>Here's our old broken layout:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct List&lt;T&gt; {
    head: Link&lt;T&gt;,
    tail: *mut Node&lt;T&gt;, // INNOCENT AND KIND
}

type Link&lt;T&gt; = Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;; // THE REAL EVIL

struct Node&lt;T&gt; {
    elem: T,
    next: Link&lt;T&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>And here's our new layout:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct List&lt;T&gt; {
    head: Link&lt;T&gt;,
    tail: *mut Node&lt;T&gt;,
}

type Link&lt;T&gt; = *mut Node&lt;T&gt;; // MUCH BETTER

struct Node&lt;T&gt; {
    elem: T,
    next: Link&lt;T&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>Remember: Option isn't as nice or useful when we're using raw pointers, so we're not using that anymore. In later sections we'll look at the <code>NonNull</code> type, but don't worry about that for now.</p>
<h1><a class="header" href="#basics-2" id="basics-2">Basics</a></h1>
<p>List::new is basically the same.</p>
<pre><code class="language-rust ignore">use ptr;

impl&lt;T&gt; List&lt;T&gt; {
    pub fn new() -&gt; Self {
        List { head: ptr::null_mut(), tail: ptr::null_mut() }
    }
}
</code></pre>
<p>Push is basically the s-</p>
<pre><code class="language-rust ignore">pub fn push(&amp;mut self, elem: T) {
    let mut new_tail = Box::new(
</code></pre>
<p>Wait we're not using Box anymore. How do we allocate memory without Box?</p>
<p>Well, we <em>could</em> with <code>std::alloc::alloc</code>, but that's like bringing a katana into the kitchen. It'll get the job done but it's kinda overkill and unwieldy.</p>
<p>We want to <em>have</em> boxes, but, <em>not</em>. One completely wild but <em>maybe</em> viable option would be to do something like this:</p>
<pre><code>struct Node&lt;T&gt; {
    elem: T,
    real_next: Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;,
    next: *mut Node&lt;T&gt;,
}
</code></pre>
<p>With the idea that we create the Boxes and store them in our node, but then we take a raw pointer into them and only use that raw pointer until we're done with the Node and want to destroy it. Then we can <code>take</code> the Box out of <code>real_next</code> and drop it. I <em>think</em> that would conform to our very simplified stacked borrows model? </p>
<p>If you wanna try to make that, have &quot;fun&quot;, but that just looks awful right? This isn't the chapter on Rc and RefCell, we're not gonna play this <em>game</em> anymore. We're gonna just make simple and clean stuff.</p>
<p>So instead we're going to use the very nice <a href="https://doc.rust-lang.org/std/boxed/struct.Box.html#method.into_raw">Box::into_raw</a> function:</p>
<blockquote>
<pre><code class="language-rust ignore">  pub fn into_raw(b: Box&lt;T&gt;) -&gt; *mut T
</code></pre>
<p>Consumes the Box, returning a wrapped raw pointer.</p>
<p>The pointer will be properly aligned and non-null.</p>
<p>After calling this function, the caller is responsible for the memory previously managed by the Box. In particular, the caller should properly destroy T and release the memory, taking into account the memory layout used by Box. The easiest way to do this is to convert the raw pointer back into a Box with the <code>Box::from_raw</code> function, allowing the Box destructor to perform the cleanup.</p>
<p>Note: this is an associated function, which means that you have to call it as <code>Box::into_raw(b)</code> instead of <code>b.into_raw()</code>. This is so that there is no conflict with a method on the inner type.</p>
<p><strong>Examples</strong></p>
<p>Converting the raw pointer back into a Box with Box::from_raw for automatic cleanup:</p>
<pre><code> let x = Box::new(String::from(&quot;Hello&quot;));
 let ptr = Box::into_raw(x);
 let x = unsafe { Box::from_raw(ptr) };
</code></pre>
</blockquote>
<p>Nice, that looks <em>literally</em> designed for our use case. It also matches the rules we're trying to follow: start with safe stuff, turn into into raw pointers, and then only convert back to safe stuff at the end (when we want to Drop it).</p>
<p>This is basically exactly like doing the weird <code>real_next</code> thing but without having to faff around storing the Box when it's the exact same pointer as the raw pointer anyway.</p>
<p>Also now that we're just using raw pointers everywhere, let's not worry about keeping those <code>unsafe</code> blocks narrow: it's all unsafe now. (It always was, but it's nice to lie to yourself sometimes.)</p>
<pre><code class="language-rust ignore">pub fn push(&amp;mut self, elem: T) {
    unsafe {
        // Immediately convert the Box into a raw pointer
        let new_tail = Box::into_raw(Box::new(Node {
            elem: elem,
            next: ptr::null_mut(),
        }));

        if !self.tail.is_null() {
            (*self.tail).next = new_tail;
        } else {
            self.head = new_tail;
        }

        self.tail = new_tail;
    }
}
</code></pre>
<p>Hey that code's actually looking a lot cleaner now that we're sticking to raw pointers!</p>
<p>On to pop, which is also pretty similar to how we left it, although we've got to remember to use <code>Box::from_raw</code> to clean up the allocation:</p>
<pre><code class="language-rust ignore">pub fn pop(&amp;mut self) -&gt; Option&lt;T&gt; {
    unsafe {
        if self.head.is_null() {
            None
        } else {
            // RISE FROM THE GRAVE
            let head = Box::from_raw(self.head);
            self.head = head.next;

            if self.head.is_null() {
                self.tail = ptr::null_mut();
            }

            Some(head.elem)
        }
    }
}
</code></pre>
<p>Our nice little <code>take</code>s and <code>map</code>s are dead, gotta just check and set <code>null</code> manually now.</p>
<p>And while we're here, let's slap in the destructor. This time we'll implement it as just repeatedly popping, because it's cute and simple:</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; Drop for List&lt;T&gt; {
    fn drop(&amp;mut self) {
        while let Some(_) = self.pop() { }
    }
}
</code></pre>
<p>Now, for the moment of truth:</p>
<pre><code class="language-rust ignore">#[cfg(test)]
mod test {
    use super::List;
    #[test]
    fn basics() {
        let mut list = List::new();

        // Check empty list behaves right
        assert_eq!(list.pop(), None);

        // Populate list
        list.push(1);
        list.push(2);
        list.push(3);

        // Check normal removal
        assert_eq!(list.pop(), Some(1));
        assert_eq!(list.pop(), Some(2));

        // Push some more just to make sure nothing's corrupted
        list.push(4);
        list.push(5);

        // Check normal removal
        assert_eq!(list.pop(), Some(3));
        assert_eq!(list.pop(), Some(4));

        // Check exhaustion
        assert_eq!(list.pop(), Some(5));
        assert_eq!(list.pop(), None);

        // Check the exhaustion case fixed the pointer right
        list.push(6);
        list.push(7);

        // Check normal removal
        assert_eq!(list.pop(), Some(6));
        assert_eq!(list.pop(), Some(7));
        assert_eq!(list.pop(), None);
    }
}
</code></pre>
<pre><code class="language-text">cargo test

running 12 tests
test fifth::test::basics ... ok
test first::test::basics ... ok
test fourth::test::basics ... ok
test fourth::test::peek ... ok
test second::test::basics ... ok
test fourth::test::into_iter ... ok
test second::test::into_iter ... ok
test second::test::iter ... ok
test second::test::iter_mut ... ok
test second::test::peek ... ok
test third::test::basics ... ok
test third::test::iter ... ok

test result: ok. 12 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Good, but does miri agree?</p>
<pre><code class="language-text">MIRIFLAGS=&quot;-Zmiri-tag-raw-pointers&quot; cargo +nightly-2022-01-21 miri test

running 12 tests
test fifth::test::basics ... ok
test first::test::basics ... ok
test fourth::test::basics ... ok
test fourth::test::peek ... ok
test second::test::basics ... ok
test fourth::test::into_iter ... ok
test second::test::into_iter ... ok
test second::test::iter ... ok
test second::test::iter_mut ... ok
test second::test::peek ... ok
test third::test::basics ... ok
test third::test::iter ... ok

test result: ok. 12 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>EYYYY!!!!!</p>
<p>IT FRIGGIN WORKED!</p>
<p>PROBABLY!</p>
<p>FAILING TO FIND UNDEFINED BEHAVIOUR IS NOT A PROOF THAT IT ISN'T THERE WAITING TO CAUSE PROBLEMS BUT THERE IS A LIMIT TO HOW RIGOROUS I AM WILLING TO BE FOR A JOKE BOOK ABOUT LINKED LISTS SO WE'RE GONNA CALL THIS A 100% MACHINE VERIFIED PROOF AND ANYONE WHO SAYS OTHERWISE CAN SUCK MY COQ!</p>
<p>∴ QED □</p>
<h1><a class="header" href="#extra-junk" id="extra-junk">Extra Junk</a></h1>
<p>Now that <code>push</code> and <code>pop</code> are written, everything else is acutally exactly the same as the stack case, weirdly. Only operations that change the length of the list need to touch the tail pointer.</p>
<p>But of course, now that everything's unsafe pointers we need to rewrite the code to use those! And if we're going to be touching all the code, we might as well
take the chance to make sure we aren't missing something.</p>
<p>But anyway, let's start copy-pasting code from the stack implementation:</p>
<pre><code class="language-rust ignore">// ...

pub struct IntoIter&lt;T&gt;(List&lt;T&gt;);

pub struct Iter&lt;'a, T&gt; {
    next: Option&lt;&amp;'a Node&lt;T&gt;&gt;,
}

pub struct IterMut&lt;'a, T&gt; {
    next: Option&lt;&amp;'a mut Node&lt;T&gt;&gt;,
}
</code></pre>
<p>IntoIter looks fine, but <code>Iter</code> and <code>IterMut</code> are breaking our simple rule of never using safe pointers in our types anymore. Let's be safe and change those to use raw pointers:</p>
<pre><code class="language-rust ignore">pub struct IntoIter&lt;T&gt;(List&lt;T&gt;);

pub struct Iter&lt;'a, T&gt; {
    next: *mut Node&lt;T&gt;,
}

pub struct IterMut&lt;'a, T&gt; {
    next: *mut Node&lt;T&gt;,
}

impl&lt;T&gt; List&lt;T&gt; {
    pub fn into_iter(self) -&gt; IntoIter&lt;T&gt; {
        IntoIter(self)
    }

    pub fn iter(&amp;self) -&gt; Iter&lt;'_, T&gt; {
        Iter { next: self.head }
    }

    pub fn iter_mut(&amp;mut self) -&gt; IterMut&lt;'_, T&gt; {
        IterMut { next: self.head }
    }
}
</code></pre>
<p>Looks good!</p>
<pre><code class="language-text">error[E0392]: parameter `'a` is never used
  --&gt; src\fifth.rs:17:17
   |
17 | pub struct Iter&lt;'a, T&gt; {
   |                 ^^ unused parameter
   |
   = help: consider removing `'a`, referring to it in a field, 
     or using a marker such as `PhantomData`

error[E0392]: parameter `'a` is never used
  --&gt; src\fifth.rs:21:20
   |
21 | pub struct IterMut&lt;'a, T&gt; {
   |                    ^^ unused parameter
   |
   = help: consider removing `'a`, referring to it in a field, 
     or using a marker such as `PhantomData`
</code></pre>
<p>Doesn't look good! What's this <a href="https://doc.rust-lang.org/std/marker/struct.PhantomData.html">PhantomData</a> they're on about?</p>
<blockquote>
<p>Zero-sized type used to mark things that “act like” they own a <code>T</code>.</p>
<p>Adding a <code>PhantomData&lt;T&gt;</code> field to your type tells the compiler that your type acts as though it stores a value of type <code>T</code>, even though it doesn’t really. This information is used when computing certain safety properties.</p>
<p>For a more in-depth explanation of how to use <code>PhantomData&lt;T&gt;</code>, please see <a href="https://doc.rust-lang.org/nightly/nomicon/">the Nomicon</a>.</p>
</blockquote>
<p>Hey don't get hasty there, we're reading the book that <em>I</em> wrote. Not that other book that some huge <em>nerd</em> probably wrote! I bet if they write a data structure in there it's something lame like an Array Stack and <em>not</em> a Linked List.</p>
<blockquote>
<p>Unused lifetime parameters</p>
<p>Perhaps the most common use case for PhantomData is a struct that has an unused lifetime parameter, typically as part of some unsafe code.</p>
</blockquote>
<p>Ah so we're naming a lifetime in our type but not actually using it. We <em>could</em> go down the PhantomData path, but I want to save that for the doubly-linked list in the next chapter that will <em>really</em> need it.</p>
<p>We're in an interesting situation where we actually don't need PhantomData. <em>I think</em>. I'm just going to claim that and trust that it's true, and if miri yells at us at the end I'll concede the point and we'll do the PhantomData thing.</p>
<p>What we're actually going to do is put the references back in these Iterator types and be happy we get to use references in some places still. I think that's sound because there's still a kind of proper nesting when you use an iterator: you create the iterator, use safe references for a while, and then discard the iterator. </p>
<p>Only once the iterator is gone can you access the list and call things like <code>push</code> and <code>pop</code> which need to mess with the tail pointer and Boxes. Now, during the iteration we <em>are</em> going to be dereferencing a bunch of raw pointers, so there is a kind of mixing there, but we should be able to think of those references as reborrows of the unsafe pointers.</p>
<p><em>I'm</em> not even 100% convinced but I just wanna give it a try and see!</p>
<pre><code class="language-rust ignore">pub struct IntoIter&lt;T&gt;(List&lt;T&gt;);

pub struct Iter&lt;'a, T&gt; {
    next: Option&lt;&amp;'a Node&lt;T&gt;&gt;,
}

pub struct IterMut&lt;'a, T&gt; {
    next: Option&lt;&amp;'a mut Node&lt;T&gt;&gt;,
}

impl&lt;T&gt; List&lt;T&gt; {
    pub fn into_iter(self) -&gt; IntoIter&lt;T&gt; {
        IntoIter(self)
    }

    pub fn iter(&amp;self) -&gt; Iter&lt;'_, T&gt; {
        unsafe {
            Iter { next: self.head.as_ref() }
        }
    }

    pub fn iter_mut(&amp;mut self) -&gt; IterMut&lt;'_, T&gt; {
        unsafe {
            IterMut { next: self.head.as_mut() }
        }
    }
}
</code></pre>
<p>If we're going to be storing references, we need to upgrade our raw pointers to options-of-references. We <em>could</em> check if the pointer is null, but this is one of the incredibly narrow cases where I <em>think</em> it's ok to use the nasty <a href="https://doc.rust-lang.org/std/primitive.pointer.html#method.as_ref-1">ptr::as_ref</a> and <a href="https://doc.rust-lang.org/std/primitive.pointer.html#method.as_mut">ptr::as_mut</a> methods.</p>
<p>I <em>usually</em> recommend avoiding these methods like the plague because they do some surprising and nasty stuff and they're inherently reintroducing references when my whole &quot;easy rule&quot; is to avoid doing that!</p>
<p>Those methods come with a lot of warnings, but the most interesting is this:</p>
<blockquote>
<p>You must enforce Rust’s aliasing rules, since the returned lifetime <code>'a</code> is arbitrarily chosen and does not necessarily reflect the actual lifetime of the data. In particular, for the duration of this lifetime, the memory the pointer points to must not get accessed (read or written) through any other pointer.</p>
</blockquote>
<p>Hey look it's the thing we talked about for 25 pages! I have already asserted we're <em>definitely</em> going to be fine to use references here, so aliasing solved! The other evil part is the signature:</p>
<pre><code class="language-rust ignore">pub unsafe fn as_mut&lt;'a&gt;(self) -&gt; Option&lt;&amp;'a mut T&gt;
</code></pre>
<p>Do you see how that lifetime isn't attached to the input at all, because <code>self</code> is by-value? Yeah that's what we call an &quot;unbounded lifetime&quot; and it's nasty stuff. It's willing to pretend to be as large as we ask it to be, even <code>'static</code>! The way you <em>deal</em> with that is by putting it somewhere that <em>is</em> bounded, which usually just means &quot;return this from a function as soon as possible so that the function signature limits it&quot;.</p>
<p>Boy I'm nervous about this but we're gonna keep pushing through! Let's steal some iterator impls from the stack:</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; Iterator for IntoIter&lt;T&gt; {
    type Item = T;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.0.pop()
    }
}

impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {
    type Item = &amp;'a T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        unsafe {
            self.next.map(|node| {
                self.next = node.next.as_ref();
                &amp;node.elem
            })
        }
    }
}

impl&lt;'a, T&gt; Iterator for IterMut&lt;'a, T&gt; {
    type Item = &amp;'a mut T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        unsafe {
            self.next.take().map(|node| {
                self.next = node.next.as_mut();
                &amp;mut node.elem
            })
        }
    }
}
</code></pre>
<p>Moment of truth time...</p>
<pre><code class="language-text">cargo test

running 15 tests
test fifth::test::basics ... ok
test fifth::test::into_iter ... ok
test fifth::test::iter ... ok
test fifth::test::iter_mut ... ok
test first::test::basics ... ok
test fourth::test::basics ... ok
test fourth::test::into_iter ... ok
test fourth::test::peek ... ok
test second::test::basics ... ok
test second::test::into_iter ... ok
test second::test::iter ... ok
test second::test::iter_mut ... ok
test second::test::peek ... ok
test third::test::iter ... ok
test third::test::basics ... ok

test result: ok. 15 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out;
</code></pre>
<pre><code class="language-text">MIRIFLAGS=&quot;-Zmiri-tag-raw-pointers&quot; cargo +nightly-2022-01-21 miri test

running 15 tests
test fifth::test::basics ... ok
test fifth::test::into_iter ... ok
test fifth::test::iter ... ok
test fifth::test::iter_mut ... ok
test first::test::basics ... ok
test fourth::test::basics ... ok
test fourth::test::into_iter ... ok
test fourth::test::peek ... ok
test second::test::basics ... ok
test second::test::into_iter ... ok
test second::test::iter ... ok
test second::test::iter_mut ... ok
test second::test::peek ... ok
test third::test::basics ... ok
test third::test::iter ... ok

test result: ok. 15 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>YES!!! Take that <strong>NARRATOR</strong>! Sometimes I don't make mistakes!</p>
<blockquote>
<p><strong>NARRATOR</strong>: but wasn't the whole point that the mistakes are there to teach the reader.</p>
</blockquote>
<p>YEAH WELL SOMETIMES THE LESSON IS THAT I'M RIGHT AND EVERYONE SHOULD LISTEN TO ME WHEN I SAY THINGS ABOUT UNSAFE CODE BECAUSE I HAVE SPENT FAR TOO MUCH TIME THINKING ABOUT THE SOUNDNESS OF ITERATOR IMPLEMENTATIONS?! OK?! OK.</p>
<p>Anyway here's <code>peek</code> and <code>peek_mut</code>.</p>
<pre><code class="language-rust ignore">pub fn peek(&amp;self) -&gt; Option&lt;&amp;T&gt; {
    unsafe {
        self.head.as_ref()
    }
}

pub fn peek_mut(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt; {
    unsafe {
        self.head.as_mut()
    }
}
</code></pre>
<p>I'm not even gonna test them because I never make mistakes anymore.</p>
<blockquote>
<p><strong>NARRATOR</strong>: <code>cargo build</code></p>
</blockquote>
<pre><code class="language-text">error[E0308]: mismatched types
  --&gt; src\fifth.rs:66:13
   |
25 | impl&lt;T&gt; List&lt;T&gt; {
   |      - this type parameter
...
64 |     pub fn peek(&amp;self) -&gt; Option&lt;&amp;T&gt; {
   |                           ---------- expected `Option&lt;&amp;T&gt;` 
   |                                      because of return type
65 |         unsafe {
66 |             self.head.as_ref()
   |             ^^^^^^^^^^^^^^^^^^ expected type parameter `T`, 
   |                                found struct `fifth::Node`
   |
   = note: expected enum `Option&lt;&amp;T&gt;`
              found enum `Option&lt;&amp;fifth::Node&lt;T&gt;&gt;`

</code></pre>
<p>FINE.</p>
<pre><code class="language-rust ignore">pub fn peek(&amp;self) -&gt; Option&lt;&amp;T&gt; {
    unsafe {
        self.head.as_ref().map(|node| &amp;node.elem)
    }
}

pub fn peek_mut(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt; {
    unsafe {
        self.head.as_mut().map(|node| &amp;mut node.elem)
    }
}
</code></pre>
<p>I guess I am going to <em>continue</em> to make mistakes, so we're going to be extra careful and add a new test I'm going to call &quot;miri food&quot;: something that just messes around and mixes up our APIs a bunch to help miri catch our mistakes.</p>
<pre><code class="language-rust ignore">#[test]
fn miri_food() {
    let mut list = List::new();

    list.push(1);
    list.push(2);
    list.push(3);

    assert!(list.pop() == Some(1));
    list.push(4);
    assert!(list.pop() == Some(2));
    list.push(5);

    assert!(list.peek() == Some(&amp;3));
    list.push(6);
    list.peek_mut().map(|x| *x *= 10);
    assert!(list.peek() == Some(&amp;30));
    assert!(list.pop() == Some(30));

    for elem in list.iter_mut() {
        *elem *= 100;
    }

    let mut iter = list.iter();
    assert_eq!(iter.next(), Some(&amp;400));
    assert_eq!(iter.next(), Some(&amp;500));
    assert_eq!(iter.next(), Some(&amp;600));
    assert_eq!(iter.next(), None);
    assert_eq!(iter.next(), None);

    assert!(list.pop() == Some(400));
    list.peek_mut().map(|x| *x *= 10);
    assert!(list.peek() == Some(&amp;5000));
    list.push(7);

    // Drop it on the ground and let the dtor exercise itself
}
</code></pre>
<pre><code class="language-text">cargo test

running 16 tests
test fifth::test::basics ... ok
test fifth::test::into_iter ... ok
test fifth::test::iter ... ok
test fifth::test::iter_mut ... ok
test fifth::test::miri_food ... ok
test first::test::basics ... ok
test fourth::test::basics ... ok
test fourth::test::into_iter ... ok
test fourth::test::peek ... ok
test second::test::into_iter ... ok
test second::test::basics ... ok
test second::test::iter_mut ... ok
test second::test::peek ... ok
test third::test::iter ... ok
test second::test::iter ... ok
test third::test::basics ... ok

test result: ok. 16 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out



MIRIFLAGS=&quot;-Zmiri-tag-raw-pointers&quot; cargo +nightly-2022-01-21 miri test

running 16 tests
test fifth::test::basics ... ok
test fifth::test::into_iter ... ok
test fifth::test::iter ... ok
test fifth::test::iter_mut ... ok
test fifth::test::miri_food ... ok
test first::test::basics ... ok
test fourth::test::basics ... ok
test fourth::test::into_iter ... ok
test fourth::test::peek ... ok
test second::test::into_iter ... ok
test second::test::basics ... ok
test second::test::iter_mut ... ok
test second::test::peek ... ok
test third::test::iter ... ok
test second::test::iter ... ok
test third::test::basics ... ok

test result: ok. 16 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Perfect.</p>
<h1><a class="header" href="#final-code-3" id="final-code-3">Final Code</a></h1>
<p>Alright, so with a teeny-tiny dash of unsafety we managed to get a linear
time improvement over the naive safe queue, and we managed to reuse almost
all of the logic from the safe stack!</p>
<p>You know, except for that part where miri completely dunked on us and we had to write a short master's thesis on rust's memory model. You know, as you do.</p>
<p>But on the bright side we <em>didn't</em> have to write any jank Rc or RefCell stuff.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::ptr;

pub struct List&lt;T&gt; {
    head: Link&lt;T&gt;,
    tail: *mut Node&lt;T&gt;,
}

type Link&lt;T&gt; = *mut Node&lt;T&gt;;

struct Node&lt;T&gt; {
    elem: T,
    next: Link&lt;T&gt;,
}

pub struct IntoIter&lt;T&gt;(List&lt;T&gt;);

pub struct Iter&lt;'a, T&gt; {
    next: Option&lt;&amp;'a Node&lt;T&gt;&gt;,
}

pub struct IterMut&lt;'a, T&gt; {
    next: Option&lt;&amp;'a mut Node&lt;T&gt;&gt;,
}

impl&lt;T&gt; List&lt;T&gt; {
    pub fn new() -&gt; Self {
        List { head: ptr::null_mut(), tail: ptr::null_mut() }
    }
    pub fn push(&amp;mut self, elem: T) {
        unsafe {
            let new_tail = Box::into_raw(Box::new(Node {
                elem: elem,
                next: ptr::null_mut(),
            }));

            if !self.tail.is_null() {
                (*self.tail).next = new_tail;
            } else {
                self.head = new_tail;
            }

            self.tail = new_tail;
        }
    }
    pub fn pop(&amp;mut self) -&gt; Option&lt;T&gt; {
        unsafe {
            if self.head.is_null() {
                None
            } else {
                let head = Box::from_raw(self.head);
                self.head = head.next;

                if self.head.is_null() {
                    self.tail = ptr::null_mut();
                }

                Some(head.elem)
            }
        }
    }

    pub fn peek(&amp;self) -&gt; Option&lt;&amp;T&gt; {
        unsafe {
            self.head.as_ref().map(|node| &amp;node.elem)
        }
    }

    pub fn peek_mut(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt; {
        unsafe {
            self.head.as_mut().map(|node| &amp;mut node.elem)
        }
    }

    pub fn into_iter(self) -&gt; IntoIter&lt;T&gt; {
        IntoIter(self)
    }

    pub fn iter(&amp;self) -&gt; Iter&lt;'_, T&gt; {
        unsafe {
            Iter { next: self.head.as_ref() }
        }
    }

    pub fn iter_mut(&amp;mut self) -&gt; IterMut&lt;'_, T&gt; {
        unsafe {
            IterMut { next: self.head.as_mut() }
        }
    }
}

impl&lt;T&gt; Drop for List&lt;T&gt; {
    fn drop(&amp;mut self) {
        while let Some(_) = self.pop() { }
    }
}

impl&lt;T&gt; Iterator for IntoIter&lt;T&gt; {
    type Item = T;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.0.pop()
    }
}

impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {
    type Item = &amp;'a T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        unsafe {
            self.next.map(|node| {
                self.next = node.next.as_ref();
                &amp;node.elem
            })
        }
    }
}

impl&lt;'a, T&gt; Iterator for IterMut&lt;'a, T&gt; {
    type Item = &amp;'a mut T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        unsafe {
            self.next.take().map(|node| {
                self.next = node.next.as_mut();
                &amp;mut node.elem
            })
        }
    }
}

#[cfg(test)]
mod test {
    use super::List;
    #[test]
    fn basics() {
        let mut list = List::new();

        // Check empty list behaves right
        assert_eq!(list.pop(), None);

        // Populate list
        list.push(1);
        list.push(2);
        list.push(3);

        // Check normal removal
        assert_eq!(list.pop(), Some(1));
        assert_eq!(list.pop(), Some(2));

        // Push some more just to make sure nothing's corrupted
        list.push(4);
        list.push(5);

        // Check normal removal
        assert_eq!(list.pop(), Some(3));
        assert_eq!(list.pop(), Some(4));

        // Check exhaustion
        assert_eq!(list.pop(), Some(5));
        assert_eq!(list.pop(), None);

        // Check the exhaustion case fixed the pointer right
        list.push(6);
        list.push(7);

        // Check normal removal
        assert_eq!(list.pop(), Some(6));
        assert_eq!(list.pop(), Some(7));
        assert_eq!(list.pop(), None);
    }

    #[test]
    fn into_iter() {
        let mut list = List::new();
        list.push(1); list.push(2); list.push(3);

        let mut iter = list.into_iter();
        assert_eq!(iter.next(), Some(1));
        assert_eq!(iter.next(), Some(2));
        assert_eq!(iter.next(), Some(3));
        assert_eq!(iter.next(), None);
    }

    #[test]
    fn iter() {
        let mut list = List::new();
        list.push(1); list.push(2); list.push(3);

        let mut iter = list.iter();
        assert_eq!(iter.next(), Some(&amp;1));
        assert_eq!(iter.next(), Some(&amp;2));
        assert_eq!(iter.next(), Some(&amp;3));
        assert_eq!(iter.next(), None);
    }

    #[test]
    fn iter_mut() {
        let mut list = List::new();
        list.push(1); list.push(2); list.push(3);

        let mut iter = list.iter_mut();
        assert_eq!(iter.next(), Some(&amp;mut 1));
        assert_eq!(iter.next(), Some(&amp;mut 2));
        assert_eq!(iter.next(), Some(&amp;mut 3));
        assert_eq!(iter.next(), None);
    }

    #[test]
    fn miri_food() {
        let mut list = List::new();

        list.push(1);
        list.push(2);
        list.push(3);

        assert!(list.pop() == Some(1));
        list.push(4);
        assert!(list.pop() == Some(2));
        list.push(5);

        assert!(list.peek() == Some(&amp;3));
        list.push(6);
        list.peek_mut().map(|x| *x *= 10);
        assert!(list.peek() == Some(&amp;30));
        assert!(list.pop() == Some(30));

        for elem in list.iter_mut() {
            *elem *= 100;
        }

        let mut iter = list.iter();
        assert_eq!(iter.next(), Some(&amp;400));
        assert_eq!(iter.next(), Some(&amp;500));
        assert_eq!(iter.next(), Some(&amp;600));
        assert_eq!(iter.next(), None);
        assert_eq!(iter.next(), None);

        assert!(list.pop() == Some(400));
        list.peek_mut().map(|x| *x *= 10);
        assert!(list.peek() == Some(&amp;5000));
        list.push(7);

        // Drop it on the ground and let the dtor exercise itself
    }
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#a-production-quality-unsafe-doubly-linked-deque" id="a-production-quality-unsafe-doubly-linked-deque">A Production-Quality Unsafe Doubly-Linked Deque</a></h1>
<p>We finally made it. My greatests nemesis: <strong><a href="https://github.com/rust-lang/rust/blob/master/library/alloc/src/collections/linked_list.rs">std::collections::LinkedList</a>, the Doubly-Linked Deque</strong>. </p>
<p>The one that I tried and failed to destroy.</p>
<p>Our story begins as 2014 was coming to a close and we were rapidly approaching the release of Rust 1.0, Rust's first stable release. I had found myself in the role of caring for <code>std::collections</code>, or as we affectionately called it in those times, libcollections.</p>
<p>libcollections had spent years as a dumping ground for everyone's Cute Ideas and Vaguely Useful Things. This was all well and good when Rust was a fledgling experimental language, but if my children were going to escape the nest and be stabilized, they would have to prove their worth.</p>
<p>Until then I had encouraged and nurtured them all, but it was now time for them to face judgement for their failings.</p>
<p>I sunk my claws into the bedrock and carved tombstones for my most foolish children. A grisly monument that I placed in the town square for all to see:</p>
<p><strong><a href="https://github.com/rust-lang/rust/pull/19955">Kill TreeMap, TreeSet, TrieMap, TrieSet, LruCache and EnumSet</a></strong></p>
<p>Their fates were sealed, for my word was absolute. The other collections were horrified by my brutality, but they were not yet safe from their mother's wrath. I soon returned with two more tombstones:</p>
<p><strong><a href="https://github.com/rust-lang/rust/pull/26034">Deprecate BitSet and BitVec</a></strong></p>
<p>The Bit twins were more cunning than their fallen comrades, but they lacked the strength to escape me. Most thought my work done, but I soon took one more: </p>
<p><strong><a href="https://github.com/rust-lang/rust/pull/26734">Deprecate VecMap</a></strong></p>
<p>VecMap had tried to survive through stealth — it was so small and inoffensive! But that wasn't enough for the libcollections I saw in my vision of the future.</p>
<p>I surveyed the land and saw what remained:</p>
<ul>
<li>Vec and VecDeque - hearty and simple, the heart of computing.</li>
<li>HashMap and HashSet - powerful and wise, the brain of computing.</li>
<li>BTreeMap and BTreeSet - awkward but necessary, the liver of computing.</li>
<li>BinaryHeap - crafty and dextrous, the ankle of computing.</li>
</ul>
<p>I nodded in contentment. Simple and effective. My work was don—</p>
<p>No, <a href="https://github.com/rust-lang/rust/blob/0a84308ebaaafb8fd89b2fd7c235198e3ec21384/src/libcollections/dlist.rs">DList</a>, it can't be! I thought you died in that tragic garbage collection incident! The one which was definitely an accident and not intentional at all!</p>
<p>They had faked their death and taken on a new name, but it was still them: LinkedList, the shadowy and untrustworthy schemer of computing. </p>
<p>I spread word of their misdeeds to all that would hear me, but hearts were unmoved. LinkedList was a silver-tongued devil who had convinced everyone around me that it was some sort of fundamental and natural datastructure of computing. It had even convinced C++ that it was <a href="https://en.cppreference.com/w/cpp/container/list"><em>the</em> list</a>!</p>
<p>&quot;How could you have a standard library without a <em>LinkedList</em>?&quot;</p>
<p>Easily! Trivially!</p>
<p>&quot;It's non-trivial unsafe code, so it makes sense to have it in the standard library!&quot;</p>
<p>So are GPU drivers and video codecs, libcollections is minimalist!</p>
<p>But alas, LinkedList had gathered too many allies and grown too strong while I was distracted with its kin.</p>
<p>I fled to my laboratory and tried to devise some sort of <a href="https://github.com/contain-rs/linked-list">evil clone</a> or <a href="https://github.com/contain-rs/blist">enhanced cyborg replicant</a> that could rival and destroy it, but my grant funding ran out because my research was &quot;too murderously evil&quot; or somesuch nonsense.</p>
<p>LinkedList had won. I was defeated and forced into exile.</p>
<p>But you're here now. You've come this far. Surely now you can understand the depths of LinkedList's debauchery! Come, I will you show you everything you need to know to help me destroy it once and for all — everything you need to know to implement an unsafe production-quality Doubly-Linked Deque.</p>
<p>How production-quality? Well we're going to completely rewrite my ancient Rust 1.0 linked-list crate, the one that is objectively better than the one in std. The one with Cursors on stable Rust, from 2015! Something the 2022 stdlib still doesn't have!</p>
<h1><a class="header" href="#layout-4" id="layout-4">Layout</a></h1>
<p>Let us begin by first studying the structure of our enemy. A Doubly-Linked List is conceptually simple, but that's how it decieves and manipulates you. It's the same kind of linked list we've looked at over and over, but the links go both ways. Double the links, double the evil.</p>
<p>So rather than this (gonna drop the Some/None stuff to keep it cleaner):</p>
<pre><code class="language-text">... -&gt; (A, ptr) -&gt; (B, ptr) -&gt; ...
</code></pre>
<p>We have this:</p>
<pre><code class="language-text">... &lt;-&gt; (ptr, A, ptr) &lt;-&gt; (ptr, B, ptr) &lt;-&gt; ...
</code></pre>
<p>This lets you traverse the list from either direction, or seek back and forth with a <a href="https://doc.rust-lang.org/std/collections/struct.LinkedList.html#method.cursor_back_mut">cursor</a>.</p>
<p>In exchange for this flexibility, every node has to store twice as many pointers, and every operation has to fix up way more pointers. It's a significant enough complication that it's a lot easier to make a mistake, so we're going to be doing a lot of testing.</p>
<p>You might have also noticed that I intentionally haven't drawn the <em>ends</em> of the list. This is because this is one of the places where there are genuinely defensible options for our implementation. We <em>definitely</em> need our implementation to have two pointers: one to the start of the list, and one to the end of the list.</p>
<p>There are two notable ways to do this in my mind: &quot;traditional&quot; and &quot;dummy node&quot;.</p>
<p>The traditional approach is the simple extension of how we did a Stack — just store the head and tail pointers on the stack:</p>
<pre><code class="language-text">[ptr, ptr] &lt;-&gt; (ptr, A, ptr) &lt;-&gt; (ptr, B, ptr)
  ^                                        ^
  +----------------------------------------+
</code></pre>
<p>This is fine, but it has one downside: corner cases. There are now two edges to our list, which means twice as many corner cases. It's easy to forget one and have a serious bug.</p>
<p>The dummy node approach attempts to smooth out these corner cases by adding an extra node to our list which contains no data but links the two ends together into a ring:</p>
<pre><code class="language-text">[ptr] -&gt; (ptr, ?DUMMY?, ptr) &lt;-&gt; (ptr, A, ptr) &lt;-&gt; (ptr, B, ptr)
           ^                                                 ^
           +-------------------------------------------------+ 
</code></pre>
<p>By doing this, every node <em>always</em> has actual pointers to a previous and next node in the list. Even when you remove the last element from the list, you just end up stitching the dummy node to point at itself:</p>
<pre><code class="language-text">[ptr] -&gt; (ptr, ?DUMMY?, ptr) 
           ^             ^
           +-------------+
</code></pre>
<p>There is a part of me that finds this <em>very</em> satisfying and elegant. Unfortunately, it has a couple practical problems:</p>
<p>Problem 1: An extra indirection and allocation, especially for the empty list, which must include the dummy node. Potential solutions include:</p>
<ul>
<li>
<p>Don't allocate the dummy node until something is inserted: simple and effective, but it adds back some of the corner cases we were trying to avoid by using dummy pointers!</p>
</li>
<li>
<p>Use a static copy-on-write empty singleton dummy node, with some really clever scheme that lets the Copy-On-Write checks piggy-back on normal checks: look I'm really tempted, I really do love that shit, but we can't go down that dark path in this book. Read <a href="https://docs.rs/thin-vec/0.2.4/src/thin_vec/lib.rs.html#319-325">ThinVec's sourcecode</a> if you want to see that kind of perverted stuff.</p>
</li>
<li>
<p>Store the dummy node on the stack - not practical in a language without C++-style move-constructors. I'm sure there's something weird thing we could do here with <a href="https://doc.rust-lang.org/std/pin/index.html">pinning</a> but we're not gonna.</p>
</li>
</ul>
<p>Problem 2: What <em>value</em> is stored in the dummy node? Sure if it's an integer it's fine, but what if we're storing a list full of <code>Box</code>? It may be impossible for us to initialized this value! Potential solutions include:</p>
<ul>
<li>
<p>Make every node store <code>Option&lt;T&gt;</code>: simple and effective, but also bloated and annoying.</p>
</li>
<li>
<p>Make every node store <a href="https://doc.rust-lang.org/std/mem/union.MaybeUninit.html"><code>MaybeUninit&lt;T&gt;</code></a>. Horrifying and annoying.</p>
</li>
<li>
<p><em>Really</em> careful and clever inheritance-style type punning so the dummy node doesn't include the data field. This is also tempting but it's extremely dangerous and annoying. Read <a href="https://doc.rust-lang.org/1.55.0/src/alloc/collections/btree/node.rs.html#49-104">BTreeMap's source</a> if you want to see that kind of perverted stuff.</p>
</li>
</ul>
<p>The problems really outweigh the convenience for a language like Rust, so we're going to stick to the traditional layout. We'll be using the same basic design as we did for the unsafe queue in the previous chapter:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct LinkedList&lt;T&gt; {
    front: Link&lt;T&gt;,
    back: Link&lt;T&gt;,
    len: usize,
}

type Link&lt;T&gt; = *mut Node&lt;T&gt;;

struct Node&lt;T&gt; {
    front: Link&lt;T&gt;,
    back: Link&lt;T&gt;,
    elem: T, 
}
<span class="boring">}
</span></code></pre></pre>
<p>(Now that we have reached the doubly-linked-deque, we have finally earned the right to call ourselves LinkedList, for this is the True Linked List.)</p>
<p>This isn't quite a <em>true</em> production-quality layout yet. It's <em>fine</em> but there's magic tricks we can do to tell Rust what we're doing a bit better. To do that we're going to need to go... deeper.</p>
<h1><a class="header" href="#variance-and-phantomdata" id="variance-and-phantomdata">Variance and PhantomData</a></h1>
<p>It's going to be annoying to punt on this now and fix it later, so we're going to do the Hardcore Layout stuff now.</p>
<p>There are five terrible horsemen of making unsafe Rust collections:</p>
<ol>
<li><a href="https://doc.rust-lang.org/nightly/nomicon/subtyping.html">Variance</a></li>
<li><a href="https://doc.rust-lang.org/nightly/nomicon/dropck.html">Drop Check</a></li>
<li><a href="https://doc.rust-lang.org/nightly/std/ptr/struct.NonNull.html">NonNull Optimizations</a></li>
<li><a href="https://doc.rust-lang.org/nightly/nomicon/vec/vec-alloc.html">The isize::MAX Allocation Rule</a></li>
<li><a href="https://doc.rust-lang.org/nightly/nomicon/vec/vec-zsts.html">Zero-Sized Types</a></li>
</ol>
<p>Mercifully, the last 2 aren't going to be a problem for us. </p>
<p>The third we <em>could</em> make into our problem but it's more trouble than it's worth -- if you've opted into a LinkedList you've already given up the battle on memory-effeciency 100-fold already.</p>
<p>The second is something that I used to insist was really important and that std messes around with, but the defaults are safe, the ways to mess with it are unstable, and you need to try <em>so very hard</em> to ever notice the limitations of the defaults, so, don't worry about it.</p>
<p>That just leaves us with Variance. To be honest, you can probably punt on this one too, but I still have my pride as a Collections Person, so we're going to Do The Variance Thing.</p>
<p>So, surprise: Rust has subtyping. In particular, <code>&amp;'big T</code> is a <em>subtype</em> of <code>&amp;'small T</code>. Why? Well because if some code needs a reference that lives for some particular region of the program, it's usually perfectly fine to give it a reference that lives for <em>longer</em>. Like, intuitively that's just true, right?</p>
<p>Why is this important? Well imagine some code that takes two values with the same type:</p>
<pre><code class="language-rust ignore">fn take_two&lt;T&gt;(_val1: T, _val2: T) { }
</code></pre>
<p>This is some deeply boring code, and so we should expect it to work with T=&amp;u32 fine, right?</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn two_refs&lt;'big: 'small, 'small&gt;(
    big: &amp;'big u32, 
    small: &amp;'small u32,
) {
    take_two(big, small);
}

fn take_two&lt;T&gt;(_val1: T, _val2: T) { }
<span class="boring">}
</span></code></pre></pre>
<p>Yep, that compiles fine!</p>
<p>Now let's have some fun and wrap it in, oh, I don't know, <code>std::cell::Cell</code>:</p>
<pre><pre class="playground"><code class="language-rust compilefail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cell::Cell;

fn two_refs&lt;'big: 'small, 'small&gt;(
    // NOTE: these two lines changed
    big: Cell&lt;&amp;'big u32&gt;, 
    small: Cell&lt;&amp;'small u32&gt;,
) {
    take_two(big, small);
}

fn take_two&lt;T&gt;(_val1: T, _val2: T) { }
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-text">error[E0623]: lifetime mismatch
 --&gt; src/main.rs:7:19
  |
4 |     big: Cell&lt;&amp;'big u32&gt;, 
  |               ---------
5 |     small: Cell&lt;&amp;'small u32&gt;,
  |                 ----------- these two types are declared with different lifetimes...
6 | ) {
7 |     take_two(big, small);
  |                   ^^^^^ ...but data from `small` flows into `big` here
</code></pre>
<p>Huh??? We didn't touch the lifetimes, why's the compiler angry now!?</p>
<p>Ah well, the lifetime &quot;subtyping&quot; stuff must be really simple, so it falls over if you wrap the references in anything, see look it breaks with Vec too:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn two_refs&lt;'big: 'small, 'small&gt;(
    big: Vec&lt;&amp;'big u32&gt;, 
    small: Vec&lt;&amp;'small u32&gt;,
) {
    take_two(big, small);
}

fn take_two&lt;T&gt;(_val1: T, _val2: T) { }
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-text">    Finished dev [unoptimized + debuginfo] target(s) in 1.07s
     Running `target/debug/playground`
</code></pre>
<p>See it doesn't compile eith-- wait what??? Vec is magic??????</p>
<p>Well, yes. But also, no. The magic was inside us all along, and that magic is ✨<em>Variance</em>✨.</p>
<p>Read the <a href="https://doc.rust-lang.org/nightly/nomicon/subtyping.html">nomicon's chapter on subtyping</a> if you want all the gorey details, but basically subtyping <em>isn't</em> always safe. In particular it's not safe when mutable references are involved because you can use things like <code>mem::swap</code> and suddenly oops dangling pointers!</p>
<p>Things that are &quot;like mutable references&quot; are <em>invariant</em> which means they block subtyping from happening on their generic parameters. So for safety, <code>&amp;mut T</code> is invariant over T, and <code>Cell&lt;T&gt;</code> is invariant over T because <code>&amp;Cell&lt;T&gt;</code> is basically just <code>&amp;mut T</code> (because of interior mutability).</p>
<p>Almost everything that isn't invariant is <em>covariant</em>, and that just means that subtyping &quot;passes through&quot; it and continues to work normally (there are also contravariant types that make subtyping go backwards but they are really rare and no one likes them so I won't mention them again).</p>
<p>Collections generally contain a mutable pointer to their data, so you might expect them to be invariant too, but in fact, they don't need to be! Because of Rust's ownership system, <code>Vec&lt;T&gt;</code> is semantically equivalent to <code>T</code>, and that means it's safe for it to be covariant!</p>
<p>Unfortunately, this definition is invariant:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct LinkedList&lt;T&gt; {
    front: Link&lt;T&gt;,
    back: Link&lt;T&gt;,
    len: usize,
}

type Link&lt;T&gt; = *mut Node&lt;T&gt;;

struct Node&lt;T&gt; {
    front: Link&lt;T&gt;,
    back: Link&lt;T&gt;,
    elem: T, 
}
<span class="boring">}
</span></code></pre></pre>
<p>But how is Rust actually deciding the variance of things? Well in the good-old-days before 1.0 we messed around with just letting people specify the variance they wanted and... it was an absolute train-wreck! Subtyping and variance is really hard to wrap your head around, and core developers genuinely disagreed on basic terminology! So we moved to a &quot;variance by example&quot; approach: the compiler just looks at your fields and copies their variances. If there's any kind of disagreement, then invariance always wins, because that's safe.</p>
<p>So what's in our type definitions that Rust is getting mad about? <code>*mut</code>!</p>
<p>Raw pointers in Rust really just try to let you do whatever, but they have exactly one safety feature: because most people have no idea that variance and subtyping are a thing in Rust, and being <em>incorrectly</em> covariant would be horribly dangerous, <code>*mut T</code> is invariant, because there's a good chance it's being used &quot;as&quot; <code>&amp;mut T</code>.</p>
<p>This is extremely annoying for Exactly Me as a person who has spent a lot of time writing collections in Rust. This is why when I made <a href="https://doc.rust-lang.org/std/ptr/struct.NonNull.html">std::ptr::NonNull</a>, I added this little piece of magic:</p>
<blockquote>
<p>Unlike <code>*mut T</code>, <code>NonNull&lt;T&gt;</code> was chosen to be covariant over <code>T</code>. This makes it possible to use <code>NonNull&lt;T&gt;</code> when building covariant types, but introduces the risk of unsoundness if used in a type that shouldn’t actually be covariant.</p>
</blockquote>
<p>But hey, it's interface is built around <code>*mut T</code>, what's the deal! Is it just magic?! Let's look:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct NonNull&lt;T&gt; {
    pointer: *const T,
}


impl&lt;T&gt; NonNull&lt;T&gt; {
    pub unsafe fn new_unchecked(ptr: *mut T) -&gt; Self {
        // SAFETY: the caller must guarantee that `ptr` is non-null.
        unsafe { NonNull { pointer: ptr as *const T } }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>NOPE. NO MAGIC HERE! NonNull just abuses the fact that <code>*const T</code> is covariant and stores that instead, casting back and forth between <code>*mut T</code> at the API boundary to make it &quot;look like&quot; it's storing a <code>*mut T</code>. That's the whole trick! That's how collections in Rust are covariant! And it's miserable! So I made the Good Pointer Type do it for you! You're welcome! Enjoy your subtyping footgun!</p>
<p>The solution to all your problems is to use NonNull, and then if you want to have nullable pointers again, use <code>Option&lt;NonNull&lt;T&gt;&gt;</code>. Are we really going to bother doing that..?</p>
<p>Yep! It sucks, but we're making <em>production grade linked lists</em> so we're going to eat all our vegetables and do things the hard way (we could just use bare <code>*const T</code> and cast everywhere, but I genuinely want to see how painful this is... for Ergonomics Science).</p>
<p>So here's our final type definitions:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::ptr::NonNull;

// !!!This changed!!!
pub struct LinkedList&lt;T&gt; {
    front: Link&lt;T&gt;,
    back: Link&lt;T&gt;,
    len: usize,
}

type Link&lt;T&gt; = Option&lt;NonNull&lt;Node&lt;T&gt;&gt;&gt;;

struct Node&lt;T&gt; {
    front: Link&lt;T&gt;,
    back: Link&lt;T&gt;,
    elem: T, 
}
<span class="boring">}
</span></code></pre></pre>
<p>...wait nope, one last thing. Any time you do raw pointer stuff, you should add a Ghost to protect your pointers:</p>
<pre><code class="language-rust ignore">use std::marker::PhantomData;

pub struct LinkedList&lt;T&gt; {
    front: Link&lt;T&gt;,
    back: Link&lt;T&gt;,
    len: usize,
    /// We semantically store values of T by-value.
    _boo: PhantomData&lt;T&gt;,
}
</code></pre>
<p>In this case I don't think we <em>actually</em> need <a href="https://doc.rust-lang.org/std/marker/struct.PhantomData.html">PhantomData</a>, but any time you <em>do</em> use NonNull (or just raw pointers in general), you should always add it to be safe and make it clear to the compiler and others what you <em>think</em> you're doing.</p>
<p>PhantomData is a way for us to give the compiler an extra &quot;example&quot; field that <em>conceptually</em> exists in your type but for various reasons (indirection, type erasure, ...) doesn't. In this case we're using NonNull because we're claiming our type behaves &quot;as if&quot; it stored a value T, so we add a PhantomData to make that explicit.</p>
<p>The stdlib actually has other reasons to do this because it has access to the accursed <a href="https://doc.rust-lang.org/nightly/nomicon/dropck.html">Drop Check overrides</a>, but that feature has been reworked so many times that I don't actually know if the PhantomData thing <em>is</em> a thing for it anymore. I'm still going to cargo-cult it for all eternity, because Drop Check Magic is burned into my brain!</p>
<p>(Node literally stores a T, so it doesn't have to do this, yay!)</p>
<p>...ok for real we're done with layout now! On to actual basic functionality!</p>
<h1><a class="header" href="#basics-3" id="basics-3">Basics</a></h1>
<p>Alright, this is the part of the book that sucks, and why it took me 7 years to write this chapter! Time to just burn through a whole lot of really boring stuff we've done 5 times already, but extra verbose and long because we have to do everything twice and with <code>Option&lt;NonNull&lt;Node&lt;T&gt;&gt;&gt;</code>!</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; LinkedList&lt;T&gt; {
    pub fn new() -&gt; Self {
        Self {
            front: None,
            back: None,
            len: 0,
            _boo: PhantomData,
        }
    }
}
</code></pre>
<p>PhantomData is a weird type with no fields so you just make one by, saying its type name. <em>shrug</em></p>
<pre><code class="language-rust ignore">pub fn push_front(&amp;mut self, elem: T) {
    // SAFETY: it's a linked-list, what do you want?
    unsafe {
        let new = NonNull::new_unchecked(Box::into_raw(Box::new(Node {
            front: None,
            back: None,
            elem,
        })));
        if let Some(old) = self.front {
            // Put the new front before the old one
            (*old).front = Some(new);
            (*new).back = Some(old);
        } else {
            // If there's no front, then we're the empty list and need 
            // to set the back too. Also here's some integrity checks
            // for testing, in case we mess up.
            debug_assert!(self.back.is_none());
            debug_assert!(self.front.is_none());
            debug_assert!(self.len == 0);
            self.back = Some(new);
        }
        self.front = Some(new);
        self.len += 1;
    }
}
</code></pre>
<pre><code class="language-text">error[E0614]: type `NonNull&lt;Node&lt;T&gt;&gt;` cannot be dereferenced
  --&gt; src\lib.rs:39:17
   |
39 |                 (*old).front = Some(new);
   |                 ^^^^^^
</code></pre>
<p>Ah yes, I truly hate my pointer-y children. We need to explicitly get the raw pointer out of NonNull with <code>as_ptr</code>, because DerefMut is defined in terms of <code>&amp;mut</code> and we don't want to randomly introduce safe references into our unsafe code!</p>
<pre><code class="language-rust ignore">            (*old.as_ptr()).front = Some(new);
            (*new.as_ptr()).back = Some(old);
</code></pre>
<pre><code class="language-text">   Compiling linked-list v0.0.3
warning: field is never read: `elem`
  --&gt; src\lib.rs:16:5
   |
16 |     elem: T,
   |     ^^^^^^^
   |
   = note: `#[warn(dead_code)]` on by default

warning: `linked-list` (lib) generated 1 warning (1 duplicate)
warning: `linked-list` (lib test) generated 1 warning
    Finished test [unoptimized + debuginfo] target(s) in 0.33s
</code></pre>
<p>Nice, now for pop (and len):</p>
<pre><code class="language-rust ignore">pub fn pop_front(&amp;mut self) -&gt; Option&lt;T&gt; {
    unsafe {
        // Only have to do stuff if there is a front node to pop.
        // Note that we don't need to mess around with `take` anymore
        // because everything is Copy and there are no dtors that will
        // run if we mess up... right? :) Riiiight? :)))
        self.front.map(|node| {
            // Bring the Box back to life so we can move out its value and
            // Drop it (Box continues to magically understand this for us).
            let boxed_node = Box::from_raw(node.as_ptr());
            let result = boxed_node.elem;

            // Make the next node into the new front.
            self.front = boxed_node.back;
            if let Some(new) = self.front {
                // Cleanup its reference to the removed node
                (*new.as_ptr()).front = None;
            } else {
                // If the front is now null, then this list is now empty!
                debug_assert!(self.len == 1);
                self.back = None;
            }

            self.len -= 1;
            result
            // Box gets implicitly freed here, knows there is no T.
        })
    }
}

pub fn len(&amp;self) -&gt; usize {
    self.len
}
</code></pre>
<pre><code class="language-text">   Compiling linked-list v0.0.3
    Finished dev [unoptimized + debuginfo] target(s) in 0.37s
</code></pre>
<p>Seems legit to me, time to write a test!</p>
<pre><code class="language-rust ignore">#[cfg(test)]
mod test {
    use super::LinkedList;

    #[test]
    fn test_basic_front() {
        let mut list = LinkedList::new();

        // Try to break an empty list
        assert_eq!(list.len(), 0);
        assert_eq!(list.pop_front(), None);
        assert_eq!(list.len(), 0);

        // Try to break a one item list
        list.push_front(10);
        assert_eq!(list.len(), 1);
        assert_eq!(list.pop_front(), Some(10));
        assert_eq!(list.len(), 0);
        assert_eq!(list.pop_front(), None);
        assert_eq!(list.len(), 0);

        // Mess around
        list.push_front(10);
        assert_eq!(list.len(), 1);
        list.push_front(20);
        assert_eq!(list.len(), 2);
        list.push_front(30);
        assert_eq!(list.len(), 3);
        assert_eq!(list.pop_front(), Some(30));
        assert_eq!(list.len(), 2);
        list.push_front(40);
        assert_eq!(list.len(), 3);
        assert_eq!(list.pop_front(), Some(40));
        assert_eq!(list.len(), 2);
        assert_eq!(list.pop_front(), Some(20));
        assert_eq!(list.len(), 1);
        assert_eq!(list.pop_front(), Some(10));
        assert_eq!(list.len(), 0);
        assert_eq!(list.pop_front(), None);
        assert_eq!(list.len(), 0);
        assert_eq!(list.pop_front(), None);
        assert_eq!(list.len(), 0);
    }
}
</code></pre>
<pre><code class="language-text">   Compiling linked-list v0.0.3
    Finished test [unoptimized + debuginfo] target(s) in 0.40s
     Running unittests src\lib.rs

running 1 test
test test::test_basic_front ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>Hooray, we're perfect!</p>
<p>...Right?</p>
<h1><a class="header" href="#drop-and-panic-safety" id="drop-and-panic-safety">Drop and Panic Safety</a></h1>
<p>So hey, did you notice this comment:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Note that we don't need to mess around with `take` anymore
// because everything is Copy and there are no dtors that will
// run if we mess up... right? :) Riiiight? :)))
<span class="boring">}
</span></code></pre></pre>
<p>Is it right? </p>
<p>Sorry did you forget the book you're reading? Of course it's wrong! (Sort Of.)</p>
<p>Let's look at the inner body of pop_front again:</p>
<pre><code class="language-rust ignore">// Bring the Box back to life so we can move out its value and
// Drop it (Box continues to magically understand this for us).
let boxed_node = Box::from_raw(node.as_ptr());
let result = boxed_node.elem;

// Make the next node into the new front.
self.front = boxed_node.back;
if let Some(new) = self.front {
    // Cleanup its reference to the removed node
    (*new.as_ptr()).front = None;
} else {
    // If the front is now null, then this list is now empty!
    debug_assert!(self.len == 1);
    self.back = None;
}

self.len -= 1;
result
// Box gets implicitly freed here, knows there is no T.
</code></pre>
<p>Do you see the bug? Horrifyingly, it's actually this line:</p>
<pre><code class="language-rust ignore">debug_assert!(self.len == 1);
</code></pre>
<p><em>Really</em>? Our friggin' integrity check for tests is a bug?? Yes!!! Well, if we implement our collection right it <em>shouldn't</em> be, but it can turn something benign like &quot;oh we are doing a bad job of keeping len up to date&quot; into <em>An Exploitable Memory Safety Bug</em>! Why? Because it can panic! Most of the time you don't have to think or worry about panics, but once you start writing <em>really</em> unsafe code and playing fast and loose with &quot;invariants&quot;, you need to become hyper-vigilant about panics!</p>
<p>We've gotta talk about <a href="https://doc.rust-lang.org/nightly/nomicon/exception-safety.html"><em>exception safety</em></a> (AKA panic safety, AKA unwind safety, ...).</p>
<p>So here's the deal: by default, panics are <em>unwinding</em>. Unwinding is just a fancy way to say &quot;make every single function immediately return&quot;. You might think &quot;well, if <em>everyone</em> returns then the program is about to die, so why care about it?&quot;, but you'd be wrong!</p>
<p>We have to care for two reasons: destructors run when a function returns, and the unwind can be <em>caught</em>. In both cases, code can keep running after a panic, so we need to be very careful and make sure our unsafe collections are always in <em>some</em> kind of coherent state whenever a panic could occur, because each panic is an implicit early return!</p>
<p>Let's think about what state our collection is in when we get to that line:</p>
<p>We have our boxed_node on the stack, and we've extracted the element from it. If we were to return at this point, the Box would be dropped, and the node would be freed. Do you see it now..? self.back is still pointing at that freed node! Once we implement the rest of our collection and start using self.back for things, this could result in a use-after-free! Yikes!</p>
<p>Interestingly, this line has similar problems, but it's much safer:</p>
<pre><code class="language-rust ignore">self.len -= 1;
</code></pre>
<p>By default in debug builds Rust checks for underflows and overflows and will panic when they happen. Yes, every arithmetic operation is a panic-safety hazard! This one is <em>better</em> because it happens after we've repaired all of our invariants, so it won't cause memory-safety issues... as long as we don't trust len to be right, but then, if we underflow it's definitely wrong, so we were dead either way! The debug assert is in some sense <em>worse</em> because it can escalate a minor issue into a critical one!</p>
<p>I've brought up the term &quot;invariants&quot; a few times, and that's because it's a really useful concept for panic-safety! Basically, to an outside observer of our collection, there are certain property we're always upholding. For a LinkedList, one of those is that any node that is reachable in our list is still allocated and initialized.</p>
<p><em>Inside</em> the implementation we have a bit more flexibility to break invariants <em>temporarily</em> as long as we make sure to repair them <em>before anyone notices</em>. This is actually one of the &quot;killer apps&quot; of Rust's ownership and borrowing system for collections: if an operation requires an <code>&amp;mut Self</code>, then we are <em>guaranteed</em> that we have exclusive access to our collection and that it's fine for us to temporarily break invariants, safe in the knowledge that no one can sneakily mess with it.</p>
<p>Perhaps the greatest expression of this is <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.drain">Vec::drain</a>, which actually lets you completely smash a core invariant of Vec and start moving values out from the <em>front</em> or even <em>middle</em> of a Vec. The reason this is <em>sound</em> is because the Drain iterator that we return holds an <code>&amp;mut</code> to the Vec, and so all access is gated behind it! No one can observe the Vec until the Drain iterator goes away, and then it's destructor can &quot;repair&quot; the Vec before anyone can notice, it's perfe--</p>
<p><a href="https://doc.rust-lang.org/nightly/nomicon/leaking.html#drain">It's not perfect</a>. Unfortunately, you <a href="https://doc.rust-lang.org/std/mem/fn.forget.html">can't rely on destructors in code you don't control to run</a>, and so even with Drain we need to do a little extra work to make our type always preserved invariants, but in a kind of goofy way: <a href="https://doc.rust-lang.org/std/mem/fn.forget.html">we just set the Vec's len to 0 at the start</a>, so if anyone leaks the Drain, then they will have a <em>safe</em> Vec... but they will have also lost a bunch of data. You leak me? I leak you! An eye for an eye! True justice!</p>
<p>For a situation where you <em>can</em> actually use destructors for panic-safety, check out the <a href="https://doc.rust-lang.org/nightly/nomicon/exception-safety.html#binaryheapsift_up">BinaryHeap::sift_up case study</a>.</p>
<p>Anyway, we won't be needing all of this fancy stuff for our LinkedLists, we just need to be a bit more vigilant about where we break our invariants, what we trust/require to be correct, and to avoid introducing unnecessary unwinds in the middle of hairy tasks.</p>
<p>In this case, we have two options to make our code a bit more robust:</p>
<ul>
<li>
<p>Use operations like Option::take a lot more aggressively, because they are more &quot;transactional&quot; and have a tendency to preserve invariants.</p>
</li>
<li>
<p>Kill the debug_asserts and trust ourselves to write better tests with dedicated &quot;integrity check&quot; functions that won't run in user code ever.</p>
</li>
</ul>
<p>In principle I like the first option, but it doesn't actually work great for a doubly-linked list, because everything is doubly-redundantly encoded. Option::take wouldn't fix the problem here, but moving the debug_assert down a line would. But really, why make things harder for ourselves? Let's just remove those debug_asserts, and make sure anything can panic is at the start or end of our methods, where our invariants should be known to hold.</p>
<p>(In this way it's perhaps more accurate to think of them as <em>preconditions</em> and <em>postconditions</em> but you really should endeavour to treat them as invariants as much as possible!)</p>
<p>Here's our full implementation now:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::ptr::NonNull;
use std::marker::PhantomData;

pub struct LinkedList&lt;T&gt; {
    front: Link&lt;T&gt;,
    back: Link&lt;T&gt;,
    len: usize,
    _boo: PhantomData&lt;T&gt;,
}

type Link&lt;T&gt; = Option&lt;NonNull&lt;Node&lt;T&gt;&gt;&gt;;

struct Node&lt;T&gt; {
    front: Link&lt;T&gt;,
    back: Link&lt;T&gt;,
    elem: T, 
}

impl&lt;T&gt; LinkedList&lt;T&gt; {
    pub fn new() -&gt; Self {
        Self {
            front: None,
            back: None,
            len: 0,
            _boo: PhantomData,
        }
    }

    pub fn push_front(&amp;mut self, elem: T) {
        // SAFETY: it's a linked-list, what do you want?
        unsafe {
            let new = NonNull::new_unchecked(Box::into_raw(Box::new(Node {
                front: None,
                back: None,
                elem,
            })));
            if let Some(old) = self.front {
                // Put the new front before the old one
                (*old.as_ptr()).front = Some(new);
                (*new.as_ptr()).back = Some(old);
            } else {
                // If there's no front, then we're the empty list and need 
                // to set the back too.
                self.back = Some(new);
            }
            // These things always happen!
            self.front = Some(new);
            self.len += 1;
        }
    }

    pub fn pop_front(&amp;mut self) -&gt; Option&lt;T&gt; {
        unsafe {
            // Only have to do stuff if there is a front node to pop.
            self.front.map(|node| {
                // Bring the Box back to life so we can move out its value and
                // Drop it (Box continues to magically understand this for us).
                let boxed_node = Box::from_raw(node.as_ptr());
                let result = boxed_node.elem;

                // Make the next node into the new front.
                self.front = boxed_node.back;
                if let Some(new) = self.front {
                    // Cleanup its reference to the removed node
                    (*new.as_ptr()).front = None;
                } else {
                    // If the front is now null, then this list is now empty!
                    self.back = None;
                }

                self.len -= 1;
                result
                // Box gets implicitly freed here, knows there is no T.
            })
        }
    }

    pub fn len(&amp;self) -&gt; usize {
        self.len
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>What can panic here? Well, knowing that honestly requires you to be a bit of a Rust expert, but thankfully, I am!</p>
<p>The only places I can see in this code that <em>possibly</em> can panic (barring some absolute fuckery where someone recompiles the stdlib with debug_asserts enabled, but this is not something you should ever do) are <code>Box::new</code> (for out-of-memory conditions) and the len arithmetic. All of that stuff is at the very end or very start of our methods, so yep, we're being nice and safe!</p>
<p>...were you surprised by <code>Box::new</code> being able to panic? Panics will get you like that! Try to preserve those invariants so you don't need to worry about it!</p>
<h1><a class="header" href="#boring-combinatorics" id="boring-combinatorics">Boring Combinatorics</a></h1>
<p>Ok, back to our regularly scheduled linked lists!</p>
<p>First let's knock out <code>Drop</code> which is trivial with pop:</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; Drop for LinkedList&lt;T&gt; {
    fn drop(&amp;mut self) {
        // Pop until we have to stop
        while let Some(_) = self.pop_front() { }
    }
}
</code></pre>
<p>We've got to fill in a bunch of really boring combinatoric implementations like front, front_mut, back, back_mut, iter, iter_mut, into_iter, ...</p>
<p>You could do them with macros or whatever but honestly, that's a worse fate than copy-pasting. We're just going to do a lot of copy-pasting. I have <em>very carefully</em> crafted the previous push/pop implementations so that we should be able to <em>literally</em> just swap front and back and the code does/says the right thing! Hooray for painful experience! (It's so tempting to talk about &quot;prev and next&quot; for nodes, but I find it's really worth it to just consistently talk about &quot;front&quot; and &quot;back&quot; as much as possible to avoid mistakes.)</p>
<p>Alright, first up, <code>front</code>:</p>
<pre><code class="language-rust ignore">pub fn front(&amp;self) -&gt; Option&lt;&amp;T&gt; {
    unsafe {
        self.front.map(|node| &amp;(*node.as_ptr()).elem)
    }
}
</code></pre>
<p>Hey actually, this book is really old and some nice new things have been added like the <code>?</code> operator which does an early return on Option::None, does that make our code nicer?</p>
<pre><code class="language-rust ignore">pub fn front(&amp;self) -&gt; Option&lt;&amp;T&gt; {
    unsafe {
        Some(&amp;(*self.front?.as_ptr()).elem)
    }
}
</code></pre>
<p>Maybe? It's kind of a wash for something this simple, and the previous section was all about how early returns are kinda spooky for us, so maybe we should prefer being a bit more explicit here (I'm sticking to the <code>map</code> implementation).  On to front_mut:</p>
<pre><code class="language-rust ignore">pub fn front_mut(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt; {
    unsafe {
        self.front.map(|node| &amp;mut (*node.as_ptr()).elem)
    }
}
</code></pre>
<p>I'll just dump all the <code>back</code> versions at the end. </p>
<p>Next up, iterators. Unlike all of our previous lists we've <em>finally</em> unlocked the ability to do <a href="https://doc.rust-lang.org/std/iter/trait.DoubleEndedIterator.html">DoubleEndedIterator</a>, and if we're going for production quality we're gonna do <a href="https://doc.rust-lang.org/std/iter/trait.ExactSizeIterator.html">ExactSizeIterator</a> too.</p>
<p>So in addition to <code>next</code> and <code>size_hint</code>, we're going to support <code>next_back</code> and <code>len</code>.</p>
<p>The vigilant among you might notice that IterMut seems a lot more sketchy with double-ended iteration, but it's actually still sound!</p>
<p>... god this is gonna be a lot of boilerplate. Maybe I should really write a macro... no, no, that's still a worse fate.</p>
<pre><code class="language-rust ignore">pub struct Iter&lt;'a, T&gt; {
    front: Link&lt;T&gt;,
    back: Link&lt;T&gt;,
    len: usize,
    _boo: PhantomData&lt;&amp;'a T&gt;,
}

impl&lt;T&gt; LinkedList&lt;T&gt; {
    pub fn iter(&amp;self) -&gt; Iter&lt;T&gt; {
        Iter { 
            front: self.front, 
            back: self.back,
            len: self.len,
            _boo: PhantomData,
        }
    }
}


impl&lt;'a, T&gt; IntoIterator for &amp;'a LinkedList&lt;T&gt; {
    type IntoIter = Iter&lt;'a, T&gt;;
    type Item = &amp;'a T;

    fn into_iter(self) -&gt; Self::IntoIter {
        self.iter()
    }
}

impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {
    type Item = &amp;'a T;
    
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        // While self.front == self.back is a tempting condition to check here,
        // it won't do the right for yielding the last element! That sort of
        // thing only works for arrays because of &quot;one-past-the-end&quot; pointers.
        if self.len &gt; 0 {
            // We could unwrap front, but this is safer and easier
            self.front.map(|node| unsafe {
                self.len -= 1;
                self.front = (*node.as_ptr()).back;
                &amp;(*node.as_ptr()).elem
            })
        } else {
            None
        }
    }

    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) {
        (self.len, Some(self.len))
    }
}

impl&lt;'a, T&gt; DoubleEndedIterator for Iter&lt;'a, T&gt; {
    fn next_back(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        if self.len &gt; 0 {
            self.back.map(|node| unsafe {
                self.len -= 1;
                self.back = (*node.as_ptr()).front;
                &amp;(*node.as_ptr()).elem
            })
        } else {
            None
        }
    }
}

impl&lt;'a, T&gt; ExactSizeIterator for Iter&lt;'a, T&gt; {
    fn len(&amp;self) -&gt; usize {
        self.len
    }
}
</code></pre>
<p>...that's just <code>.iter()</code>...</p>
<p>we'll paste IterMut at the end, it's literally the exact same code with <code>mut</code> in a lot of places, let's just knock out <code>into_iter</code> first. We can mercifully still lean on our tried-and-true solution of just making it wrap our collection and using pop for next:</p>
<pre><code class="language-rust ignore">pub struct IntoIter&lt;T&gt; {
    list: LinkedList&lt;T&gt;,
}

impl&lt;T&gt; LinkedList&lt;T&gt; {
    pub fn into_iter(self) -&gt; IntoIter&lt;T&gt; {
        IntoIter { 
            list: self
        }
    }
}


impl&lt;T&gt; IntoIterator for LinkedList&lt;T&gt; {
    type IntoIter = IntoIter&lt;T&gt;;
    type Item = T;

    fn into_iter(self) -&gt; Self::IntoIter {
        self.into_iter()
    }
}

impl&lt;T&gt; Iterator for IntoIter&lt;T&gt; {
    type Item = T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.list.pop_front()
    }

    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) {
        (self.list.len, Some(self.list.len))
    }
}

impl&lt;T&gt; DoubleEndedIterator for IntoIter&lt;T&gt; {
    fn next_back(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.list.pop_back()
    }
}

impl&lt;T&gt; ExactSizeIterator for IntoIter&lt;T&gt; {
    fn len(&amp;self) -&gt; usize {
        self.list.len
    }
}
</code></pre>
<p>Still a crapload of boiler plate, but at least it's <em>satisfying</em> boilerplate.</p>
<p>Alright, here's all of our code with all the combinatorics filled in:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::ptr::NonNull;
use std::marker::PhantomData;

pub struct LinkedList&lt;T&gt; {
    front: Link&lt;T&gt;,
    back: Link&lt;T&gt;,
    len: usize,
    _boo: PhantomData&lt;T&gt;,
}

type Link&lt;T&gt; = Option&lt;NonNull&lt;Node&lt;T&gt;&gt;&gt;;

struct Node&lt;T&gt; {
    front: Link&lt;T&gt;,
    back: Link&lt;T&gt;,
    elem: T, 
}

pub struct Iter&lt;'a, T&gt; {
    front: Link&lt;T&gt;,
    back: Link&lt;T&gt;,
    len: usize,
    _boo: PhantomData&lt;&amp;'a T&gt;,
}

pub struct IterMut&lt;'a, T&gt; {
    front: Link&lt;T&gt;,
    back: Link&lt;T&gt;,
    len: usize,
    _boo: PhantomData&lt;&amp;'a mut T&gt;,
}

pub struct IntoIter&lt;T&gt; {
    list: LinkedList&lt;T&gt;,
}

impl&lt;T&gt; LinkedList&lt;T&gt; {
    pub fn new() -&gt; Self {
        Self {
            front: None,
            back: None,
            len: 0,
            _boo: PhantomData,
        }
    }

    pub fn push_front(&amp;mut self, elem: T) {
        // SAFETY: it's a linked-list, what do you want?
        unsafe {
            let new = NonNull::new_unchecked(Box::into_raw(Box::new(Node {
                front: None,
                back: None,
                elem,
            })));
            if let Some(old) = self.front {
                // Put the new front before the old one
                (*old.as_ptr()).front = Some(new);
                (*new.as_ptr()).back = Some(old);
            } else {
                // If there's no front, then we're the empty list and need 
                // to set the back too.
                self.back = Some(new);
            }
            // These things always happen!
            self.front = Some(new);
            self.len += 1;
        }
    }

    pub fn push_back(&amp;mut self, elem: T) {
        // SAFETY: it's a linked-list, what do you want?
        unsafe {
            let new = NonNull::new_unchecked(Box::into_raw(Box::new(Node {
                back: None,
                front: None,
                elem,
            })));
            if let Some(old) = self.back {
                // Put the new back before the old one
                (*old.as_ptr()).back = Some(new);
                (*new.as_ptr()).front = Some(old);
            } else {
                // If there's no back, then we're the empty list and need 
                // to set the front too.
                self.front = Some(new);
            }
            // These things always happen!
            self.back = Some(new);
            self.len += 1;
        }
    }

    pub fn pop_front(&amp;mut self) -&gt; Option&lt;T&gt; {
        unsafe {
            // Only have to do stuff if there is a front node to pop.
            self.front.map(|node| {
                // Bring the Box back to life so we can move out its value and
                // Drop it (Box continues to magically understand this for us).
                let boxed_node = Box::from_raw(node.as_ptr());
                let result = boxed_node.elem;

                // Make the next node into the new front.
                self.front = boxed_node.back;
                if let Some(new) = self.front {
                    // Cleanup its reference to the removed node
                    (*new.as_ptr()).front = None;
                } else {
                    // If the front is now null, then this list is now empty!
                    self.back = None;
                }

                self.len -= 1;
                result
                // Box gets implicitly freed here, knows there is no T.
            })
        }
    }

    pub fn pop_back(&amp;mut self) -&gt; Option&lt;T&gt; {
        unsafe {
            // Only have to do stuff if there is a back node to pop.
            self.back.map(|node| {
                // Bring the Box front to life so we can move out its value and
                // Drop it (Box continues to magically understand this for us).
                let boxed_node = Box::from_raw(node.as_ptr());
                let result = boxed_node.elem;

                // Make the next node into the new back.
                self.back = boxed_node.front;
                if let Some(new) = self.back {
                    // Cleanup its reference to the removed node
                    (*new.as_ptr()).back = None;
                } else {
                    // If the back is now null, then this list is now empty!
                    self.front = None;
                }

                self.len -= 1;
                result
                // Box gets implicitly freed here, knows there is no T.
            })
        }
    }

    pub fn front(&amp;self) -&gt; Option&lt;&amp;T&gt; {
        unsafe {
            self.front.map(|node| &amp;(*node.as_ptr()).elem)
        }
    }

    pub fn front_mut(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt; {
        unsafe {
            self.front.map(|node| &amp;mut (*node.as_ptr()).elem)
        }
    }

    pub fn back(&amp;self) -&gt; Option&lt;&amp;T&gt; {
        unsafe {
            self.back.map(|node| &amp;(*node.as_ptr()).elem)
        }
    }

    pub fn back_mut(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt; {
        unsafe {
            self.back.map(|node| &amp;mut (*node.as_ptr()).elem)
        }
    }

    pub fn len(&amp;self) -&gt; usize {
        self.len
    }

    pub fn iter(&amp;self) -&gt; Iter&lt;T&gt; {
        Iter { 
            front: self.front, 
            back: self.back,
            len: self.len,
            _boo: PhantomData,
        }
    }

    pub fn iter_mut(&amp;mut self) -&gt; IterMut&lt;T&gt; {
        IterMut { 
            front: self.front, 
            back: self.back,
            len: self.len,
            _boo: PhantomData,
        }
    }

    pub fn into_iter(self) -&gt; IntoIter&lt;T&gt; {
        IntoIter { 
            list: self
        }
    }
}

impl&lt;T&gt; Drop for LinkedList&lt;T&gt; {
    fn drop(&amp;mut self) {
        // Pop until we have to stop
        while let Some(_) = self.pop_front() { }
    }
}

impl&lt;'a, T&gt; IntoIterator for &amp;'a LinkedList&lt;T&gt; {
    type IntoIter = Iter&lt;'a, T&gt;;
    type Item = &amp;'a T;

    fn into_iter(self) -&gt; Self::IntoIter {
        self.iter()
    }
}

impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {
    type Item = &amp;'a T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        // While self.front == self.back is a tempting condition to check here,
        // it won't do the right for yielding the last element! That sort of
        // thing only works for arrays because of &quot;one-past-the-end&quot; pointers.
        if self.len &gt; 0 {
            // We could unwrap front, but this is safer and easier
            self.front.map(|node| unsafe {
                self.len -= 1;
                self.front = (*node.as_ptr()).back;
                &amp;(*node.as_ptr()).elem
            })
        } else {
            None
        }
    }

    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) {
        (self.len, Some(self.len))
    }
}

impl&lt;'a, T&gt; DoubleEndedIterator for Iter&lt;'a, T&gt; {
    fn next_back(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        if self.len &gt; 0 {
            self.back.map(|node| unsafe {
                self.len -= 1;
                self.back = (*node.as_ptr()).front;
                &amp;(*node.as_ptr()).elem
            })
        } else {
            None
        }
    }
}

impl&lt;'a, T&gt; ExactSizeIterator for Iter&lt;'a, T&gt; {
    fn len(&amp;self) -&gt; usize {
        self.len
    }
}

impl&lt;'a, T&gt; IntoIterator for &amp;'a mut LinkedList&lt;T&gt; {
    type IntoIter = IterMut&lt;'a, T&gt;;
    type Item = &amp;'a mut T;

    fn into_iter(self) -&gt; Self::IntoIter {
        self.iter_mut()
    }
}

impl&lt;'a, T&gt; Iterator for IterMut&lt;'a, T&gt; {
    type Item = &amp;'a mut T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        // While self.front == self.back is a tempting condition to check here,
        // it won't do the right for yielding the last element! That sort of
        // thing only works for arrays because of &quot;one-past-the-end&quot; pointers.
        if self.len &gt; 0 {
            // We could unwrap front, but this is safer and easier
            self.front.map(|node| unsafe {
                self.len -= 1;
                self.front = (*node.as_ptr()).back;
                &amp;mut (*node.as_ptr()).elem
            })
        } else {
            None
        }
    }

    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) {
        (self.len, Some(self.len))
    }
}

impl&lt;'a, T&gt; DoubleEndedIterator for IterMut&lt;'a, T&gt; {
    fn next_back(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        if self.len &gt; 0 {
            self.back.map(|node| unsafe {
                self.len -= 1;
                self.back = (*node.as_ptr()).front;
                &amp;mut (*node.as_ptr()).elem
            })
        } else {
            None
        }
    }
}

impl&lt;'a, T&gt; ExactSizeIterator for IterMut&lt;'a, T&gt; {
    fn len(&amp;self) -&gt; usize {
        self.len
    }
}

impl&lt;T&gt; IntoIterator for LinkedList&lt;T&gt; {
    type IntoIter = IntoIter&lt;T&gt;;
    type Item = T;

    fn into_iter(self) -&gt; Self::IntoIter {
        self.into_iter()
    }
}

impl&lt;T&gt; Iterator for IntoIter&lt;T&gt; {
    type Item = T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.list.pop_front()
    }

    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) {
        (self.list.len, Some(self.list.len))
    }
}

impl&lt;T&gt; DoubleEndedIterator for IntoIter&lt;T&gt; {
    fn next_back(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.list.pop_back()
    }
}

impl&lt;T&gt; ExactSizeIterator for IntoIter&lt;T&gt; {
    fn len(&amp;self) -&gt; usize {
        self.list.len
    }
}


#[cfg(test)]
mod test {
    use super::LinkedList;

    #[test]
    fn test_basic_front() {
        let mut list = LinkedList::new();

        // Try to break an empty list
        assert_eq!(list.len(), 0);
        assert_eq!(list.pop_front(), None);
        assert_eq!(list.len(), 0);

        // Try to break a one item list
        list.push_front(10);
        assert_eq!(list.len(), 1);
        assert_eq!(list.pop_front(), Some(10));
        assert_eq!(list.len(), 0);
        assert_eq!(list.pop_front(), None);
        assert_eq!(list.len(), 0);

        // Mess around
        list.push_front(10);
        assert_eq!(list.len(), 1);
        list.push_front(20);
        assert_eq!(list.len(), 2);
        list.push_front(30);
        assert_eq!(list.len(), 3);
        assert_eq!(list.pop_front(), Some(30));
        assert_eq!(list.len(), 2);
        list.push_front(40);
        assert_eq!(list.len(), 3);
        assert_eq!(list.pop_front(), Some(40));
        assert_eq!(list.len(), 2);
        assert_eq!(list.pop_front(), Some(20));
        assert_eq!(list.len(), 1);
        assert_eq!(list.pop_front(), Some(10));
        assert_eq!(list.len(), 0);
        assert_eq!(list.pop_front(), None);
        assert_eq!(list.len(), 0);
        assert_eq!(list.pop_front(), None);
        assert_eq!(list.len(), 0);
    }
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#filling-in-random-bits" id="filling-in-random-bits">Filling In Random Bits</a></h1>
<p>Hey you said you wanted to be production-quality, didn't you? </p>
<p>Here's some more random gunk to toss in to be a &quot;good&quot; collection:</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; LinkedList&lt;T&gt; {
    pub fn is_empty(&amp;self) -&gt; bool {
        self.len == 0
    }

    pub fn clear(&amp;mut self) {
        // Oh look it's drop again
        while let Some(_) = self.pop_front() { }
    }
}
</code></pre>
<p>And now we've got a bunch of traits to implement that everyone expects:</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; Default for LinkedList&lt;T&gt; {
    fn default() -&gt; Self {
        Self::new()
    }
}

impl&lt;T: Clone&gt; Clone for LinkedList&lt;T&gt; {
    fn clone(&amp;self) -&gt; Self {
        let mut new_list = Self::new();
        for item in self {
            new_list.push_back(item.clone());
        }
        new_list
    }
}

impl&lt;T&gt; Extend&lt;T&gt; for LinkedList&lt;T&gt; {
    fn extend&lt;I: IntoIterator&lt;Item = T&gt;&gt;(&amp;mut self, iter: I) {
        for item in iter {
            self.push_back(item);
        }
    }
}

impl&lt;T&gt; FromIterator&lt;T&gt; for LinkedList&lt;T&gt; {
    fn from_iter&lt;I: IntoIterator&lt;Item = T&gt;&gt;(iter: I) -&gt; Self {
        let mut list = Self::new();
        list.extend(iter);
        list
    }
}

impl&lt;T: Debug&gt; Debug for LinkedList&lt;T&gt; {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        f.debug_list().entries(self).finish()
    }
}

impl&lt;T: PartialEq&gt; PartialEq for LinkedList&lt;T&gt; {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool {
        self.len() == other.len() &amp;&amp; self.iter().eq(other)
    }

    fn ne(&amp;self, other: &amp;Self) -&gt; bool {
        self.len() != other.len() || self.iter().ne(other)
    }
}

impl&lt;T: Eq&gt; Eq for LinkedList&lt;T&gt; { }

impl&lt;T: PartialOrd&gt; PartialOrd for LinkedList&lt;T&gt; {
    fn partial_cmp(&amp;self, other: &amp;Self) -&gt; Option&lt;Ordering&gt; {
        self.iter().partial_cmp(other)
    }
}

impl&lt;T: Ord&gt; Ord for LinkedList&lt;T&gt; {
    fn cmp(&amp;self, other: &amp;Self) -&gt; Ordering {
        self.iter().cmp(other)
    }
}

impl&lt;T: Hash&gt; Hash for LinkedList&lt;T&gt; {
    fn hash&lt;H: Hasher&gt;(&amp;self, state: &amp;mut H) {
        self.len().hash(state);
        for item in self {
            item.hash(state);
        }
    }
}
</code></pre>
<p>I definitely wrote all of these from scratch, and didn't just copy the std impls. Because they're so interesting, and I definitely remember the subtleties of manually implementing Hash. Yeah, that's something I think about All The Time...</p>
<p>Ok there's actually a few things worth noting here.</p>
<p>First, a nasty namespace clash. For whatever reason std now has macros named Hash and Debug, and so if you don't have the traits imported, you'll get really cryptic errors about macros instead of the proper &quot;missing trait&quot;.</p>
<p>The other intersting thing to talk about is Hash itself. Do you see how we hash in <code>len</code>? That's actually really important! If collections don't hash in lengths, <a href="https://doc.rust-lang.org/std/hash/trait.Hash.html#prefix-collisions">they can accidentally make themselves vulnerable to prefix collisions</a>. For instance, what distinguishes <code>[&quot;he&quot;, &quot;llo&quot;]</code> from <code>[&quot;hello&quot;]</code>? If no one is hashing lengths or some other &quot;separator&quot;, nothing! Making it too easy for hash collisions to accidentally or maliciously happen can result in serious sadness, so just do it!</p>
<p>Alright, here's our current code:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cmp::Ordering;
use std::fmt::{self, Debug};
use std::hash::{Hash, Hasher};
use std::iter::FromIterator;
use std::ptr::NonNull;
use std::marker::PhantomData;

pub struct LinkedList&lt;T&gt; {
    front: Link&lt;T&gt;,
    back: Link&lt;T&gt;,
    len: usize,
    _boo: PhantomData&lt;T&gt;,
}

type Link&lt;T&gt; = Option&lt;NonNull&lt;Node&lt;T&gt;&gt;&gt;;

struct Node&lt;T&gt; {
    front: Link&lt;T&gt;,
    back: Link&lt;T&gt;,
    elem: T, 
}

pub struct Iter&lt;'a, T&gt; {
    front: Link&lt;T&gt;,
    back: Link&lt;T&gt;,
    len: usize,
    _boo: PhantomData&lt;&amp;'a T&gt;,
}

pub struct IterMut&lt;'a, T&gt; {
    front: Link&lt;T&gt;,
    back: Link&lt;T&gt;,
    len: usize,
    _boo: PhantomData&lt;&amp;'a mut T&gt;,
}

pub struct IntoIter&lt;T&gt; {
    list: LinkedList&lt;T&gt;,
}

impl&lt;T&gt; LinkedList&lt;T&gt; {
    pub fn new() -&gt; Self {
        Self {
            front: None,
            back: None,
            len: 0,
            _boo: PhantomData,
        }
    }

    pub fn push_front(&amp;mut self, elem: T) {
        // SAFETY: it's a linked-list, what do you want?
        unsafe {
            let new = NonNull::new_unchecked(Box::into_raw(Box::new(Node {
                front: None,
                back: None,
                elem,
            })));
            if let Some(old) = self.front {
                // Put the new front before the old one
                (*old.as_ptr()).front = Some(new);
                (*new.as_ptr()).back = Some(old);
            } else {
                // If there's no front, then we're the empty list and need 
                // to set the back too.
                self.back = Some(new);
            }
            // These things always happen!
            self.front = Some(new);
            self.len += 1;
        }
    }

    pub fn push_back(&amp;mut self, elem: T) {
        // SAFETY: it's a linked-list, what do you want?
        unsafe {
            let new = NonNull::new_unchecked(Box::into_raw(Box::new(Node {
                back: None,
                front: None,
                elem,
            })));
            if let Some(old) = self.back {
                // Put the new back before the old one
                (*old.as_ptr()).back = Some(new);
                (*new.as_ptr()).front = Some(old);
            } else {
                // If there's no back, then we're the empty list and need 
                // to set the front too.
                self.front = Some(new);
            }
            // These things always happen!
            self.back = Some(new);
            self.len += 1;
        }
    }

    pub fn pop_front(&amp;mut self) -&gt; Option&lt;T&gt; {
        unsafe {
            // Only have to do stuff if there is a front node to pop.
            self.front.map(|node| {
                // Bring the Box back to life so we can move out its value and
                // Drop it (Box continues to magically understand this for us).
                let boxed_node = Box::from_raw(node.as_ptr());
                let result = boxed_node.elem;

                // Make the next node into the new front.
                self.front = boxed_node.back;
                if let Some(new) = self.front {
                    // Cleanup its reference to the removed node
                    (*new.as_ptr()).front = None;
                } else {
                    // If the front is now null, then this list is now empty!
                    self.back = None;
                }

                self.len -= 1;
                result
                // Box gets implicitly freed here, knows there is no T.
            })
        }
    }

    pub fn pop_back(&amp;mut self) -&gt; Option&lt;T&gt; {
        unsafe {
            // Only have to do stuff if there is a back node to pop.
            self.back.map(|node| {
                // Bring the Box front to life so we can move out its value and
                // Drop it (Box continues to magically understand this for us).
                let boxed_node = Box::from_raw(node.as_ptr());
                let result = boxed_node.elem;

                // Make the next node into the new back.
                self.back = boxed_node.front;
                if let Some(new) = self.back {
                    // Cleanup its reference to the removed node
                    (*new.as_ptr()).back = None;
                } else {
                    // If the back is now null, then this list is now empty!
                    self.front = None;
                }

                self.len -= 1;
                result
                // Box gets implicitly freed here, knows there is no T.
            })
        }
    }

    pub fn front(&amp;self) -&gt; Option&lt;&amp;T&gt; {
        unsafe {
            self.front.map(|node| &amp;(*node.as_ptr()).elem)
        }
    }

    pub fn front_mut(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt; {
        unsafe {
            self.front.map(|node| &amp;mut (*node.as_ptr()).elem)
        }
    }

    pub fn back(&amp;self) -&gt; Option&lt;&amp;T&gt; {
        unsafe {
            self.back.map(|node| &amp;(*node.as_ptr()).elem)
        }
    }

    pub fn back_mut(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt; {
        unsafe {
            self.back.map(|node| &amp;mut (*node.as_ptr()).elem)
        }
    }

    pub fn len(&amp;self) -&gt; usize {
        self.len
    }

    pub fn is_empty(&amp;self) -&gt; bool {
        self.len == 0
    }

    pub fn clear(&amp;mut self) {
        // Oh look it's drop again
        while let Some(_) = self.pop_front() { }
    }

    pub fn iter(&amp;self) -&gt; Iter&lt;T&gt; {
        Iter { 
            front: self.front, 
            back: self.back,
            len: self.len,
            _boo: PhantomData,
        }
    }

    pub fn iter_mut(&amp;mut self) -&gt; IterMut&lt;T&gt; {
        IterMut { 
            front: self.front, 
            back: self.back,
            len: self.len,
            _boo: PhantomData,
        }
    }

    pub fn into_iter(self) -&gt; IntoIter&lt;T&gt; {
        IntoIter { 
            list: self
        }
    }
}

impl&lt;T&gt; Drop for LinkedList&lt;T&gt; {
    fn drop(&amp;mut self) {
        // Pop until we have to stop
        while let Some(_) = self.pop_front() { }
    }
}

impl&lt;T&gt; Default for LinkedList&lt;T&gt; {
    fn default() -&gt; Self {
        Self::new()
    }
}

impl&lt;T: Clone&gt; Clone for LinkedList&lt;T&gt; {
    fn clone(&amp;self) -&gt; Self {
        let mut new_list = Self::new();
        for item in self {
            new_list.push_back(item.clone());
        }
        new_list
    }
}

impl&lt;T&gt; Extend&lt;T&gt; for LinkedList&lt;T&gt; {
    fn extend&lt;I: IntoIterator&lt;Item = T&gt;&gt;(&amp;mut self, iter: I) {
        for item in iter {
            self.push_back(item);
        }
    }
}

impl&lt;T&gt; FromIterator&lt;T&gt; for LinkedList&lt;T&gt; {
    fn from_iter&lt;I: IntoIterator&lt;Item = T&gt;&gt;(iter: I) -&gt; Self {
        let mut list = Self::new();
        list.extend(iter);
        list
    }
}

impl&lt;T: Debug&gt; Debug for LinkedList&lt;T&gt; {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        f.debug_list().entries(self).finish()
    }
}

impl&lt;T: PartialEq&gt; PartialEq for LinkedList&lt;T&gt; {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool {
        self.len() == other.len() &amp;&amp; self.iter().eq(other)
    }

    fn ne(&amp;self, other: &amp;Self) -&gt; bool {
        self.len() != other.len() || self.iter().ne(other)
    }
}

impl&lt;T: Eq&gt; Eq for LinkedList&lt;T&gt; { }

impl&lt;T: PartialOrd&gt; PartialOrd for LinkedList&lt;T&gt; {
    fn partial_cmp(&amp;self, other: &amp;Self) -&gt; Option&lt;Ordering&gt; {
        self.iter().partial_cmp(other)
    }
}

impl&lt;T: Ord&gt; Ord for LinkedList&lt;T&gt; {
    fn cmp(&amp;self, other: &amp;Self) -&gt; Ordering {
        self.iter().cmp(other)
    }
}

impl&lt;T: Hash&gt; Hash for LinkedList&lt;T&gt; {
    fn hash&lt;H: Hasher&gt;(&amp;self, state: &amp;mut H) {
        self.len().hash(state);
        for item in self {
            item.hash(state);
        }
    }
}

impl&lt;'a, T&gt; IntoIterator for &amp;'a LinkedList&lt;T&gt; {
    type IntoIter = Iter&lt;'a, T&gt;;
    type Item = &amp;'a T;

    fn into_iter(self) -&gt; Self::IntoIter {
        self.iter()
    }
}

impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {
    type Item = &amp;'a T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        // While self.front == self.back is a tempting condition to check here,
        // it won't do the right for yielding the last element! That sort of
        // thing only works for arrays because of &quot;one-past-the-end&quot; pointers.
        if self.len &gt; 0 {
            // We could unwrap front, but this is safer and easier
            self.front.map(|node| unsafe {
                self.len -= 1;
                self.front = (*node.as_ptr()).back;
                &amp;(*node.as_ptr()).elem
            })
        } else {
            None
        }
    }

    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) {
        (self.len, Some(self.len))
    }
}

impl&lt;'a, T&gt; DoubleEndedIterator for Iter&lt;'a, T&gt; {
    fn next_back(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        if self.len &gt; 0 {
            self.back.map(|node| unsafe {
                self.len -= 1;
                self.back = (*node.as_ptr()).front;
                &amp;(*node.as_ptr()).elem
            })
        } else {
            None
        }
    }
}

impl&lt;'a, T&gt; ExactSizeIterator for Iter&lt;'a, T&gt; {
    fn len(&amp;self) -&gt; usize {
        self.len
    }
}

impl&lt;'a, T&gt; IntoIterator for &amp;'a mut LinkedList&lt;T&gt; {
    type IntoIter = IterMut&lt;'a, T&gt;;
    type Item = &amp;'a mut T;

    fn into_iter(self) -&gt; Self::IntoIter {
        self.iter_mut()
    }
}

impl&lt;'a, T&gt; Iterator for IterMut&lt;'a, T&gt; {
    type Item = &amp;'a mut T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        // While self.front == self.back is a tempting condition to check here,
        // it won't do the right for yielding the last element! That sort of
        // thing only works for arrays because of &quot;one-past-the-end&quot; pointers.
        if self.len &gt; 0 {
            // We could unwrap front, but this is safer and easier
            self.front.map(|node| unsafe {
                self.len -= 1;
                self.front = (*node.as_ptr()).back;
                &amp;mut (*node.as_ptr()).elem
            })
        } else {
            None
        }
    }

    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) {
        (self.len, Some(self.len))
    }
}

impl&lt;'a, T&gt; DoubleEndedIterator for IterMut&lt;'a, T&gt; {
    fn next_back(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        if self.len &gt; 0 {
            self.back.map(|node| unsafe {
                self.len -= 1;
                self.back = (*node.as_ptr()).front;
                &amp;mut (*node.as_ptr()).elem
            })
        } else {
            None
        }
    }
}

impl&lt;'a, T&gt; ExactSizeIterator for IterMut&lt;'a, T&gt; {
    fn len(&amp;self) -&gt; usize {
        self.len
    }
}

impl&lt;T&gt; IntoIterator for LinkedList&lt;T&gt; {
    type IntoIter = IntoIter&lt;T&gt;;
    type Item = T;

    fn into_iter(self) -&gt; Self::IntoIter {
        self.into_iter()
    }
}

impl&lt;T&gt; Iterator for IntoIter&lt;T&gt; {
    type Item = T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.list.pop_front()
    }

    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) {
        (self.list.len, Some(self.list.len))
    }
}

impl&lt;T&gt; DoubleEndedIterator for IntoIter&lt;T&gt; {
    fn next_back(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.list.pop_back()
    }
}

impl&lt;T&gt; ExactSizeIterator for IntoIter&lt;T&gt; {
    fn len(&amp;self) -&gt; usize {
        self.list.len
    }
}


#[cfg(test)]
mod test {
    use super::LinkedList;

    #[test]
    fn test_basic_front() {
        let mut list = LinkedList::new();

        // Try to break an empty list
        assert_eq!(list.len(), 0);
        assert_eq!(list.pop_front(), None);
        assert_eq!(list.len(), 0);

        // Try to break a one item list
        list.push_front(10);
        assert_eq!(list.len(), 1);
        assert_eq!(list.pop_front(), Some(10));
        assert_eq!(list.len(), 0);
        assert_eq!(list.pop_front(), None);
        assert_eq!(list.len(), 0);

        // Mess around
        list.push_front(10);
        assert_eq!(list.len(), 1);
        list.push_front(20);
        assert_eq!(list.len(), 2);
        list.push_front(30);
        assert_eq!(list.len(), 3);
        assert_eq!(list.pop_front(), Some(30));
        assert_eq!(list.len(), 2);
        list.push_front(40);
        assert_eq!(list.len(), 3);
        assert_eq!(list.pop_front(), Some(40));
        assert_eq!(list.len(), 2);
        assert_eq!(list.pop_front(), Some(20));
        assert_eq!(list.len(), 1);
        assert_eq!(list.pop_front(), Some(10));
        assert_eq!(list.len(), 0);
        assert_eq!(list.pop_front(), None);
        assert_eq!(list.len(), 0);
        assert_eq!(list.pop_front(), None);
        assert_eq!(list.len(), 0);
    }
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#testing-1" id="testing-1">Testing</a></h1>
<p>Alright I put off testing for a while because well, we both know that we're now masters of Rust and we don't make mistakes anymore! Also just, this is a rewrite of an old crate, so I just have all the tests already. They're tests, you've seen tests a lot already. Here they are:</p>
<pre><code class="language-rust ignore">#[cfg(test)]
mod test {
    use super::LinkedList;

    fn generate_test() -&gt; LinkedList&lt;i32&gt; {
        list_from(&amp;[0, 1, 2, 3, 4, 5, 6])
    }

    fn list_from&lt;T: Clone&gt;(v: &amp;[T]) -&gt; LinkedList&lt;T&gt; {
        v.iter().map(|x| (*x).clone()).collect()
    }

    #[test]
    fn test_basic_front() {
        let mut list = LinkedList::new();

        // Try to break an empty list
        assert_eq!(list.len(), 0);
        assert_eq!(list.pop_front(), None);
        assert_eq!(list.len(), 0);

        // Try to break a one item list
        list.push_front(10);
        assert_eq!(list.len(), 1);
        assert_eq!(list.pop_front(), Some(10));
        assert_eq!(list.len(), 0);
        assert_eq!(list.pop_front(), None);
        assert_eq!(list.len(), 0);

        // Mess around
        list.push_front(10);
        assert_eq!(list.len(), 1);
        list.push_front(20);
        assert_eq!(list.len(), 2);
        list.push_front(30);
        assert_eq!(list.len(), 3);
        assert_eq!(list.pop_front(), Some(30));
        assert_eq!(list.len(), 2);
        list.push_front(40);
        assert_eq!(list.len(), 3);
        assert_eq!(list.pop_front(), Some(40));
        assert_eq!(list.len(), 2);
        assert_eq!(list.pop_front(), Some(20));
        assert_eq!(list.len(), 1);
        assert_eq!(list.pop_front(), Some(10));
        assert_eq!(list.len(), 0);
        assert_eq!(list.pop_front(), None);
        assert_eq!(list.len(), 0);
        assert_eq!(list.pop_front(), None);
        assert_eq!(list.len(), 0);
    }

    #[test]
    fn test_basic() {
        let mut m = LinkedList::new();
        assert_eq!(m.pop_front(), None);
        assert_eq!(m.pop_back(), None);
        assert_eq!(m.pop_front(), None);
        m.push_front(1);
        assert_eq!(m.pop_front(), Some(1));
        m.push_back(2);
        m.push_back(3);
        assert_eq!(m.len(), 2);
        assert_eq!(m.pop_front(), Some(2));
        assert_eq!(m.pop_front(), Some(3));
        assert_eq!(m.len(), 0);
        assert_eq!(m.pop_front(), None);
        m.push_back(1);
        m.push_back(3);
        m.push_back(5);
        m.push_back(7);
        assert_eq!(m.pop_front(), Some(1));

        let mut n = LinkedList::new();
        n.push_front(2);
        n.push_front(3);
        {
            assert_eq!(n.front().unwrap(), &amp;3);
            let x = n.front_mut().unwrap();
            assert_eq!(*x, 3);
            *x = 0;
        }
        {
            assert_eq!(n.back().unwrap(), &amp;2);
            let y = n.back_mut().unwrap();
            assert_eq!(*y, 2);
            *y = 1;
        }
        assert_eq!(n.pop_front(), Some(0));
        assert_eq!(n.pop_front(), Some(1));
    }

    #[test]
    fn test_iterator() {
        let m = generate_test();
        for (i, elt) in m.iter().enumerate() {
            assert_eq!(i as i32, *elt);
        }
        let mut n = LinkedList::new();
        assert_eq!(n.iter().next(), None);
        n.push_front(4);
        let mut it = n.iter();
        assert_eq!(it.size_hint(), (1, Some(1)));
        assert_eq!(it.next().unwrap(), &amp;4);
        assert_eq!(it.size_hint(), (0, Some(0)));
        assert_eq!(it.next(), None);
    }

    #[test]
    fn test_iterator_double_end() {
        let mut n = LinkedList::new();
        assert_eq!(n.iter().next(), None);
        n.push_front(4);
        n.push_front(5);
        n.push_front(6);
        let mut it = n.iter();
        assert_eq!(it.size_hint(), (3, Some(3)));
        assert_eq!(it.next().unwrap(), &amp;6);
        assert_eq!(it.size_hint(), (2, Some(2)));
        assert_eq!(it.next_back().unwrap(), &amp;4);
        assert_eq!(it.size_hint(), (1, Some(1)));
        assert_eq!(it.next_back().unwrap(), &amp;5);
        assert_eq!(it.next_back(), None);
        assert_eq!(it.next(), None);
    }

    #[test]
    fn test_rev_iter() {
        let m = generate_test();
        for (i, elt) in m.iter().rev().enumerate() {
            assert_eq!(6 - i as i32, *elt);
        }
        let mut n = LinkedList::new();
        assert_eq!(n.iter().rev().next(), None);
        n.push_front(4);
        let mut it = n.iter().rev();
        assert_eq!(it.size_hint(), (1, Some(1)));
        assert_eq!(it.next().unwrap(), &amp;4);
        assert_eq!(it.size_hint(), (0, Some(0)));
        assert_eq!(it.next(), None);
    }

    #[test]
    fn test_mut_iter() {
        let mut m = generate_test();
        let mut len = m.len();
        for (i, elt) in m.iter_mut().enumerate() {
            assert_eq!(i as i32, *elt);
            len -= 1;
        }
        assert_eq!(len, 0);
        let mut n = LinkedList::new();
        assert!(n.iter_mut().next().is_none());
        n.push_front(4);
        n.push_back(5);
        let mut it = n.iter_mut();
        assert_eq!(it.size_hint(), (2, Some(2)));
        assert!(it.next().is_some());
        assert!(it.next().is_some());
        assert_eq!(it.size_hint(), (0, Some(0)));
        assert!(it.next().is_none());
    }

    #[test]
    fn test_iterator_mut_double_end() {
        let mut n = LinkedList::new();
        assert!(n.iter_mut().next_back().is_none());
        n.push_front(4);
        n.push_front(5);
        n.push_front(6);
        let mut it = n.iter_mut();
        assert_eq!(it.size_hint(), (3, Some(3)));
        assert_eq!(*it.next().unwrap(), 6);
        assert_eq!(it.size_hint(), (2, Some(2)));
        assert_eq!(*it.next_back().unwrap(), 4);
        assert_eq!(it.size_hint(), (1, Some(1)));
        assert_eq!(*it.next_back().unwrap(), 5);
        assert!(it.next_back().is_none());
        assert!(it.next().is_none());
    }

    #[test]
    fn test_eq() {
        let mut n: LinkedList&lt;u8&gt; = list_from(&amp;[]);
        let mut m = list_from(&amp;[]);
        assert!(n == m);
        n.push_front(1);
        assert!(n != m);
        m.push_back(1);
        assert!(n == m);

        let n = list_from(&amp;[2, 3, 4]);
        let m = list_from(&amp;[1, 2, 3]);
        assert!(n != m);
    }

    #[test]
    fn test_ord() {
        let n = list_from(&amp;[]);
        let m = list_from(&amp;[1, 2, 3]);
        assert!(n &lt; m);
        assert!(m &gt; n);
        assert!(n &lt;= n);
        assert!(n &gt;= n);
    }

    #[test]
    fn test_ord_nan() {
        let nan = 0.0f64 / 0.0;
        let n = list_from(&amp;[nan]);
        let m = list_from(&amp;[nan]);
        assert!(!(n &lt; m));
        assert!(!(n &gt; m));
        assert!(!(n &lt;= m));
        assert!(!(n &gt;= m));

        let n = list_from(&amp;[nan]);
        let one = list_from(&amp;[1.0f64]);
        assert!(!(n &lt; one));
        assert!(!(n &gt; one));
        assert!(!(n &lt;= one));
        assert!(!(n &gt;= one));

        let u = list_from(&amp;[1.0f64, 2.0, nan]);
        let v = list_from(&amp;[1.0f64, 2.0, 3.0]);
        assert!(!(u &lt; v));
        assert!(!(u &gt; v));
        assert!(!(u &lt;= v));
        assert!(!(u &gt;= v));

        let s = list_from(&amp;[1.0f64, 2.0, 4.0, 2.0]);
        let t = list_from(&amp;[1.0f64, 2.0, 3.0, 2.0]);
        assert!(!(s &lt; t));
        assert!(s &gt; one);
        assert!(!(s &lt;= one));
        assert!(s &gt;= one);
    }

    #[test]
    fn test_debug() {
        let list: LinkedList&lt;i32&gt; = (0..10).collect();
        assert_eq!(format!(&quot;{:?}&quot;, list), &quot;[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]&quot;);

        let list: LinkedList&lt;&amp;str&gt; = vec![&quot;just&quot;, &quot;one&quot;, &quot;test&quot;, &quot;more&quot;]
            .iter().copied()
            .collect();
        assert_eq!(format!(&quot;{:?}&quot;, list), r#&quot;[&quot;just&quot;, &quot;one&quot;, &quot;test&quot;, &quot;more&quot;]&quot;#);
    }

    #[test]
    fn test_hashmap() {
        // Check that HashMap works with this as a key

        let list1: LinkedList&lt;i32&gt; = (0..10).collect();
        let list2: LinkedList&lt;i32&gt; = (1..11).collect();
        let mut map = std::collections::HashMap::new();

        assert_eq!(map.insert(list1.clone(), &quot;list1&quot;), None);
        assert_eq!(map.insert(list2.clone(), &quot;list2&quot;), None);

        assert_eq!(map.len(), 2);

        assert_eq!(map.get(&amp;list1), Some(&amp;&quot;list1&quot;));
        assert_eq!(map.get(&amp;list2), Some(&amp;&quot;list2&quot;));

        assert_eq!(map.remove(&amp;list1), Some(&quot;list1&quot;));
        assert_eq!(map.remove(&amp;list2), Some(&quot;list2&quot;));

        assert!(map.is_empty());
    }
}
</code></pre>
<p>And now for the moments of truth:</p>
<pre><code class="language-text">cargo test
    Finished test [unoptimized + debuginfo] target(s) in 0.00s
     Running unittests src\lib.rs

running 12 tests
test test::test_basic ... ok
test test::test_basic_front ... ok
test test::test_eq ... ok
test test::test_iterator ... ok
test test::test_iterator_mut_double_end ... ok
test test::test_ord_nan ... ok
test test::test_iterator_double_end ... ok
test test::test_mut_iter ... ok
test test::test_rev_iter ... ok
test test::test_hashmap ... ok
test test::test_ord ... ok
test test::test_debug ... ok

test result: ok. 12 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<pre><code class="language-text">$env:MIRIFLAGS=&quot;-Zmiri-tag-raw-pointers&quot;
cargo miri test
   Compiling linked-list v0.0.3
    Finished test [unoptimized + debuginfo] target(s) in 0.35s
     Running unittests src\lib.rs

running 12 tests
test test::test_basic ... ok
test test::test_basic_front ... ok
test test::test_debug ... ok
test test::test_eq ... ok
test test::test_hashmap ... ok
test test::test_iterator ... ok
test test::test_iterator_double_end ... ok
test test::test_iterator_mut_double_end ... ok
test test::test_mut_iter ... ok
test test::test_ord ... ok
test test::test_ord_nan ... ok
test test::test_rev_iter ... ok

test result: ok. 12 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>😭</p>
<p>We did it, we actually didn't screw up. This isn't a trick! All of our practice and training was finally worth it, we've finally written <em>good code</em>!!!</p>
<p>Now with all that gunk out of the way, we can get back to the Interesting Stuff!</p>
<h1><a class="header" href="#send-sync-and-compile-tests" id="send-sync-and-compile-tests">Send, Sync, and Compile Tests</a></h1>
<p>Ok actually we do have one more pair of traits to think about, but they're special. We have to deal with Rust's Holy Roman Empire: The Unsafe Opt-In Built-In Traits (OIBITs): <a href="https://doc.rust-lang.org/nomicon/send-and-sync.html">Send and Sync</a>, which are in fact opt-out and built-out (1 out of 3 is pretty good!).</p>
<p>Like Copy, these traits have absolutely no code associated with them, and are just markers that your type has a particular property. Send says that your type is safe to send to another thread. Sync says your type is safe to share between threads (&amp;Self: Send).</p>
<p>The same argument for LinkedList being covariant applies here: generally normal collections which don't use fancy interior mutability tricks are safe to make Send and Sync.</p>
<p>But I said they're <em>opt out</em>. So actually, are we already? How would we know?</p>
<p>Let's add some new magic to our code: random private garbage that won't compile unless our types have the properties we expect:</p>
<pre><code class="language-rust ignore">#[allow(dead_code)]
fn assert_properties() {
    fn is_send&lt;T: Send&gt;() {}
    fn is_sync&lt;T: Sync&gt;() {}

    is_send::&lt;LinkedList&lt;i32&gt;&gt;();
    is_sync::&lt;LinkedList&lt;i32&gt;&gt;();

    is_send::&lt;IntoIter&lt;i32&gt;&gt;();
    is_sync::&lt;IntoIter&lt;i32&gt;&gt;();

    is_send::&lt;Iter&lt;i32&gt;&gt;();
    is_sync::&lt;Iter&lt;i32&gt;&gt;();

    is_send::&lt;IterMut&lt;i32&gt;&gt;();
    is_sync::&lt;IterMut&lt;i32&gt;&gt;();

    is_send::&lt;Cursor&lt;i32&gt;&gt;();
    is_sync::&lt;Cursor&lt;i32&gt;&gt;();

    fn linked_list_covariant&lt;'a, T&gt;(x: LinkedList&lt;&amp;'static T&gt;) -&gt; LinkedList&lt;&amp;'a T&gt; { x }
    fn iter_covariant&lt;'i, 'a, T&gt;(x: Iter&lt;'i, &amp;'static T&gt;) -&gt; Iter&lt;'i, &amp;'a T&gt; { x }
    fn into_iter_covariant&lt;'a, T&gt;(x: IntoIter&lt;&amp;'static T&gt;) -&gt; IntoIter&lt;&amp;'a T&gt; { x }
}
</code></pre>
<pre><code class="language-text">cargo build
   Compiling linked-list v0.0.3 
error[E0277]: `NonNull&lt;Node&lt;i32&gt;&gt;` cannot be sent between threads safely
   --&gt; src\lib.rs:433:5
    |
433 |     is_send::&lt;LinkedList&lt;i32&gt;&gt;();
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ `NonNull&lt;Node&lt;i32&gt;&gt;` cannot be sent between threads safely
    |
    = help: within `LinkedList&lt;i32&gt;`, the trait `Send` is not implemented for `NonNull&lt;Node&lt;i32&gt;&gt;`
    = note: required because it appears within the type `Option&lt;NonNull&lt;Node&lt;i32&gt;&gt;&gt;`
note: required because it appears within the type `LinkedList&lt;i32&gt;`
   --&gt; src\lib.rs:8:12
    |
8   | pub struct LinkedList&lt;T&gt; {
    |            ^^^^^^^^^^
note: required by a bound in `is_send`
   --&gt; src\lib.rs:430:19
    |
430 |     fn is_send&lt;T: Send&gt;() {}
    |                   ^^^^ required by this bound in `is_send`

&lt;a million more errors&gt;
</code></pre>
<p>Oh geez, what gives! I had that great Holy Roman Empire joke!</p>
<p>Well, I lied to you when I said raw pointers have only one safety guard: this is the other. <code>*const</code> AND <code>*mut</code> explicitly opt out of Send and Sync to be safe, so we do <em>actually</em> have to opt back in:</p>
<pre><code class="language-rust ignore">unsafe impl&lt;T: Send&gt; Send for LinkedList&lt;T&gt; {}
unsafe impl&lt;T: Sync&gt; Sync for LinkedList&lt;T&gt; {}

unsafe impl&lt;'a, T: Send&gt; Send for Iter&lt;'a, T&gt; {}
unsafe impl&lt;'a, T: Sync&gt; Sync for Iter&lt;'a, T&gt; {}

unsafe impl&lt;'a, T: Send&gt; Send for IterMut&lt;'a, T&gt; {}
unsafe impl&lt;'a, T: Sync&gt; Sync for IterMut&lt;'a, T&gt; {}
</code></pre>
<p>Note that we have to write <em>unsafe impl</em> here: these are <em>unsafe traits</em>! Unsafe code (like concurrency libraries) gets to rely on us only implementing these traits correctly! Since there's no actual code, the guarantee we're making is just that, yes, we are indeed safe to Send or Share between threads!</p>
<p>Don't just slap these on lightly, but I am a Certified Professional here to say: yep there's are totally fine. Note how we don't need to implement Send and Sync for IntoIter: it just contains LinkedList, so it auto-derives Send and Sync — I told you they were actually opt out! (You opt out with the hillarious syntax of <code>impl !Send for MyType {}</code>.)</p>
<pre><code class="language-text">cargo build
   Compiling linked-list v0.0.3
    Finished dev [unoptimized + debuginfo] target(s) in 0.18s
</code></pre>
<p>Ok nice!</p>
<p>...Wait, actually it would be really dangerous if stuff that <em>shouldn't</em> be these things wasn't. In particular, IterMut <em>definitely</em> shouldn't be covariant, because it's &quot;like&quot; <code>&amp;mut T</code>. But how can we check that?</p>
<p>With Magic! Well, actually, with rustdoc! Ok well we don't have to use rustdoc for this, but it's the funniest way to do it. See, if you write a doccomment and include a code block, then rustdoc will try to compile and run it, so we can use that to make fresh anonymous &quot;programs&quot; that don't affect the main one:</p>
<pre><code class="language-rust ignore">    /// ```
    /// use linked_list::IterMut;
    /// 
    /// fn iter_mut_covariant&lt;'i, 'a, T&gt;(x: IterMut&lt;'i, &amp;'static T&gt;) -&gt; IterMut&lt;'i, &amp;'a T&gt; { x }
    /// ```
    fn iter_mut_invariant() {}
</code></pre>
<pre><code class="language-text">cargo test

...

   Doc-tests linked-list

running 1 test
test src\lib.rs - assert_properties::iter_mut_invariant (line 458) ... FAILED

failures:

---- src\lib.rs - assert_properties::iter_mut_invariant (line 458) stdout ----
error[E0308]: mismatched types
 --&gt; src\lib.rs:461:86
  |
6 | fn iter_mut_covariant&lt;'i, 'a, T&gt;(x: IterMut&lt;'i, &amp;'static T&gt;) -&gt; IterMut&lt;'i, &amp;'a T&gt; { x }
  |                                                                                      ^ lifetime mismatch
  |
  = note: expected struct `linked_list::IterMut&lt;'_, &amp;'a T&gt;`
             found struct `linked_list::IterMut&lt;'_, &amp;'static T&gt;`
</code></pre>
<p>Ok cool, we've proved it's invariant, but uh, now our tests fail. No worries, rustdoc lets you say that's expected by annotating the fence with compile_fail!</p>
<p>(Actually we only proved it's &quot;not covariant&quot; but honestly if you manage to make a type &quot;accidentaly and incorrectly contravariant&quot; then, congrats?)</p>
<pre><code class="language-rust ignore">    /// ```compile_fail
    /// use linked_list::IterMut;
    /// 
    /// fn iter_mut_covariant&lt;'i, 'a, T&gt;(x: IterMut&lt;'i, &amp;'static T&gt;) -&gt; IterMut&lt;'i, &amp;'a T&gt; { x }
    /// ```
    fn iter_mut_invariant() {}
</code></pre>
<pre><code class="language-text">cargo test
   Compiling linked-list v0.0.3
    Finished test [unoptimized + debuginfo] target(s) in 0.49s
     Running unittests src\lib.rs

...

   Doc-tests linked-list

running 1 test
test src\lib.rs - assert_properties::iter_mut_invariant (line 458) - compile fail ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.12s
</code></pre>
<p>Yay! I recommend always making the test without compile_fail so that you can confirm that it fails to compile <em>for the right reason</em>. For instance, that test will also fail (and therefore pass) if you forget the <code>use</code>, which, is not what we want! While it's conceptually appealing to be able to &quot;require&quot; a specific error from the compiler, this would be an absolute nightmare that would effectively make it a breaking change <em>for the compiler to produce better errors</em>. We want the compiler to get better, so, no you don't get to have that.</p>
<p>(Oh wait, we can actually just specify the error code we want next to the compile_fail <strong>but this only works on nightly and is a bad idea to rely on for the reasons state above. It will be silently ignored on not-nightly.</strong>)</p>
<pre><code class="language-rust ignore">    /// ```compile_fail,E0308
    /// use linked_list::IterMut;
    /// 
    /// fn iter_mut_covariant&lt;'i, 'a, T&gt;(x: IterMut&lt;'i, &amp;'static T&gt;) -&gt; IterMut&lt;'i, &amp;'a T&gt; { x }
    /// ```
    fn iter_mut_invariant() {}
</code></pre>
<p>...also, did you notice the part where we actually made IterMut invariant? It was easy to miss, since I &quot;just&quot; copy-pasted Iter and dumped it at the end. It's the last line here:</p>
<pre><code class="language-rust ignore">pub struct IterMut&lt;'a, T&gt; {
    front: Link&lt;T&gt;,
    back: Link&lt;T&gt;,
    len: usize,
    _boo: PhantomData&lt;&amp;'a mut T&gt;,
}
</code></pre>
<p>Let's try removing that PhantomData:</p>
<pre><code class="language-text"> cargo build
   Compiling linked-list v0.0.3 (C:\Users\ninte\dev\contain\linked-list)
error[E0392]: parameter `'a` is never used
  --&gt; src\lib.rs:30:20
   |
30 | pub struct IterMut&lt;'a, T&gt; {
   |                    ^^ unused parameter
   |
   = help: consider removing `'a`, referring to it in a field, or using a marker such as `PhantomData`
</code></pre>
<p>Ha! The compiler has our back and won't just let us <em>not</em> use the lifetime. Let's try using the <em>wrong</em> example instead:</p>
<pre><code class="language-rust ignore">    _boo: PhantomData&lt;&amp;'a T&gt;,
</code></pre>
<pre><code class="language-text">cargo build
   Compiling linked-list v0.0.3 (C:\Users\ninte\dev\contain\linked-list)
    Finished dev [unoptimized + debuginfo] target(s) in 0.17s
</code></pre>
<p>It builds! Do our tests catch a problem now?</p>
<pre><code class="language-text">cargo test

...

   Doc-tests linked-list

running 1 test
test src\lib.rs - assert_properties::iter_mut_invariant (line 458) - compile fail ... FAILED

failures:

---- src\lib.rs - assert_properties::iter_mut_invariant (line 458) stdout ----
Test compiled successfully, but it's marked `compile_fail`.

failures:
    src\lib.rs - assert_properties::iter_mut_invariant (line 458)

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.15s
</code></pre>
<p>Eyyy!!! The system works! I love having tests that actually do their job, so that I don't have to be quite so horrified of looming mistakes!</p>
<h1><a class="header" href="#an-introduction-to-cursors" id="an-introduction-to-cursors">An Introduction To Cursors</a></h1>
<p>OK!!! We now have a LinkedList that's on par with std's 1.0 implementation! Which of course means that our LinkedList is <em>still completely useless</em>. We've taken the enormous performance penalty of implementing a Deque as a linked list, <strong>and we don't have any of the APIs that make it actually useful</strong>. </p>
<p>Here's how we do against the &quot;killer apps&quot; of linked lists:</p>
<ul>
<li>🚫 Getting to do <a href="https://docs.rs/linked-hash-map/latest/linked_hash_map/">weird intrusive stuff</a></li>
<li>🚫 Getting to do <a href="https://doc.rust-lang.org/std/sync/mpsc/">weird lockfree stuff</a></li>
<li>🚫 Getting to store <a href="https://doc.rust-lang.org/nomicon/exotic-sizes.html#dynamically-sized-types-dsts">Dynamically Sized Types</a></li>
<li>🌟 O(1) push/pop without <a href="https://en.wikipedia.org/wiki/Amortized_analysis">amortization</a> (if you are willing to believe that malloc is O(1))</li>
<li>🚫 O(1) list splitting</li>
<li>🚫 O(1) list splicing</li>
</ul>
<p>Well... 1 out of 6 is... better than nothing! Do you see why I wanted to rip this thing out of std?</p>
<p>We're not going to make our list support &quot;weird&quot; stuff, because that's all adhoc and domain-specific. But the splitting and splicing thing, now that's something we can do!</p>
<p>But here's the problem: actually <em>reaching</em> the k<sup>th</sup> element in a LinkedList takes O(k) time, so how can we <em>possibly</em> do arbitrary splits and merges in O(1)? Well, the trick is that you don't have an API like <code>split_at(index)</code> -- you make a system where the user can statefully iterate to a position in the list and make O(1) modifications at that point!</p>
<p>Hey, we already have iterators! Can we use them for this? Kind of... but one of their super-powers gets in the way. You may recall that the way that we write out the lifetimes for by-ref iterators means that the references they return <em>aren't</em> tied to the iterator. This lets us repeatedly call <code>next</code> and hold onto the elements:</p>
<pre><code class="language-rust ignore">let mut list = ...;
let iter = list.iter_mut();
let elem1 = list.next();
let elem2 = list.next();

if elem1 == elem2 { ... }
</code></pre>
<p>If the returned references borrowed the iterator, then this code wouldn't work at all. The compiler would just complain about the second call to <code>next</code>! This flexibility is great, but it puts some implicit constraints on us:</p>
<ul>
<li>
<p>By-Mutable-Ref Iterators can never go backwards and yield an element again, because the user would be able to get two <code>&amp;mut</code>'s to the same element, breaking fundamental rules of the language.</p>
</li>
<li>
<p>By-Ref Iterators can't have extra methods which could possibly modify the underlying collection in a way that would invalidate any reference that has already been yielded.</p>
</li>
</ul>
<p>Unfortunately, both of these things are <em>exactly</em> what we want our LinkedList API to do! So we can't just use iterators, we need something new: <em>Cursors</em>.</p>
<p>Cursors are exactly like the little blinking <code>|</code> you get when you're editing some text on a computer. It's a position in a sequence (the text) that you can move around (with the arrow keys), and whenever you type the edits happen at that point.</p>
<p>See if I just</p>
<p>press</p>
<p>enter</p>
<p>the whole</p>
<p>text</p>
<p>gets broken in half.</p>
<p>Sorry you're standing behind me and watching me type this right? So that totally makes sense, right? Right.</p>
<p>Now if you've ever had the misfortune of having a keyboard with an &quot;insert&quot; key and actually pressed it, you know that there's actually technically two interpretations of cursors: they can either lie between elements (characters) or <em>on</em> elements. I'm pretty sure no one has ever pressed &quot;insert&quot; on purpose in their life, and that it exists purely as a Suffering Button, so it's pretty obvious which one is Better and Right: cursors go between elements!</p>
<p>Pretty rock-solid logic right there, I don't think anyone can disagree with me.</p>
<p>Sorry what? There was an <a href="https://github.com/rust-lang/rfcs/blob/master/text/2570-linked-list-cursors.md">RFC in 2018 to add Cursors to Rust's LinkedList</a>?</p>
<blockquote>
<p>With a Cursor one can seek back and forth through a list and get the current element. With a CursorMut One can seek back and forth and get mutable references to elements, and it can insert and delete elements before and behind the current element (along with performing several list operations such as splitting and splicing).</p>
</blockquote>
<p><em>Current element</em>? This cursor is <em>on</em> elements, not between them! I can't believe they didn't accept my totally rock-solid argument! So yeah you can just go use the Cursor in std... wait, it's <a href="https://doc.rust-lang.org/1.60.0/std/collections/linked_list/struct.CursorMut.html">2022, and Rust 1.60 still has Cursor marked as unstable</a>?</p>
<p>Hey wait:</p>
<blockquote>
<p>Cursors always rest between two elements in the list, and index in a logically circular way. To accommodate this, there is a &quot;ghost&quot; non-element that yields None between the head and tail of the list.</p>
</blockquote>
<p>HEY WAIT. This is the opposite of what the RFC says??? But wait all the docs on the methods still refer to &quot;current&quot; elements... wait hold on, where have I seen this ghost stuff before. Oh wait, didn't I do that in <a href="https://docs.rs/linked-list/0.0.3/linked_list/struct.Cursor.html">my old linked-list fork</a> where I prototyped?</p>
<blockquote>
<p>Cursors always rest between two elements in the list, and index in a logically circular way. To accomadate this, there is a &quot;ghost&quot; non-element that yields None between the head and tail of the List.</p>
</blockquote>
<p>Hold up what the fuck. This isn't a gag, I am actually trying to Read The Docs right now. Did std actually RFC a different design from the one I proposed in 2015, but then copy-paste the docs from my prototype??? Is std meta-shitposting me for writing a book about how much I hate LinkedList????? Like yeah I built that prototype to demonstrate the concept so that people would let me add it to std and make LinkedList not useless but, qu'est-ce que le fuck??????????????</p>
<p>Ok you know what, clearly std is blessing my design as the objectively superior one, so we're going to do my design. Also that's nice because this entire chapter is me actually literally rewriting that library from scratch, so not changing the API sounds Good To Me!</p>
<p>Here's the full top-level docs I wrote:</p>
<blockquote>
<p>A Cursor is like an iterator, except that it can freely seek back-and-forth, and can safely mutate the list during iteration. This is because the lifetime of its yielded references are tied to its own lifetime, instead of just the underlying list. This means cursors cannot yield multiple elements at once.</p>
<p>Cursors always rest between two elements in the list, and index in a logically circular way. To accomadate this, there is a &quot;ghost&quot; non-element that yields None between the head and tail of the List.</p>
<p>When created, cursors start between the ghost and the front of the list. That is, next will yield the front of the list, and prev will yield None. Calling prev again will yield the tail.</p>
</blockquote>
<p>Cute, even though we concluded that the whole &quot;sentinel-node&quot; thing was more trouble than it's worth, we're still going to end up with semantics that &quot;pretend&quot; there's a sentinel node so that the cursor can wrap around to the other side of the list.</p>
<p><em>Skims over my old APIs some more</em></p>
<pre><code class="language-rust ignore">fn splice(&amp;mut self, other: &amp;mut LinkedList&lt;T&gt;)
</code></pre>
<blockquote>
<p>Inserts the entire list's contents right after the cursor.</p>
</blockquote>
<p>Oh yeah, this is coming back to me. I wrote this when I was really mad about combinatoric explosion, and was trying to come up with a way for there to only be one copy of each operation. Unfortunately this is... semantically problematic. See, when the user wants to splice one list into another, they might want the cursor to end up <em>before</em> the splice or <em>after it</em>. The inserted list can be arbitrarily large, so it's a genuine issue for us to only allow for one and expect the user to walk over the entire inserted list!</p>
<p>We're gonna have to rework this design from the ground up after all. What does our Cursor type need? Well it needs to:</p>
<ul>
<li>point &quot;between&quot; two elements</li>
<li>as a nice little feature, keep track of what &quot;index&quot; is next</li>
<li>update the list itself to modify front/back/len. </li>
</ul>
<p>How do you point between two elements? Well, you don't. You just point at the &quot;next&quot; element. So, yeah even though we're exposing &quot;cursor goes in-between&quot; semantics, we're really implementing it as &quot;cursor is on&quot;, and just pretending everything happens before or after that point.</p>
<p>But there's a reason! The splice use-case wants to let the user choose whether they end up before or after the list, but this is... <em>horribly</em> complicated to express with the std API! They have splice_after and splice_before, but neither changes the cursor's position, so really you'd need splice_after_before and splice_after_after...</p>
<p>Wait no I'm being silly. In the std API you can just choose the node you want to end up on, and then use splice_after/before as appropriate.</p>
<p><em>squints</em></p>
<p>Wait is the std API actually good.</p>
<p><em>skims through the code</em></p>
<p>Ok the std API is actually good.</p>
<p>Alright screw it, we're going to <a href="https://github.com/rust-lang/rfcs/blob/master/text/2570-linked-list-cursors.md">implement the RFC</a>. Or at least the interesting parts of it.</p>
<p>I have my quibbles with some of the terminology std uses, but cursors are always going to be a bit brain-melty: <code>iter().next_back()</code>  gets you <code>back()</code>, so that's good, but then each subsequent <code>next_back()</code> is actually bringing you <em>closer to the front</em> and indeed, every pointer we follow is a &quot;front&quot; pointer! If I think about this seeming-paradox too much it hurts my brain, so, I can certainly respect going for different terminology to avoid this.</p>
<p>The std API talks about operations before &quot;before&quot; (towards the front) and &quot;after&quot; (towards the back), and instead of <code>next</code> and <code>next_back</code>, it... calls things <code>move_next</code> and <code>move_prev</code>. HRM. Ok so they're getting into a bit of the iterator terminology, but at least <code>next</code> doesn't evoke front/back, and helps you orient how things behave compared to the iterators.</p>
<p>We can work with this.</p>
<h1><a class="header" href="#implementing-cursors" id="implementing-cursors">Implementing Cursors</a></h1>
<p>Ok so we're only going to bother with std's CursorMut because the immutable version isn't actually interesting. Just like my original design, it has a &quot;ghost&quot; element that contains None to indicate the start/end of the list, and you can &quot;walk over it&quot; to wrap around to the other side of the list. To implement it, we're going to need:</p>
<ul>
<li>A pointer to the current node</li>
<li>A pointer to the list</li>
<li>The current index</li>
</ul>
<p>Wait what's the index when we point at the &quot;ghost&quot;? </p>
<p><em>furrows brow</em> ... <em>checks std</em> ... <em>dislikes std's answer</em></p>
<p>Ok so quite reasonably <code>index</code> on a Cursor returns an <code>Option&lt;usize&gt;</code>. The std implementation does a bunch of junk to avoid storing it as an Option but... we're a linked list, it's fine. Also std has the cursor_front/cursor_back stuff which starts the cursor on the front/back elements, which feels intuitive, but then has to do something weird when the list is empty.</p>
<p>You can implement that stuff if you want, but I'm going to cut down on all the repetitive gunk and corner cases and just make a bare <code>cursor_mut</code> method that starts at the ghost, and people can use move_next/move_prev to get the one they want (and then you can wrap that up as cursor_front if you really want).</p>
<p>Let's get cracking:</p>
<pre><code class="language-rust ignore">pub struct CursorMut&lt;'a, T&gt; {
    cur: Link&lt;T&gt;,
    list: &amp;'a mut LinkedList&lt;T&gt;,
    index: Option&lt;usize&gt;,
}
</code></pre>
<p>Pretty straight-forward, one field for each item of our bulleted list! Now the <code>cursor_mut</code> method:</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; LinkedList&lt;T&gt; {
    pub fn cursor_mut(&amp;mut self) -&gt; CursorMut&lt;T&gt; {
        CursorMut { 
            list: self, 
            cur: None, 
            index: None,
        }
    }
}
</code></pre>
<p>Since we're starting at the ghost, we can just start with everything as None, nice and simple! Next, movement:</p>
<pre><code class="language-rust ignore">impl&lt;'a, T&gt; CursorMut&lt;'a, T&gt; {
    pub fn index(&amp;self) -&gt; Option&lt;usize&gt; {
        self.index
    }

    pub fn move_next(&amp;mut self) {
        if let Some(cur) = self.cur {
            unsafe {
                // We're on a real element, go to its next (back)
                self.cur = (*cur.as_ptr()).back;
                if self.cur.is_some() {
                    *self.index.as_mut().unwrap() += 1;
                } else {
                    // We just walked to the ghost, no more index
                    self.index = None;
                }
            }
        } else if !self.list.is_empty() {
            // We're at the ghost, and there is a real front, so move to it!
            self.cur = self.list.front;
            self.index = Some(0)
        } else {
            // We're at the ghost, but that's the only element... do nothing.
        }
    }
}
</code></pre>
<p>So there's 4 interesting cases:</p>
<ul>
<li>The normal case</li>
<li>The normal case, but we reach the ghost</li>
<li>The ghost case, where we go to the front of the list</li>
<li>The ghost case, but the list is empty, so do nothing</li>
</ul>
<p>move_prev is the exact same logic, but with front/back inverted and the indexing changes inverted:</p>
<pre><code class="language-rust ignore">pub fn move_prev(&amp;mut self) {
    if let Some(cur) = self.cur {
        unsafe {
            // We're on a real element, go to its previous (front)
            self.cur = (*cur.as_ptr()).front;
            if self.cur.is_some() {
                *self.index.as_mut().unwrap() -= 1;
            } else {
                // We just walked to the ghost, no more index
                self.index = None;
            }
        }
    } else if !self.list.is_empty() {
        // We're at the ghost, and there is a real back, so move to it!
        self.cur = self.list.back;
        self.index = Some(self.list.len - 1)
    } else {
        // We're at the ghost, but that's the only element... do nothing.
    }
}
</code></pre>
<p>Next let's add some methods to look at the elements around the cursor: current, peek_next, and peek_prev. <strong>A Very Important Note:</strong> these methods must borrow our cursor by <code>&amp;mut self</code>, and the results must be tied to that borrow. We cannot let the user get multiple copies of a mutable reference, and we cannot let them use any of our insert/remove/split/splice APIs while holding onto such a reference!</p>
<p>Thankfully, this is the default assumption rust makes when you use lifetime elision, so, we will just do the right thing by default!</p>
<pre><code class="language-rust ignore">pub fn current(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt; {
    unsafe {
        self.cur.map(|node| &amp;mut (*node.as_ptr()).elem)
    }
}

pub fn peek_next(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt; {
    unsafe {
        self.cur
            .and_then(|node| (*node.as_ptr()).back)
            .map(|node| &amp;mut (*node.as_ptr()).elem)
    }
}

pub fn peek_prev(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt; {
    unsafe {
        self.cur
            .and_then(|node| (*node.as_ptr()).front)
            .map(|node| &amp;mut (*node.as_ptr()).elem)
    }
}
</code></pre>
<p>Head empty, Option methods and (omitted) compiler errors do all thinking now. I was skeptical about the <code>Option&lt;NonNull&gt;</code> stuff, but, god damn it really just lets me autopilot this code. I've spent way too much time writing array-based collections where you never get to use Option, wow this is nice! (<code>(*node.as_ptr())</code> is still miserable but, that's just Rust's raw pointers for you...)</p>
<p>Next we have a choice: we can either jump right to split and splice, the entire point of these APIs, or we can take a baby-step with single element insert/remove. I have a feeling we're just going to want to implement insert/remove in terms of split and splice so... let's just do those first and see where the cards fall (genuinely have no idea as I type this).</p>
<h1><a class="header" href="#split" id="split">Split</a></h1>
<p>First up, split_before and split_after, which return everything before/after the current element as a LinkedList (stopping at the ghost element, unless you're at the ghost, in which case we just return the whole List and the cursor now points to an empty list):</p>
<p><em>squints</em> ok this one is actually some non-trivial logic so we're going to have to talk it out one step at a time.</p>
<p>I see 4 potentially interesting cases for split_before:</p>
<ul>
<li>The normal case</li>
<li>The normal case, but prev is the ghost</li>
<li>The ghost case, where we return the whole list and become empty</li>
<li>The ghost case, but the list is empty, so do nothing and return the empty list</li>
</ul>
<p>Let's start with the corner cases. The third case I believe is just</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mem::replace(self.list, LinkedList::new())
<span class="boring">}
</span></code></pre></pre>
<p>Right? We become empty, we return the whole list, and our fields were already None, so nothing to update. Nice. Oh hey, this also Does The Right Thing on the fourth case too!</p>
<p>So now the normal cases... ok I'm going to need some ASCII diagrams for this. In the most general case, we have something like this:</p>
<pre><code class="language-text">list.front -&gt; A &lt;-&gt; B &lt;-&gt; C &lt;-&gt; D &lt;- list.back
                          ^
                         cur
</code></pre>
<p>And we want to produce this:</p>
<pre><code class="language-text">list.front -&gt; C &lt;-&gt; D &lt;- list.back
              ^
             cur

return.front -&gt; A &lt;-&gt; B &lt;- return.back
</code></pre>
<p>So we need to break the link between cur and prev, and... god so much needs to change. Ok I just need to break this up into steps so I can convince myself it makes sense. This will be a bit over-verbose but I can at least make sense of it:</p>
<pre><code class="language-rust ignore">pub fn split_before(&amp;mut self) -&gt; LinkedList&lt;T&gt; {
    if let Some(cur) = self.cur {
        // We are pointing at a real element, so the list is non-empty.
        unsafe {
            // Current state
            let old_len = self.list.len;
            let old_idx = self.index.unwrap();
            let prev = (*cur.as_ptr()).front;
            
            // What self will become
            let new_len = old_len - old_idx;
            let new_front = self.cur;
            let new_back = self.list.back;
            let new_idx = Some(0);

            // What the output will become
            let output_len = old_len - new_len;
            let output_front = self.list.front;
            let output_back = prev;

            // Break the links between cur and prev
            if let Some(prev) = prev {
                (*cur.as_ptr()).front = None;
                (*prev.as_ptr()).back = None;
            }

            // Produce the result:
            self.list.len = new_len;
            self.list.front = new_front;
            self.list.back = new_back;
            self.index = new_idx;

            LinkedList {
                front: output_front,
                back: output_back,
                len: output_len,
                _boo: PhantomData,
            }
        }
    } else {
        // We're at the ghost, just replace our list with an empty one.
        // No other state needs to be changed.
        std::mem::replace(self.list, LinkedList::new())
    }
}
</code></pre>
<p>Note that this if-let is handling the &quot;normal case, but prev is the ghost&quot; situation:</p>
<pre><code class="language-rust ignore">if let Some(prev) = prev {
    (*cur.as_ptr()).front = None;
    (*prev.as_ptr()).back = None;
}
</code></pre>
<p>If <em>you</em> want to, you can squash that all together and apply optimizations like:</p>
<ul>
<li>fold the two accesses to <code>(*cur.as_ptr()).front</code> as just <code>(*cur.as_ptr()).front.take()</code> </li>
<li>note that new_back is a noop, and just remove both</li>
</ul>
<p>As far as I can tell, everything else just incidentally Does The Right Thing otherwise. We'll see when we write tests! (copy-paste to make split_after)</p>
<p>I am done Making Mistakes and I am just going to try to write the most foolproof code I can. This is how I <em>actually</em> write collections: just break things down into trivial steps and cases until it can fit in my head and seems foolproof. Then write a ton of tests until I'm convinced I didn't manage to mess it up still.</p>
<p>Because most of the collections work I've done is <em>extremely unsafe</em> I don't generally get to rely on the compiler catching mistakes, and miri didn't exist back in the day! So I just need to squint at a problem until my head hurts and try my hardest to Never Ever Ever Make A Mistake.</p>
<p>Don't write Unsafe Rust Code! Safe Rust is so much better!!!!</p>
<h1><a class="header" href="#splice" id="splice">Splice</a></h1>
<p>Just one more boss to fight, splice_before and splice_after, which I expect to be the corner-casiest one of them all. The two functions <em>take in</em> a LinkedList and grafts its contents into outrs. Our list could be empty, their list could be empty, we've got ghosts to deal with... <em>sigh</em> let's just take it one step at a time with splice_before.</p>
<ul>
<li>If their list is empty, we don't need to do anything. </li>
<li>If our list is empty, then our list just becomes their list.</li>
<li>If we're pointing at the ghost, then this appends to the back (change list.back)</li>
<li>If we're pointing at the first element (0), this this appends to the front (change list.front)</li>
<li>In the general case, we do a whole lot of pointer fuckery.</li>
</ul>
<p>The general case is this:</p>
<pre><code class="language-text">input.front -&gt; 1 &lt;-&gt; 2 &lt;- input.back

 list.front -&gt; A &lt;-&gt; B &lt;-&gt; C &lt;- list.back
                     ^
                    cur
</code></pre>
<p>Becoming this:</p>
<pre><code class="language-text">list.front -&gt; A &lt;-&gt; 1 &lt;-&gt; 2 &lt;-&gt; B &lt;-&gt; C &lt;- list.back
</code></pre>
<p>Ok? Ok. Let's write that out... <em>TAKES A HUGE BREATH AND PLUNGES IN</em>:</p>
<pre><code class="language-rust ignore">    pub fn splice_before(&amp;mut self, mut input: LinkedList&lt;T&gt;) {
        unsafe {
            if input.is_empty() {
                // Input is empty, do nothing.
            } else if let Some(cur) = self.cur {
                if let Some(0) = self.index {
                    // We're appending to the front, see append to back
                    (*cur.as_ptr()).front = input.back.take();
                    (*input.back.unwrap().as_ptr()).back = Some(cur);
                    self.list.front = input.front.take();

                    // Index moves forward by input length
                    *self.index.as_mut().unwrap() += input.len;
                    self.list.len += input.len;
                    input.len = 0;
                } else {
                    // General Case, no boundaries, just internal fixups
                    let prev = (*cur.as_ptr()).front.unwrap();
                    let in_front = input.front.take().unwrap();
                    let in_back = input.back.take().unwrap();

                    (*prev.as_ptr()).back = Some(in_front);
                    (*in_front.as_ptr()).front = Some(prev);
                    (*cur.as_ptr()).front = Some(in_back);
                    (*in_back.as_ptr()).back = Some(cur);

                    // Index moves forward by input length
                    *self.index.as_mut().unwrap() += input.len;
                    self.list.len += input.len;
                    input.len = 0;
                }
            } else if let Some(back) = self.list.back {
                // We're on the ghost but non-empty, append to the back
                // We can either `take` the input's pointers or `mem::forget`
                // it. Using take is more responsible in case we do custom
                // allocators or something that also needs to be cleaned up!
                (*back.as_ptr()).back = input.front.take();
                (*input.front.unwrap().as_ptr()).front = Some(back);
                self.list.back = input.back.take();
                self.list.len += input.len;
                // Not necessary but Polite To Do
                input.len = 0;
            } else {
                // We're empty, become the input, remain on the ghost
                *self.list = input;
            }
        }
    }
</code></pre>
<p>Ok this one is genuinely horrendous, and really is feeling that <code>Option&lt;NonNull&gt;</code> pain now. But there's a lot of cleanups we can do. For one, we can pull this code out to the very end, because we always want to do it. I don't <em>love</em>  (although sometimes it's a noop, and setting <code>input.len</code> is more a matter of paranoia about future extensions to the code):</p>
<pre><code class="language-rust ignore">self.list.len += input.len;
input.len = 0;
</code></pre>
<blockquote>
<p>Use of moved value: <code>input</code></p>
</blockquote>
<p>Ah, right, in the &quot;we're empty&quot; case we're moving the list. Let's replace that with a swap:</p>
<pre><code class="language-rust ignore">// We're empty, become the input, remain on the ghost
std::mem::swap(self.list, &amp;mut input);
</code></pre>
<p>In this case the writes will be pointless, but, they still work (we could probably also early-return in this branch to appease the compiler).</p>
<p>This unwrap is just a consequence of me thinking about the cases backwards, and can be fixed by making the if-let ask the right question:</p>
<pre><code class="language-rust ignore">if let Some(0) = self.index {

} else {
    let prev = (*cur.as_ptr()).front.unwrap();
}
</code></pre>
<p>Adjusting the index is duplicated inside the branches, so can also be hoisted out:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>*self.index.as_mut().unwrap() += input.len;
<span class="boring">}
</span></code></pre></pre>
<p>Ok, putting that all together we get this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if input.is_empty() {
    // Input is empty, do nothing.
} else if let Some(cur) = self.cur {
    // Both lists are non-empty
    if let Some(prev) = (*cur.as_ptr()).front {
        // General Case, no boundaries, just internal fixups
        let in_front = input.front.take().unwrap();
        let in_back = input.back.take().unwrap();

        (*prev.as_ptr()).back = Some(in_front);
        (*in_front.as_ptr()).front = Some(prev);
        (*cur.as_ptr()).front = Some(in_back);
        (*in_back.as_ptr()).back = Some(cur);
    } else {
        // We're appending to the front, see append to back below
        (*cur.as_ptr()).front = input.back.take();
        (*input.back.unwrap().as_ptr()).back = Some(cur);
        self.list.front = input.front.take();
    }
    // Index moves forward by input length
    *self.index.as_mut().unwrap() += input.len;
} else if let Some(back) = self.list.back {
    // We're on the ghost but non-empty, append to the back
    // We can either `take` the input's pointers or `mem::forget`
    // it. Using take is more responsible in case we do custom
    // allocators or something that also needs to be cleaned up!
    (*back.as_ptr()).back = input.front.take();
    (*input.front.unwrap().as_ptr()).front = Some(back);
    self.list.back = input.back.take();

} else {
    // We're empty, become the input, remain on the ghost
    std::mem::swap(self.list, &amp;mut input);
}

self.list.len += input.len;
// Not necessary but Polite To Do
input.len = 0;

// Input dropped here
<span class="boring">}
</span></code></pre></pre>
<p>Alright this still sucks, but mostly because of -- nope ok just spotted a bug:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    (*back.as_ptr()).back = input.front.take();
    (*input.front.unwrap().as_ptr()).front = Some(back);
<span class="boring">}
</span></code></pre></pre>
<p>We <code>take</code> input.front and then unwrap it on the next line! <em>sigh</em> and we do the same thing in the equivalent mirror case. We would have caught this instantly in tests, but, we're trying to be Perfect now, and I'm just kinda doing this live, and this is the exact moment where I saw it. This is what I get for not being my usual tedious self and doing things in phases. More explicit!</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// We can either `take` the input's pointers or `mem::forget`
// it. Using `take` is more responsible in case we ever do custom
// allocators or something that also needs to be cleaned up!
if input.is_empty() {
    // Input is empty, do nothing.
} else if let Some(cur) = self.cur {
    // Both lists are non-empty
    let in_front = input.front.take().unwrap();
    let in_back = input.back.take().unwrap();

    if let Some(prev) = (*cur.as_ptr()).front {
        // General Case, no boundaries, just internal fixups
        (*prev.as_ptr()).back = Some(in_front);
        (*in_front.as_ptr()).front = Some(prev);
        (*cur.as_ptr()).front = Some(in_back);
        (*in_back.as_ptr()).back = Some(cur);
    } else {
        // No prev, we're appending to the front
        (*cur.as_ptr()).front = Some(in_back);
        (*in_back.as_ptr()).back = Some(cur);
        self.list.front = Some(in_front);
    }
    // Index moves forward by input length
    *self.index.as_mut().unwrap() += input.len;
} else if let Some(back) = self.list.back {
    // We're on the ghost but non-empty, append to the back
    let in_front = input.front.take().unwrap();
    let in_back = input.back.take().unwrap();

    (*back.as_ptr()).back = Some(in_front);
    (*in_front.as_ptr()).front = Some(back);
    self.list.back = Some(in_back);
} else {
    // We're empty, become the input, remain on the ghost
    std::mem::swap(self.list, &amp;mut input);
}

self.list.len += input.len;
// Not necessary but Polite To Do
input.len = 0;

// Input dropped here
<span class="boring">}
</span></code></pre></pre>
<p>Alright now this, this I can tolerate. The only complaints I have are that we don't dedupe in_front/in_back (probably we could rejig our conditions but eh whatever). Really this is basically what you would write in C but with <code>Option&lt;NonNull&gt;</code> gunk making it tedious. I can live with that. Well no we should just make raw pointers better for this stuff. But, out of scope for this book.</p>
<p>Anyway, I am absolutely exhausted after that, so, <code>insert</code> and <code>remove</code> and all the other APIs can be left as an excercise to the reader. </p>
<p>Here's the final code for our Cursor with my attempt at copy-pasting the combinatorics. Did I get it right? I'll only find out when I write the next chapter and test this monstrosity!</p>
<pre><code class="language-rust ignore">pub struct CursorMut&lt;'a, T&gt; {
    list: &amp;'a mut LinkedList&lt;T&gt;,
    cur: Link&lt;T&gt;,
    index: Option&lt;usize&gt;,
}

impl&lt;T&gt; LinkedList&lt;T&gt; {
    pub fn cursor_mut(&amp;mut self) -&gt; CursorMut&lt;T&gt; {
        CursorMut { 
            list: self, 
            cur: None, 
            index: None,
        }
    }
}

impl&lt;'a, T&gt; CursorMut&lt;'a, T&gt; {
    pub fn index(&amp;self) -&gt; Option&lt;usize&gt; {
        self.index
    }

    pub fn move_next(&amp;mut self) {
        if let Some(cur) = self.cur {
            unsafe {
                // We're on a real element, go to its next (back)
                self.cur = (*cur.as_ptr()).back;
                if self.cur.is_some() {
                    *self.index.as_mut().unwrap() += 1;
                } else {
                    // We just walked to the ghost, no more index
                    self.index = None;
                }
            }
        } else if !self.list.is_empty() {
            // We're at the ghost, and there is a real front, so move to it!
            self.cur = self.list.front;
            self.index = Some(0)
        } else {
            // We're at the ghost, but that's the only element... do nothing.
        }
    }

    pub fn move_prev(&amp;mut self) {
        if let Some(cur) = self.cur {
            unsafe {
                // We're on a real element, go to its previous (front)
                self.cur = (*cur.as_ptr()).front;
                if self.cur.is_some() {
                    *self.index.as_mut().unwrap() -= 1;
                } else {
                    // We just walked to the ghost, no more index
                    self.index = None;
                }
            }
        } else if !self.list.is_empty() {
            // We're at the ghost, and there is a real back, so move to it!
            self.cur = self.list.back;
            self.index = Some(self.list.len - 1)
        } else {
            // We're at the ghost, but that's the only element... do nothing.
        }
    }

    pub fn current(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt; {
        unsafe {
            self.cur.map(|node| &amp;mut (*node.as_ptr()).elem)
        }
    }

    pub fn peek_next(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt; {
        unsafe {
            self.cur
                .and_then(|node| (*node.as_ptr()).back)
                .map(|node| &amp;mut (*node.as_ptr()).elem)
        }
    }

    pub fn peek_prev(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt; {
        unsafe {
            self.cur
                .and_then(|node| (*node.as_ptr()).front)
                .map(|node| &amp;mut (*node.as_ptr()).elem)
        }
    }

    pub fn split_before(&amp;mut self) -&gt; LinkedList&lt;T&gt; {
        // We have this:
        //
        //     list.front -&gt; A &lt;-&gt; B &lt;-&gt; C &lt;-&gt; D &lt;- list.back
        //                               ^
        //                              cur
        // 
        //
        // And we want to produce this:
        // 
        //     list.front -&gt; C &lt;-&gt; D &lt;- list.back
        //                   ^
        //                  cur
        //
        // 
        //    return.front -&gt; A &lt;-&gt; B &lt;- return.back
        //
        if let Some(cur) = self.cur {
            // We are pointing at a real element, so the list is non-empty.
            unsafe {
                // Current state
                let old_len = self.list.len;
                let old_idx = self.index.unwrap();
                let prev = (*cur.as_ptr()).front;
                
                // What self will become
                let new_len = old_len - old_idx;
                let new_front = self.cur;
                let new_back = self.list.back;
                let new_idx = Some(0);

                // What the output will become
                let output_len = old_len - new_len;
                let output_front = self.list.front;
                let output_back = prev;

                // Break the links between cur and prev
                if let Some(prev) = prev {
                    (*cur.as_ptr()).front = None;
                    (*prev.as_ptr()).back = None;
                }

                // Produce the result:
                self.list.len = new_len;
                self.list.front = new_front;
                self.list.back = new_back;
                self.index = new_idx;

                LinkedList {
                    front: output_front,
                    back: output_back,
                    len: output_len,
                    _boo: PhantomData,
                }
            }
        } else {
            // We're at the ghost, just replace our list with an empty one.
            // No other state needs to be changed.
            std::mem::replace(self.list, LinkedList::new())
        }
    }

    pub fn split_after(&amp;mut self) -&gt; LinkedList&lt;T&gt; {
        // We have this:
        //
        //     list.front -&gt; A &lt;-&gt; B &lt;-&gt; C &lt;-&gt; D &lt;- list.back
        //                         ^
        //                        cur
        // 
        //
        // And we want to produce this:
        // 
        //     list.front -&gt; A &lt;-&gt; B &lt;- list.back
        //                         ^
        //                        cur
        //
        // 
        //    return.front -&gt; C &lt;-&gt; D &lt;- return.back
        //
        if let Some(cur) = self.cur {
            // We are pointing at a real element, so the list is non-empty.
            unsafe {
                // Current state
                let old_len = self.list.len;
                let old_idx = self.index.unwrap();
                let next = (*cur.as_ptr()).back;
                
                // What self will become
                let new_len = old_idx + 1;
                let new_back = self.cur;
                let new_front = self.list.front;
                let new_idx = Some(old_idx);

                // What the output will become
                let output_len = old_len - new_len;
                let output_front = next;
                let output_back = self.list.back;

                // Break the links between cur and next
                if let Some(next) = next {
                    (*cur.as_ptr()).back = None;
                    (*next.as_ptr()).front = None;
                }

                // Produce the result:
                self.list.len = new_len;
                self.list.front = new_front;
                self.list.back = new_back;
                self.index = new_idx;

                LinkedList {
                    front: output_front,
                    back: output_back,
                    len: output_len,
                    _boo: PhantomData,
                }
            }
        } else {
            // We're at the ghost, just replace our list with an empty one.
            // No other state needs to be changed.
            std::mem::replace(self.list, LinkedList::new())
        }
    }

    pub fn splice_before(&amp;mut self, mut input: LinkedList&lt;T&gt;) {
        // We have this:
        //
        // input.front -&gt; 1 &lt;-&gt; 2 &lt;- input.back
        //
        // list.front -&gt; A &lt;-&gt; B &lt;-&gt; C &lt;- list.back
        //                     ^
        //                    cur
        //
        //
        // Becoming this:
        //
        // list.front -&gt; A &lt;-&gt; 1 &lt;-&gt; 2 &lt;-&gt; B &lt;-&gt; C &lt;- list.back
        //                                 ^
        //                                cur
        //
        unsafe {
            // We can either `take` the input's pointers or `mem::forget`
            // it. Using `take` is more responsible in case we ever do custom
            // allocators or something that also needs to be cleaned up!
            if input.is_empty() {
                // Input is empty, do nothing.
            } else if let Some(cur) = self.cur {
                // Both lists are non-empty
                let in_front = input.front.take().unwrap();
                let in_back = input.back.take().unwrap();

                if let Some(prev) = (*cur.as_ptr()).front {
                    // General Case, no boundaries, just internal fixups
                    (*prev.as_ptr()).back = Some(in_front);
                    (*in_front.as_ptr()).front = Some(prev);
                    (*cur.as_ptr()).front = Some(in_back);
                    (*in_back.as_ptr()).back = Some(cur);
                } else {
                    // No prev, we're appending to the front
                    (*cur.as_ptr()).front = Some(in_back);
                    (*in_back.as_ptr()).back = Some(cur);
                    self.list.front = Some(in_front);
                }
                // Index moves forward by input length
                *self.index.as_mut().unwrap() += input.len;
            } else if let Some(back) = self.list.back {
                // We're on the ghost but non-empty, append to the back
                let in_front = input.front.take().unwrap();
                let in_back = input.back.take().unwrap();

                (*back.as_ptr()).back = Some(in_front);
                (*in_front.as_ptr()).front = Some(back);
                self.list.back = Some(in_back);
            } else {
                // We're empty, become the input, remain on the ghost
                std::mem::swap(self.list, &amp;mut input);
            }

            self.list.len += input.len;
            // Not necessary but Polite To Do
            input.len = 0;
            
            // Input dropped here
        }        
    }

    pub fn splice_after(&amp;mut self, mut input: LinkedList&lt;T&gt;) {
        // We have this:
        //
        // input.front -&gt; 1 &lt;-&gt; 2 &lt;- input.back
        //
        // list.front -&gt; A &lt;-&gt; B &lt;-&gt; C &lt;- list.back
        //                     ^
        //                    cur
        //
        //
        // Becoming this:
        //
        // list.front -&gt; A &lt;-&gt; B &lt;-&gt; 1 &lt;-&gt; 2 &lt;-&gt; C &lt;- list.back
        //                     ^
        //                    cur
        //
        unsafe {
            // We can either `take` the input's pointers or `mem::forget`
            // it. Using `take` is more responsible in case we ever do custom
            // allocators or something that also needs to be cleaned up!
            if input.is_empty() {
                // Input is empty, do nothing.
            } else if let Some(cur) = self.cur {
                // Both lists are non-empty
                let in_front = input.front.take().unwrap();
                let in_back = input.back.take().unwrap();

                if let Some(next) = (*cur.as_ptr()).back {
                    // General Case, no boundaries, just internal fixups
                    (*next.as_ptr()).front = Some(in_back);
                    (*in_back.as_ptr()).back = Some(next);
                    (*cur.as_ptr()).back = Some(in_front);
                    (*in_front.as_ptr()).front = Some(cur);
                } else {
                    // No next, we're appending to the back
                    (*cur.as_ptr()).back = Some(in_front);
                    (*in_front.as_ptr()).front = Some(cur);
                    self.list.back = Some(in_back);
                }
                // Index doesn't change
            } else if let Some(front) = self.list.front {
                // We're on the ghost but non-empty, append to the front
                let in_front = input.front.take().unwrap();
                let in_back = input.back.take().unwrap();

                (*front.as_ptr()).front = Some(in_back);
                (*in_back.as_ptr()).back = Some(front);
                self.list.front = Some(in_front);
            } else {
                // We're empty, become the input, remain on the ghost
                std::mem::swap(self.list, &amp;mut input);
            }

            self.list.len += input.len;
            // Not necessary but Polite To Do
            input.len = 0;
            
            // Input dropped here
        }        
    }
}
</code></pre>
<h1><a class="header" href="#testing-cursors" id="testing-cursors">Testing Cursors</a></h1>
<p>Time to find out how many horribly embarassing mistakes I made in the previous section!</p>
<p>Oh god we made our API unlike both std and the old impl. Alright well I'm just gonna hastily cobble together something from both of them. Yeah let's &quot;borrow&quot; these tests from std:</p>
<pre><code class="language-rust ignore">    #[test]
    fn test_cursor_move_peek() {
        let mut m: LinkedList&lt;u32&gt; = LinkedList::new();
        m.extend([1, 2, 3, 4, 5, 6]);
        let mut cursor = m.cursor_mut();
        cursor.move_next();
        assert_eq!(cursor.current(), Some(&amp;mut 1));
        assert_eq!(cursor.peek_next(), Some(&amp;mut 2));
        assert_eq!(cursor.peek_prev(), None);
        assert_eq!(cursor.index(), Some(0));
        cursor.move_prev();
        assert_eq!(cursor.current(), None);
        assert_eq!(cursor.peek_next(), Some(&amp;mut 1));
        assert_eq!(cursor.peek_prev(), Some(&amp;mut 6));
        assert_eq!(cursor.index(), None);
        cursor.move_next();
        cursor.move_next();
        assert_eq!(cursor.current(), Some(&amp;mut 2));
        assert_eq!(cursor.peek_next(), Some(&amp;mut 3));
        assert_eq!(cursor.peek_prev(), Some(&amp;mut 1));
        assert_eq!(cursor.index(), Some(1));

        let mut cursor = m.cursor_mut();
        cursor.move_prev();
        assert_eq!(cursor.current(), Some(&amp;mut 6));
        assert_eq!(cursor.peek_next(), None);
        assert_eq!(cursor.peek_prev(), Some(&amp;mut 5));
        assert_eq!(cursor.index(), Some(5));
        cursor.move_next();
        assert_eq!(cursor.current(), None);
        assert_eq!(cursor.peek_next(), Some(&amp;mut 1));
        assert_eq!(cursor.peek_prev(), Some(&amp;mut 6));
        assert_eq!(cursor.index(), None);
        cursor.move_prev();
        cursor.move_prev();
        assert_eq!(cursor.current(), Some(&amp;mut 5));
        assert_eq!(cursor.peek_next(), Some(&amp;mut 6));
        assert_eq!(cursor.peek_prev(), Some(&amp;mut 4));
        assert_eq!(cursor.index(), Some(4));
    }

    #[test]
    fn test_cursor_mut_insert() {
        let mut m: LinkedList&lt;u32&gt; = LinkedList::new();
        m.extend([1, 2, 3, 4, 5, 6]);
        let mut cursor = m.cursor_mut();
        cursor.move_next();
        cursor.splice_before(Some(7).into_iter().collect());
        cursor.splice_after(Some(8).into_iter().collect());
        // check_links(&amp;m);
        assert_eq!(m.iter().cloned().collect::&lt;Vec&lt;_&gt;&gt;(), &amp;[7, 1, 8, 2, 3, 4, 5, 6]);
        let mut cursor = m.cursor_mut();
        cursor.move_next();
        cursor.move_prev();
        cursor.splice_before(Some(9).into_iter().collect());
        cursor.splice_after(Some(10).into_iter().collect());
        check_links(&amp;m);
        assert_eq!(m.iter().cloned().collect::&lt;Vec&lt;_&gt;&gt;(), &amp;[10, 7, 1, 8, 2, 3, 4, 5, 6, 9]);
        
        /* remove_current not impl'd
        let mut cursor = m.cursor_mut();
        cursor.move_next();
        cursor.move_prev();
        assert_eq!(cursor.remove_current(), None);
        cursor.move_next();
        cursor.move_next();
        assert_eq!(cursor.remove_current(), Some(7));
        cursor.move_prev();
        cursor.move_prev();
        cursor.move_prev();
        assert_eq!(cursor.remove_current(), Some(9));
        cursor.move_next();
        assert_eq!(cursor.remove_current(), Some(10));
        check_links(&amp;m);
        assert_eq!(m.iter().cloned().collect::&lt;Vec&lt;_&gt;&gt;(), &amp;[1, 8, 2, 3, 4, 5, 6]);
        */

        let mut cursor = m.cursor_mut();
        cursor.move_next();
        let mut p: LinkedList&lt;u32&gt; = LinkedList::new();
        p.extend([100, 101, 102, 103]);
        let mut q: LinkedList&lt;u32&gt; = LinkedList::new();
        q.extend([200, 201, 202, 203]);
        cursor.splice_after(p);
        cursor.splice_before(q);
        check_links(&amp;m);
        assert_eq!(
            m.iter().cloned().collect::&lt;Vec&lt;_&gt;&gt;(),
            &amp;[200, 201, 202, 203, 1, 100, 101, 102, 103, 8, 2, 3, 4, 5, 6]
        );
        let mut cursor = m.cursor_mut();
        cursor.move_next();
        cursor.move_prev();
        let tmp = cursor.split_before();
        assert_eq!(m.into_iter().collect::&lt;Vec&lt;_&gt;&gt;(), &amp;[]);
        m = tmp;
        let mut cursor = m.cursor_mut();
        cursor.move_next();
        cursor.move_next();
        cursor.move_next();
        cursor.move_next();
        cursor.move_next();
        cursor.move_next();
        cursor.move_next();
        let tmp = cursor.split_after();
        assert_eq!(tmp.into_iter().collect::&lt;Vec&lt;_&gt;&gt;(), &amp;[102, 103, 8, 2, 3, 4, 5, 6]);
        check_links(&amp;m);
        assert_eq!(m.iter().cloned().collect::&lt;Vec&lt;_&gt;&gt;(), &amp;[200, 201, 202, 203, 1, 100, 101]);
    }

    fn check_links&lt;T&gt;(_list: &amp;LinkedList&lt;T&gt;) {
        // would be good to do this!
    }
</code></pre>
<p>Moment of truth!</p>
<pre><code class="language-text">cargo test

   Compiling linked-list v0.0.3
    Finished test [unoptimized + debuginfo] target(s) in 1.03s
     Running unittests src\lib.rs

running 14 tests
test test::test_basic_front ... ok
test test::test_basic ... ok
test test::test_debug ... ok
test test::test_iterator_mut_double_end ... ok
test test::test_ord ... ok
test test::test_cursor_move_peek ... FAILED
test test::test_cursor_mut_insert ... FAILED
test test::test_iterator ... ok
test test::test_mut_iter ... ok
test test::test_eq ... ok
test test::test_rev_iter ... ok
test test::test_iterator_double_end ... ok
test test::test_hashmap ... ok
test test::test_ord_nan ... ok

failures:

---- test::test_cursor_move_peek stdout ----
thread 'test::test_cursor_move_peek' panicked at 'assertion failed: `(left == right)`
  left: `None`,
 right: `Some(1)`', src\lib.rs:1079:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

---- test::test_cursor_mut_insert stdout ----
thread 'test::test_cursor_mut_insert' panicked at 'assertion failed: `(left == right)`
  left: `[200, 201, 202, 203, 10, 100, 101, 102, 103, 7, 1, 8, 2, 3, 4, 5, 6, 9]`,
 right: `[200, 201, 202, 203, 1, 100, 101, 102, 103, 8, 2, 3, 4, 5, 6]`', src\lib.rs:1153:9


failures:
    test::test_cursor_move_peek
    test::test_cursor_mut_insert

test result: FAILED. 12 passed; 2 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>I'll admit, I had some hubris here and was hoping I nailed it. This is why we write tests (but maybe I just did a bad job of porting the tests..?).</p>
<p>What's the first failure?</p>
<pre><code class="language-rust ignore">let mut m: LinkedList&lt;u32&gt; = LinkedList::new();
m.extend([1, 2, 3, 4, 5, 6]);
let mut cursor = m.cursor_mut();

cursor.move_next();
assert_eq!(cursor.current(), Some(&amp;mut 1));
assert_eq!(cursor.peek_next(), Some(&amp;mut 2));
assert_eq!(cursor.peek_prev(), None);
assert_eq!(cursor.index(), Some(0));

cursor.move_prev();
assert_eq!(cursor.current(), None);
assert_eq!(cursor.peek_next(), Some(&amp;mut 1)); // DIES HERE
</code></pre>
<p>Geez I really messed up some basic functionality. Wait,</p>
<blockquote>
<p>Head empty, Option methods and (omitted) compiler errors do all thinking now.</p>
</blockquote>
<p>Well I am nothing if not honest.</p>
<pre><code class="language-rust ignore">pub fn peek_next(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt; {
    unsafe {
        self.cur
            .and_then(|node| (*node.as_ptr()).back)
            .map(|node| &amp;mut (*node.as_ptr()).elem)
    }
}
</code></pre>
<p>...Yeah this is just wrong. If <code>self.cur</code> is None, we aren't just supposed to give up, we need to check <code>self.list.front</code> too, because we're on the ghost! So we just need to add an or_else to the chain:</p>
<pre><code class="language-rust ignore">pub fn peek_next(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt; {
    unsafe {
        self.cur
            .and_then(|node| (*node.as_ptr()).back)
            .or_else(|| self.list.front)
            .map(|node| &amp;mut (*node.as_ptr()).elem)
    }
}

pub fn peek_prev(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt; {
    unsafe {
        self.cur
            .and_then(|node| (*node.as_ptr()).front)
            .or_else(|| self.list.back)
            .map(|node| &amp;mut (*node.as_ptr()).elem)
    }
}
</code></pre>
<p>Did that fix it?</p>
<pre><code class="language-text">---- test::test_cursor_move_peek stdout ----
thread 'test::test_cursor_move_peek' panicked at 'assertion failed: `(left == right)`
  left: `Some(6)`,
 right: `None`', src\lib.rs:1078:9
</code></pre>
<p>Wait now it's wrong <em>further back</em>. Ok I need to stop head-emptying peek because apparently it's a lot harder than I was willing to give it credit for. Just trying to blindly chain these cases is a disaster, let's have a proper if for the cases of ghost vs not:</p>
<pre><code class="language-rust ignore">pub fn peek_next(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt; {
    unsafe {
        let next = if let Some(cur) = self.cur {
            // Normal case, try to follow the cur node's back pointer
            (*cur.as_ptr()).back
        } else {
            // Ghost case, try to use the list's front pointer
            self.list.front
        };

        // Yield the element if the next node exists
        next.map(|node| &amp;mut (*node.as_ptr()).elem)
    }
}

pub fn peek_prev(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt; {
    unsafe {
        let prev = if let Some(cur) = self.cur {
            // Normal case, try to follow the cur node's front pointer
            (*cur.as_ptr()).front
        } else {
            // Ghost case, try to use the list's back pointer
            self.list.back
        };

        // Yield the element if the prev node exists
        prev.map(|node| &amp;mut (*node.as_ptr()).elem)
    }
}
</code></pre>
<p>Feelin' confident about this one!</p>
<pre><code class="language-text">failures:

---- test::test_cursor_mut_insert stdout ----
thread 'test::test_cursor_mut_insert' panicked at 'assertion failed: `(left == right)`
  left: `[200, 201, 202, 203, 10, 100, 101, 102, 103, 7, 1, 8, 2, 3, 4, 5, 6, 9]`,
 right: `[200, 201, 202, 203, 1, 100, 101, 102, 103, 8, 2, 3, 4, 5, 6]`', src\lib.rs:1168:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    test::test_cursor_mut_insert

test result: FAILED. 13 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>Yesss. Ok one more failure to go... oh.</p>
<p>Did you notice the part where I commented out some code for testing remove_current? Yeah I wasn't paying attention to the fact that this test is stateful. Let's just create a new list with the state the remove_current part would have left us in:</p>
<pre><code class="language-rust ignore">let mut m: LinkedList&lt;u32&gt; = LinkedList::new();
m.extend([1, 8, 2, 3, 4, 5, 6]);
</code></pre>
<pre><code class="language-text"> cargo test
   Compiling linked-list v0.0.3
    Finished test [unoptimized + debuginfo] target(s) in 0.70s
     Running unittests src\lib.rs

running 14 tests
test test::test_basic_front ... ok
test test::test_basic ... ok
test test::test_cursor_move_peek ... ok
test test::test_eq ... ok
test test::test_cursor_mut_insert ... ok
test test::test_iterator ... ok
test test::test_iterator_double_end ... ok
test test::test_ord_nan ... ok
test test::test_mut_iter ... ok
test test::test_hashmap ... ok
test test::test_debug ... ok
test test::test_ord ... ok
test test::test_iterator_mut_double_end ... ok
test test::test_rev_iter ... ok

test result: ok. 14 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests linked-list

running 1 test
test src\lib.rs - assert_properties::iter_mut_invariant (line 803) - compile fail ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.12s
</code></pre>
<p>Heyyyy look at thaaat... ok now I'm getting paranoid. Let's properly fill in check_links and test it under miri:</p>
<pre><code class="language-rust ignore">fn check_links&lt;T: Eq + std::fmt::Debug&gt;(list: &amp;LinkedList&lt;T&gt;) {
    let from_front: Vec&lt;_&gt; = list.iter().collect();
    let from_back: Vec&lt;_&gt; = list.iter().rev().collect();
    let re_reved: Vec&lt;_&gt; = from_back.into_iter().rev().collect();

    assert_eq!(from_front, re_reved);
}
</code></pre>
<p>Is this the best way to do this? No. Is it fine? Yes.</p>
<pre><code class="language-text">$env:MIRIFLAGS=&quot;-Zmiri-tag-raw-pointers&quot;
cargo miri test
   Compiling linked-list v0.0.3
    Finished test [unoptimized + debuginfo] target(s) in 0.25s
     Running unittests src\lib.rs

running 14 tests
test test::test_basic ... ok
test test::test_basic_front ... ok
test test::test_cursor_move_peek ... ok
test test::test_cursor_mut_insert ... ok
test test::test_debug ... ok
test test::test_eq ... ok
test test::test_hashmap ... ok
test test::test_iterator ... ok
test test::test_iterator_double_end ... ok
test test::test_iterator_mut_double_end ... ok
test test::test_mut_iter ... ok
test test::test_ord ... ok
test test::test_ord_nan ... ok
test test::test_rev_iter ... ok

test result: ok. 14 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests linked-list

running 1 test
test src\lib.rs - assert_properties::iter_mut_invariant (line 803) - compile fail ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.10s
</code></pre>
<p>DONE.</p>
<p>Done.</p>
<p>We did it. We made a god damn production-quality LinkedList, with basically all the same functionality as the one in std. Are we missing little convenience methods here and there? Absolutely. Will I add them into the final published version of the crate? Probably!</p>
<p>But, I am, So Very Tired.</p>
<p>So. We win.</p>
<p>Wait fuck. We're being production quality. Ok one last final boss: clippy.</p>
<pre><code class="language-text">cargo clippy

cargo clippy
    Checking linked-list v0.0.3 (C:\Users\ninte\dev\contain\linked-list)
warning: redundant pattern matching, consider using `is_some()`
   --&gt; src\lib.rs:189:19
    |
189 |         while let Some(_) = self.pop_front() { }
    |         ----------^^^^^^^------------------- help: try this: `while self.pop_front().is_some()`
    |
    = note: `#[warn(clippy::redundant_pattern_matching)]` on by default
    = note: this will change drop order of the result, as well as all temporaries
    = note: add `#[allow(clippy::redundant_pattern_matching)]` if this is important
    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#redundant_pattern_matching

warning: method `into_iter` can be confused for the standard trait method `std::iter::IntoIterator::into_iter`
   --&gt; src\lib.rs:210:5
    |
210 | /     pub fn into_iter(self) -&gt; IntoIter&lt;T&gt; {
211 | |         IntoIter {
212 | |             list: self
213 | |         }
214 | |     }
    | |_____^
    |
    = note: `#[warn(clippy::should_implement_trait)]` on by default
    = help: consider implementing the trait `std::iter::IntoIterator` or choosing a less ambiguous method name
    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#should_implement_trait

warning: redundant pattern matching, consider using `is_some()`
   --&gt; src\lib.rs:228:19
    |
228 |         while let Some(_) = self.pop_front() { }
    |         ----------^^^^^^^------------------- help: try this: `while self.pop_front().is_some()`
    |
    = note: this will change drop order of the result, as well as all temporaries
    = note: add `#[allow(clippy::redundant_pattern_matching)]` if this is important
    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#redundant_pattern_matching

warning: re-implementing `PartialEq::ne` is unnecessary
   --&gt; src\lib.rs:275:5
    |
275 | /     fn ne(&amp;self, other: &amp;Self) -&gt; bool {
276 | |         self.len() != other.len() || self.iter().ne(other)
277 | |     }
    | |_____^
    |
    = note: `#[warn(clippy::partialeq_ne_impl)]` on by default
    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#partialeq_ne_impl

warning: `linked-list` (lib) generated 4 warnings
    Finished dev [unoptimized + debuginfo] target(s) in 0.29s
</code></pre>
<p>Alright clippy, let's do this.</p>
<p>Complaint 1 (and 3): we use <code>while let Some(_) = </code> instead of <code>while .is_some()</code>. The loop is empty so this truly doesn't matter but ok fine, clippy, I'll do things your way.</p>
<p>Complaint 2: We have an actual inherent into_iter method. Wait, what <em>checks std</em> ok, point to clippy. IntoIterator is in the prelude (and basically a lang item) so, we don't need an inherent version too.</p>
<p>Complaint 4: we copied a weird cargocult from std. <em>shrug</em> fine I'll remove it.</p>
<pre><code class="language-text">cargo clippy
    Finished dev [unoptimized + debuginfo] target(s) in 0.00s
</code></pre>
<p>Nice. Just one last thing to do before calling it production quality: fmt.</p>
<pre><code class="language-text">cargo fmt
</code></pre>
<p>...yeah it added some newlines and removed some trailing whitespace. Nothing interesting.</p>
<p><strong>WE ARE NOW TRULY FINALLY DONE!!!!!!!!!!!!!!!!!!!!!</strong></p>
<h1><a class="header" href="#final-code-4" id="final-code-4">Final Code</a></h1>
<p>I can't believe I actually just made you sit through me actually reimplementing std::collections::LinkedList from scratch, with all the fiddly little pedantry and mistakes I made along the way.</p>
<p>I did it, the book is done, I can finally rest.</p>
<p>Alright, here's all 1200 lines of our complete rewrite of  in all of its glory. This should be the same text as <a href="https://github.com/contain-rs/linked-list/commit/5b69cc29454595172a5167a09277660342b78092">this commit</a>.</p>
<p>I'll put some polish and docs back on and publish 0.1.0 later.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cmp::Ordering;
use std::fmt::{self, Debug};
use std::hash::{Hash, Hasher};
use std::iter::FromIterator;
use std::marker::PhantomData;
use std::ptr::NonNull;

pub struct LinkedList&lt;T&gt; {
    front: Link&lt;T&gt;,
    back: Link&lt;T&gt;,
    len: usize,
    _boo: PhantomData&lt;T&gt;,
}

type Link&lt;T&gt; = Option&lt;NonNull&lt;Node&lt;T&gt;&gt;&gt;;

struct Node&lt;T&gt; {
    front: Link&lt;T&gt;,
    back: Link&lt;T&gt;,
    elem: T,
}

pub struct Iter&lt;'a, T&gt; {
    front: Link&lt;T&gt;,
    back: Link&lt;T&gt;,
    len: usize,
    _boo: PhantomData&lt;&amp;'a T&gt;,
}

pub struct IterMut&lt;'a, T&gt; {
    front: Link&lt;T&gt;,
    back: Link&lt;T&gt;,
    len: usize,
    _boo: PhantomData&lt;&amp;'a mut T&gt;,
}

pub struct IntoIter&lt;T&gt; {
    list: LinkedList&lt;T&gt;,
}

pub struct CursorMut&lt;'a, T&gt; {
    list: &amp;'a mut LinkedList&lt;T&gt;,
    cur: Link&lt;T&gt;,
    index: Option&lt;usize&gt;,
}

impl&lt;T&gt; LinkedList&lt;T&gt; {
    pub fn new() -&gt; Self {
        Self {
            front: None,
            back: None,
            len: 0,
            _boo: PhantomData,
        }
    }

    pub fn push_front(&amp;mut self, elem: T) {
        // SAFETY: it's a linked-list, what do you want?
        unsafe {
            let new = NonNull::new_unchecked(Box::into_raw(Box::new(Node {
                front: None,
                back: None,
                elem,
            })));
            if let Some(old) = self.front {
                // Put the new front before the old one
                (*old.as_ptr()).front = Some(new);
                (*new.as_ptr()).back = Some(old);
            } else {
                // If there's no front, then we're the empty list and need
                // to set the back too.
                self.back = Some(new);
            }
            // These things always happen!
            self.front = Some(new);
            self.len += 1;
        }
    }

    pub fn push_back(&amp;mut self, elem: T) {
        // SAFETY: it's a linked-list, what do you want?
        unsafe {
            let new = NonNull::new_unchecked(Box::into_raw(Box::new(Node {
                back: None,
                front: None,
                elem,
            })));
            if let Some(old) = self.back {
                // Put the new back before the old one
                (*old.as_ptr()).back = Some(new);
                (*new.as_ptr()).front = Some(old);
            } else {
                // If there's no back, then we're the empty list and need
                // to set the front too.
                self.front = Some(new);
            }
            // These things always happen!
            self.back = Some(new);
            self.len += 1;
        }
    }

    pub fn pop_front(&amp;mut self) -&gt; Option&lt;T&gt; {
        unsafe {
            // Only have to do stuff if there is a front node to pop.
            self.front.map(|node| {
                // Bring the Box back to life so we can move out its value and
                // Drop it (Box continues to magically understand this for us).
                let boxed_node = Box::from_raw(node.as_ptr());
                let result = boxed_node.elem;

                // Make the next node into the new front.
                self.front = boxed_node.back;
                if let Some(new) = self.front {
                    // Cleanup its reference to the removed node
                    (*new.as_ptr()).front = None;
                } else {
                    // If the front is now null, then this list is now empty!
                    self.back = None;
                }

                self.len -= 1;
                result
                // Box gets implicitly freed here, knows there is no T.
            })
        }
    }

    pub fn pop_back(&amp;mut self) -&gt; Option&lt;T&gt; {
        unsafe {
            // Only have to do stuff if there is a back node to pop.
            self.back.map(|node| {
                // Bring the Box front to life so we can move out its value and
                // Drop it (Box continues to magically understand this for us).
                let boxed_node = Box::from_raw(node.as_ptr());
                let result = boxed_node.elem;

                // Make the next node into the new back.
                self.back = boxed_node.front;
                if let Some(new) = self.back {
                    // Cleanup its reference to the removed node
                    (*new.as_ptr()).back = None;
                } else {
                    // If the back is now null, then this list is now empty!
                    self.front = None;
                }

                self.len -= 1;
                result
                // Box gets implicitly freed here, knows there is no T.
            })
        }
    }

    pub fn front(&amp;self) -&gt; Option&lt;&amp;T&gt; {
        unsafe { self.front.map(|node| &amp;(*node.as_ptr()).elem) }
    }

    pub fn front_mut(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt; {
        unsafe { self.front.map(|node| &amp;mut (*node.as_ptr()).elem) }
    }

    pub fn back(&amp;self) -&gt; Option&lt;&amp;T&gt; {
        unsafe { self.back.map(|node| &amp;(*node.as_ptr()).elem) }
    }

    pub fn back_mut(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt; {
        unsafe { self.back.map(|node| &amp;mut (*node.as_ptr()).elem) }
    }

    pub fn len(&amp;self) -&gt; usize {
        self.len
    }

    pub fn is_empty(&amp;self) -&gt; bool {
        self.len == 0
    }

    pub fn clear(&amp;mut self) {
        // Oh look it's drop again
        while self.pop_front().is_some() {}
    }

    pub fn iter(&amp;self) -&gt; Iter&lt;T&gt; {
        Iter {
            front: self.front,
            back: self.back,
            len: self.len,
            _boo: PhantomData,
        }
    }

    pub fn iter_mut(&amp;mut self) -&gt; IterMut&lt;T&gt; {
        IterMut {
            front: self.front,
            back: self.back,
            len: self.len,
            _boo: PhantomData,
        }
    }

    pub fn cursor_mut(&amp;mut self) -&gt; CursorMut&lt;T&gt; {
        CursorMut {
            list: self,
            cur: None,
            index: None,
        }
    }
}

impl&lt;T&gt; Drop for LinkedList&lt;T&gt; {
    fn drop(&amp;mut self) {
        // Pop until we have to stop
        while self.pop_front().is_some() {}
    }
}

impl&lt;T&gt; Default for LinkedList&lt;T&gt; {
    fn default() -&gt; Self {
        Self::new()
    }
}

impl&lt;T: Clone&gt; Clone for LinkedList&lt;T&gt; {
    fn clone(&amp;self) -&gt; Self {
        let mut new_list = Self::new();
        for item in self {
            new_list.push_back(item.clone());
        }
        new_list
    }
}

impl&lt;T&gt; Extend&lt;T&gt; for LinkedList&lt;T&gt; {
    fn extend&lt;I: IntoIterator&lt;Item = T&gt;&gt;(&amp;mut self, iter: I) {
        for item in iter {
            self.push_back(item);
        }
    }
}

impl&lt;T&gt; FromIterator&lt;T&gt; for LinkedList&lt;T&gt; {
    fn from_iter&lt;I: IntoIterator&lt;Item = T&gt;&gt;(iter: I) -&gt; Self {
        let mut list = Self::new();
        list.extend(iter);
        list
    }
}

impl&lt;T: Debug&gt; Debug for LinkedList&lt;T&gt; {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        f.debug_list().entries(self).finish()
    }
}

impl&lt;T: PartialEq&gt; PartialEq for LinkedList&lt;T&gt; {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool {
        self.len() == other.len() &amp;&amp; self.iter().eq(other)
    }
}

impl&lt;T: Eq&gt; Eq for LinkedList&lt;T&gt; {}

impl&lt;T: PartialOrd&gt; PartialOrd for LinkedList&lt;T&gt; {
    fn partial_cmp(&amp;self, other: &amp;Self) -&gt; Option&lt;Ordering&gt; {
        self.iter().partial_cmp(other)
    }
}

impl&lt;T: Ord&gt; Ord for LinkedList&lt;T&gt; {
    fn cmp(&amp;self, other: &amp;Self) -&gt; Ordering {
        self.iter().cmp(other)
    }
}

impl&lt;T: Hash&gt; Hash for LinkedList&lt;T&gt; {
    fn hash&lt;H: Hasher&gt;(&amp;self, state: &amp;mut H) {
        self.len().hash(state);
        for item in self {
            item.hash(state);
        }
    }
}

impl&lt;'a, T&gt; IntoIterator for &amp;'a LinkedList&lt;T&gt; {
    type IntoIter = Iter&lt;'a, T&gt;;
    type Item = &amp;'a T;

    fn into_iter(self) -&gt; Self::IntoIter {
        self.iter()
    }
}

impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {
    type Item = &amp;'a T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        // While self.front == self.back is a tempting condition to check here,
        // it won't do the right for yielding the last element! That sort of
        // thing only works for arrays because of &quot;one-past-the-end&quot; pointers.
        if self.len &gt; 0 {
            // We could unwrap front, but this is safer and easier
            self.front.map(|node| unsafe {
                self.len -= 1;
                self.front = (*node.as_ptr()).back;
                &amp;(*node.as_ptr()).elem
            })
        } else {
            None
        }
    }

    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) {
        (self.len, Some(self.len))
    }
}

impl&lt;'a, T&gt; DoubleEndedIterator for Iter&lt;'a, T&gt; {
    fn next_back(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        if self.len &gt; 0 {
            self.back.map(|node| unsafe {
                self.len -= 1;
                self.back = (*node.as_ptr()).front;
                &amp;(*node.as_ptr()).elem
            })
        } else {
            None
        }
    }
}

impl&lt;'a, T&gt; ExactSizeIterator for Iter&lt;'a, T&gt; {
    fn len(&amp;self) -&gt; usize {
        self.len
    }
}

impl&lt;'a, T&gt; IntoIterator for &amp;'a mut LinkedList&lt;T&gt; {
    type IntoIter = IterMut&lt;'a, T&gt;;
    type Item = &amp;'a mut T;

    fn into_iter(self) -&gt; Self::IntoIter {
        self.iter_mut()
    }
}

impl&lt;'a, T&gt; Iterator for IterMut&lt;'a, T&gt; {
    type Item = &amp;'a mut T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        // While self.front == self.back is a tempting condition to check here,
        // it won't do the right for yielding the last element! That sort of
        // thing only works for arrays because of &quot;one-past-the-end&quot; pointers.
        if self.len &gt; 0 {
            // We could unwrap front, but this is safer and easier
            self.front.map(|node| unsafe {
                self.len -= 1;
                self.front = (*node.as_ptr()).back;
                &amp;mut (*node.as_ptr()).elem
            })
        } else {
            None
        }
    }

    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) {
        (self.len, Some(self.len))
    }
}

impl&lt;'a, T&gt; DoubleEndedIterator for IterMut&lt;'a, T&gt; {
    fn next_back(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        if self.len &gt; 0 {
            self.back.map(|node| unsafe {
                self.len -= 1;
                self.back = (*node.as_ptr()).front;
                &amp;mut (*node.as_ptr()).elem
            })
        } else {
            None
        }
    }
}

impl&lt;'a, T&gt; ExactSizeIterator for IterMut&lt;'a, T&gt; {
    fn len(&amp;self) -&gt; usize {
        self.len
    }
}

impl&lt;T&gt; IntoIterator for LinkedList&lt;T&gt; {
    type IntoIter = IntoIter&lt;T&gt;;
    type Item = T;

    fn into_iter(self) -&gt; Self::IntoIter {
        IntoIter { list: self }
    }
}

impl&lt;T&gt; Iterator for IntoIter&lt;T&gt; {
    type Item = T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.list.pop_front()
    }

    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) {
        (self.list.len, Some(self.list.len))
    }
}

impl&lt;T&gt; DoubleEndedIterator for IntoIter&lt;T&gt; {
    fn next_back(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.list.pop_back()
    }
}

impl&lt;T&gt; ExactSizeIterator for IntoIter&lt;T&gt; {
    fn len(&amp;self) -&gt; usize {
        self.list.len
    }
}

impl&lt;'a, T&gt; CursorMut&lt;'a, T&gt; {
    pub fn index(&amp;self) -&gt; Option&lt;usize&gt; {
        self.index
    }

    pub fn move_next(&amp;mut self) {
        if let Some(cur) = self.cur {
            unsafe {
                // We're on a real element, go to its next (back)
                self.cur = (*cur.as_ptr()).back;
                if self.cur.is_some() {
                    *self.index.as_mut().unwrap() += 1;
                } else {
                    // We just walked to the ghost, no more index
                    self.index = None;
                }
            }
        } else if !self.list.is_empty() {
            // We're at the ghost, and there is a real front, so move to it!
            self.cur = self.list.front;
            self.index = Some(0)
        } else {
            // We're at the ghost, but that's the only element... do nothing.
        }
    }

    pub fn move_prev(&amp;mut self) {
        if let Some(cur) = self.cur {
            unsafe {
                // We're on a real element, go to its previous (front)
                self.cur = (*cur.as_ptr()).front;
                if self.cur.is_some() {
                    *self.index.as_mut().unwrap() -= 1;
                } else {
                    // We just walked to the ghost, no more index
                    self.index = None;
                }
            }
        } else if !self.list.is_empty() {
            // We're at the ghost, and there is a real back, so move to it!
            self.cur = self.list.back;
            self.index = Some(self.list.len - 1)
        } else {
            // We're at the ghost, but that's the only element... do nothing.
        }
    }

    pub fn current(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt; {
        unsafe { self.cur.map(|node| &amp;mut (*node.as_ptr()).elem) }
    }

    pub fn peek_next(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt; {
        unsafe {
            let next = if let Some(cur) = self.cur {
                // Normal case, try to follow the cur node's back pointer
                (*cur.as_ptr()).back
            } else {
                // Ghost case, try to use the list's front pointer
                self.list.front
            };

            // Yield the element if the next node exists
            next.map(|node| &amp;mut (*node.as_ptr()).elem)
        }
    }

    pub fn peek_prev(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt; {
        unsafe {
            let prev = if let Some(cur) = self.cur {
                // Normal case, try to follow the cur node's front pointer
                (*cur.as_ptr()).front
            } else {
                // Ghost case, try to use the list's back pointer
                self.list.back
            };

            // Yield the element if the prev node exists
            prev.map(|node| &amp;mut (*node.as_ptr()).elem)
        }
    }

    pub fn split_before(&amp;mut self) -&gt; LinkedList&lt;T&gt; {
        // We have this:
        //
        //     list.front -&gt; A &lt;-&gt; B &lt;-&gt; C &lt;-&gt; D &lt;- list.back
        //                               ^
        //                              cur
        //
        //
        // And we want to produce this:
        //
        //     list.front -&gt; C &lt;-&gt; D &lt;- list.back
        //                   ^
        //                  cur
        //
        //
        //    return.front -&gt; A &lt;-&gt; B &lt;- return.back
        //
        if let Some(cur) = self.cur {
            // We are pointing at a real element, so the list is non-empty.
            unsafe {
                // Current state
                let old_len = self.list.len;
                let old_idx = self.index.unwrap();
                let prev = (*cur.as_ptr()).front;

                // What self will become
                let new_len = old_len - old_idx;
                let new_front = self.cur;
                let new_back = self.list.back;
                let new_idx = Some(0);

                // What the output will become
                let output_len = old_len - new_len;
                let output_front = self.list.front;
                let output_back = prev;

                // Break the links between cur and prev
                if let Some(prev) = prev {
                    (*cur.as_ptr()).front = None;
                    (*prev.as_ptr()).back = None;
                }

                // Produce the result:
                self.list.len = new_len;
                self.list.front = new_front;
                self.list.back = new_back;
                self.index = new_idx;

                LinkedList {
                    front: output_front,
                    back: output_back,
                    len: output_len,
                    _boo: PhantomData,
                }
            }
        } else {
            // We're at the ghost, just replace our list with an empty one.
            // No other state needs to be changed.
            std::mem::replace(self.list, LinkedList::new())
        }
    }

    pub fn split_after(&amp;mut self) -&gt; LinkedList&lt;T&gt; {
        // We have this:
        //
        //     list.front -&gt; A &lt;-&gt; B &lt;-&gt; C &lt;-&gt; D &lt;- list.back
        //                         ^
        //                        cur
        //
        //
        // And we want to produce this:
        //
        //     list.front -&gt; A &lt;-&gt; B &lt;- list.back
        //                         ^
        //                        cur
        //
        //
        //    return.front -&gt; C &lt;-&gt; D &lt;- return.back
        //
        if let Some(cur) = self.cur {
            // We are pointing at a real element, so the list is non-empty.
            unsafe {
                // Current state
                let old_len = self.list.len;
                let old_idx = self.index.unwrap();
                let next = (*cur.as_ptr()).back;

                // What self will become
                let new_len = old_idx + 1;
                let new_back = self.cur;
                let new_front = self.list.front;
                let new_idx = Some(old_idx);

                // What the output will become
                let output_len = old_len - new_len;
                let output_front = next;
                let output_back = self.list.back;

                // Break the links between cur and next
                if let Some(next) = next {
                    (*cur.as_ptr()).back = None;
                    (*next.as_ptr()).front = None;
                }

                // Produce the result:
                self.list.len = new_len;
                self.list.front = new_front;
                self.list.back = new_back;
                self.index = new_idx;

                LinkedList {
                    front: output_front,
                    back: output_back,
                    len: output_len,
                    _boo: PhantomData,
                }
            }
        } else {
            // We're at the ghost, just replace our list with an empty one.
            // No other state needs to be changed.
            std::mem::replace(self.list, LinkedList::new())
        }
    }

    pub fn splice_before(&amp;mut self, mut input: LinkedList&lt;T&gt;) {
        // We have this:
        //
        // input.front -&gt; 1 &lt;-&gt; 2 &lt;- input.back
        //
        // list.front -&gt; A &lt;-&gt; B &lt;-&gt; C &lt;- list.back
        //                     ^
        //                    cur
        //
        //
        // Becoming this:
        //
        // list.front -&gt; A &lt;-&gt; 1 &lt;-&gt; 2 &lt;-&gt; B &lt;-&gt; C &lt;- list.back
        //                                 ^
        //                                cur
        //
        unsafe {
            // We can either `take` the input's pointers or `mem::forget`
            // it. Using `take` is more responsible in case we ever do custom
            // allocators or something that also needs to be cleaned up!
            if input.is_empty() {
                // Input is empty, do nothing.
            } else if let Some(cur) = self.cur {
                // Both lists are non-empty
                let in_front = input.front.take().unwrap();
                let in_back = input.back.take().unwrap();

                if let Some(prev) = (*cur.as_ptr()).front {
                    // General Case, no boundaries, just internal fixups
                    (*prev.as_ptr()).back = Some(in_front);
                    (*in_front.as_ptr()).front = Some(prev);
                    (*cur.as_ptr()).front = Some(in_back);
                    (*in_back.as_ptr()).back = Some(cur);
                } else {
                    // No prev, we're appending to the front
                    (*cur.as_ptr()).front = Some(in_back);
                    (*in_back.as_ptr()).back = Some(cur);
                    self.list.front = Some(in_front);
                }
                // Index moves forward by input length
                *self.index.as_mut().unwrap() += input.len;
            } else if let Some(back) = self.list.back {
                // We're on the ghost but non-empty, append to the back
                let in_front = input.front.take().unwrap();
                let in_back = input.back.take().unwrap();

                (*back.as_ptr()).back = Some(in_front);
                (*in_front.as_ptr()).front = Some(back);
                self.list.back = Some(in_back);
            } else {
                // We're empty, become the input, remain on the ghost
                std::mem::swap(self.list, &amp;mut input);
            }

            self.list.len += input.len;
            // Not necessary but Polite To Do
            input.len = 0;

            // Input dropped here
        }
    }

    pub fn splice_after(&amp;mut self, mut input: LinkedList&lt;T&gt;) {
        // We have this:
        //
        // input.front -&gt; 1 &lt;-&gt; 2 &lt;- input.back
        //
        // list.front -&gt; A &lt;-&gt; B &lt;-&gt; C &lt;- list.back
        //                     ^
        //                    cur
        //
        //
        // Becoming this:
        //
        // list.front -&gt; A &lt;-&gt; B &lt;-&gt; 1 &lt;-&gt; 2 &lt;-&gt; C &lt;- list.back
        //                     ^
        //                    cur
        //
        unsafe {
            // We can either `take` the input's pointers or `mem::forget`
            // it. Using `take` is more responsible in case we ever do custom
            // allocators or something that also needs to be cleaned up!
            if input.is_empty() {
                // Input is empty, do nothing.
            } else if let Some(cur) = self.cur {
                // Both lists are non-empty
                let in_front = input.front.take().unwrap();
                let in_back = input.back.take().unwrap();

                if let Some(next) = (*cur.as_ptr()).back {
                    // General Case, no boundaries, just internal fixups
                    (*next.as_ptr()).front = Some(in_back);
                    (*in_back.as_ptr()).back = Some(next);
                    (*cur.as_ptr()).back = Some(in_front);
                    (*in_front.as_ptr()).front = Some(cur);
                } else {
                    // No next, we're appending to the back
                    (*cur.as_ptr()).back = Some(in_front);
                    (*in_front.as_ptr()).front = Some(cur);
                    self.list.back = Some(in_back);
                }
                // Index doesn't change
            } else if let Some(front) = self.list.front {
                // We're on the ghost but non-empty, append to the front
                let in_front = input.front.take().unwrap();
                let in_back = input.back.take().unwrap();

                (*front.as_ptr()).front = Some(in_back);
                (*in_back.as_ptr()).back = Some(front);
                self.list.front = Some(in_front);
            } else {
                // We're empty, become the input, remain on the ghost
                std::mem::swap(self.list, &amp;mut input);
            }

            self.list.len += input.len;
            // Not necessary but Polite To Do
            input.len = 0;

            // Input dropped here
        }
    }
}

unsafe impl&lt;T: Send&gt; Send for LinkedList&lt;T&gt; {}
unsafe impl&lt;T: Sync&gt; Sync for LinkedList&lt;T&gt; {}

unsafe impl&lt;'a, T: Send&gt; Send for Iter&lt;'a, T&gt; {}
unsafe impl&lt;'a, T: Sync&gt; Sync for Iter&lt;'a, T&gt; {}

unsafe impl&lt;'a, T: Send&gt; Send for IterMut&lt;'a, T&gt; {}
unsafe impl&lt;'a, T: Sync&gt; Sync for IterMut&lt;'a, T&gt; {}

#[allow(dead_code)]
fn assert_properties() {
    fn is_send&lt;T: Send&gt;() {}
    fn is_sync&lt;T: Sync&gt;() {}

    is_send::&lt;LinkedList&lt;i32&gt;&gt;();
    is_sync::&lt;LinkedList&lt;i32&gt;&gt;();

    is_send::&lt;IntoIter&lt;i32&gt;&gt;();
    is_sync::&lt;IntoIter&lt;i32&gt;&gt;();

    is_send::&lt;Iter&lt;i32&gt;&gt;();
    is_sync::&lt;Iter&lt;i32&gt;&gt;();

    is_send::&lt;IterMut&lt;i32&gt;&gt;();
    is_sync::&lt;IterMut&lt;i32&gt;&gt;();

    fn linked_list_covariant&lt;'a, T&gt;(x: LinkedList&lt;&amp;'static T&gt;) -&gt; LinkedList&lt;&amp;'a T&gt; {
        x
    }
    fn iter_covariant&lt;'i, 'a, T&gt;(x: Iter&lt;'i, &amp;'static T&gt;) -&gt; Iter&lt;'i, &amp;'a T&gt; {
        x
    }
    fn into_iter_covariant&lt;'a, T&gt;(x: IntoIter&lt;&amp;'static T&gt;) -&gt; IntoIter&lt;&amp;'a T&gt; {
        x
    }

    /// ```compile_fail,E0308
    /// use linked_list::IterMut;
    ///
    /// fn iter_mut_covariant&lt;'i, 'a, T&gt;(x: IterMut&lt;'i, &amp;'static T&gt;) -&gt; IterMut&lt;'i, &amp;'a T&gt; { x }
    /// ```
    fn iter_mut_invariant() {}
}

#[cfg(test)]
mod test {
    use super::LinkedList;

    fn generate_test() -&gt; LinkedList&lt;i32&gt; {
        list_from(&amp;[0, 1, 2, 3, 4, 5, 6])
    }

    fn list_from&lt;T: Clone&gt;(v: &amp;[T]) -&gt; LinkedList&lt;T&gt; {
        v.iter().map(|x| (*x).clone()).collect()
    }

    #[test]
    fn test_basic_front() {
        let mut list = LinkedList::new();

        // Try to break an empty list
        assert_eq!(list.len(), 0);
        assert_eq!(list.pop_front(), None);
        assert_eq!(list.len(), 0);

        // Try to break a one item list
        list.push_front(10);
        assert_eq!(list.len(), 1);
        assert_eq!(list.pop_front(), Some(10));
        assert_eq!(list.len(), 0);
        assert_eq!(list.pop_front(), None);
        assert_eq!(list.len(), 0);

        // Mess around
        list.push_front(10);
        assert_eq!(list.len(), 1);
        list.push_front(20);
        assert_eq!(list.len(), 2);
        list.push_front(30);
        assert_eq!(list.len(), 3);
        assert_eq!(list.pop_front(), Some(30));
        assert_eq!(list.len(), 2);
        list.push_front(40);
        assert_eq!(list.len(), 3);
        assert_eq!(list.pop_front(), Some(40));
        assert_eq!(list.len(), 2);
        assert_eq!(list.pop_front(), Some(20));
        assert_eq!(list.len(), 1);
        assert_eq!(list.pop_front(), Some(10));
        assert_eq!(list.len(), 0);
        assert_eq!(list.pop_front(), None);
        assert_eq!(list.len(), 0);
        assert_eq!(list.pop_front(), None);
        assert_eq!(list.len(), 0);
    }

    #[test]
    fn test_basic() {
        let mut m = LinkedList::new();
        assert_eq!(m.pop_front(), None);
        assert_eq!(m.pop_back(), None);
        assert_eq!(m.pop_front(), None);
        m.push_front(1);
        assert_eq!(m.pop_front(), Some(1));
        m.push_back(2);
        m.push_back(3);
        assert_eq!(m.len(), 2);
        assert_eq!(m.pop_front(), Some(2));
        assert_eq!(m.pop_front(), Some(3));
        assert_eq!(m.len(), 0);
        assert_eq!(m.pop_front(), None);
        m.push_back(1);
        m.push_back(3);
        m.push_back(5);
        m.push_back(7);
        assert_eq!(m.pop_front(), Some(1));

        let mut n = LinkedList::new();
        n.push_front(2);
        n.push_front(3);
        {
            assert_eq!(n.front().unwrap(), &amp;3);
            let x = n.front_mut().unwrap();
            assert_eq!(*x, 3);
            *x = 0;
        }
        {
            assert_eq!(n.back().unwrap(), &amp;2);
            let y = n.back_mut().unwrap();
            assert_eq!(*y, 2);
            *y = 1;
        }
        assert_eq!(n.pop_front(), Some(0));
        assert_eq!(n.pop_front(), Some(1));
    }

    #[test]
    fn test_iterator() {
        let m = generate_test();
        for (i, elt) in m.iter().enumerate() {
            assert_eq!(i as i32, *elt);
        }
        let mut n = LinkedList::new();
        assert_eq!(n.iter().next(), None);
        n.push_front(4);
        let mut it = n.iter();
        assert_eq!(it.size_hint(), (1, Some(1)));
        assert_eq!(it.next().unwrap(), &amp;4);
        assert_eq!(it.size_hint(), (0, Some(0)));
        assert_eq!(it.next(), None);
    }

    #[test]
    fn test_iterator_double_end() {
        let mut n = LinkedList::new();
        assert_eq!(n.iter().next(), None);
        n.push_front(4);
        n.push_front(5);
        n.push_front(6);
        let mut it = n.iter();
        assert_eq!(it.size_hint(), (3, Some(3)));
        assert_eq!(it.next().unwrap(), &amp;6);
        assert_eq!(it.size_hint(), (2, Some(2)));
        assert_eq!(it.next_back().unwrap(), &amp;4);
        assert_eq!(it.size_hint(), (1, Some(1)));
        assert_eq!(it.next_back().unwrap(), &amp;5);
        assert_eq!(it.next_back(), None);
        assert_eq!(it.next(), None);
    }

    #[test]
    fn test_rev_iter() {
        let m = generate_test();
        for (i, elt) in m.iter().rev().enumerate() {
            assert_eq!(6 - i as i32, *elt);
        }
        let mut n = LinkedList::new();
        assert_eq!(n.iter().rev().next(), None);
        n.push_front(4);
        let mut it = n.iter().rev();
        assert_eq!(it.size_hint(), (1, Some(1)));
        assert_eq!(it.next().unwrap(), &amp;4);
        assert_eq!(it.size_hint(), (0, Some(0)));
        assert_eq!(it.next(), None);
    }

    #[test]
    fn test_mut_iter() {
        let mut m = generate_test();
        let mut len = m.len();
        for (i, elt) in m.iter_mut().enumerate() {
            assert_eq!(i as i32, *elt);
            len -= 1;
        }
        assert_eq!(len, 0);
        let mut n = LinkedList::new();
        assert!(n.iter_mut().next().is_none());
        n.push_front(4);
        n.push_back(5);
        let mut it = n.iter_mut();
        assert_eq!(it.size_hint(), (2, Some(2)));
        assert!(it.next().is_some());
        assert!(it.next().is_some());
        assert_eq!(it.size_hint(), (0, Some(0)));
        assert!(it.next().is_none());
    }

    #[test]
    fn test_iterator_mut_double_end() {
        let mut n = LinkedList::new();
        assert!(n.iter_mut().next_back().is_none());
        n.push_front(4);
        n.push_front(5);
        n.push_front(6);
        let mut it = n.iter_mut();
        assert_eq!(it.size_hint(), (3, Some(3)));
        assert_eq!(*it.next().unwrap(), 6);
        assert_eq!(it.size_hint(), (2, Some(2)));
        assert_eq!(*it.next_back().unwrap(), 4);
        assert_eq!(it.size_hint(), (1, Some(1)));
        assert_eq!(*it.next_back().unwrap(), 5);
        assert!(it.next_back().is_none());
        assert!(it.next().is_none());
    }

    #[test]
    fn test_eq() {
        let mut n: LinkedList&lt;u8&gt; = list_from(&amp;[]);
        let mut m = list_from(&amp;[]);
        assert!(n == m);
        n.push_front(1);
        assert!(n != m);
        m.push_back(1);
        assert!(n == m);

        let n = list_from(&amp;[2, 3, 4]);
        let m = list_from(&amp;[1, 2, 3]);
        assert!(n != m);
    }

    #[test]
    fn test_ord() {
        let n = list_from(&amp;[]);
        let m = list_from(&amp;[1, 2, 3]);
        assert!(n &lt; m);
        assert!(m &gt; n);
        assert!(n &lt;= n);
        assert!(n &gt;= n);
    }

    #[test]
    fn test_ord_nan() {
        let nan = 0.0f64 / 0.0;
        let n = list_from(&amp;[nan]);
        let m = list_from(&amp;[nan]);
        assert!(!(n &lt; m));
        assert!(!(n &gt; m));
        assert!(!(n &lt;= m));
        assert!(!(n &gt;= m));

        let n = list_from(&amp;[nan]);
        let one = list_from(&amp;[1.0f64]);
        assert!(!(n &lt; one));
        assert!(!(n &gt; one));
        assert!(!(n &lt;= one));
        assert!(!(n &gt;= one));

        let u = list_from(&amp;[1.0f64, 2.0, nan]);
        let v = list_from(&amp;[1.0f64, 2.0, 3.0]);
        assert!(!(u &lt; v));
        assert!(!(u &gt; v));
        assert!(!(u &lt;= v));
        assert!(!(u &gt;= v));

        let s = list_from(&amp;[1.0f64, 2.0, 4.0, 2.0]);
        let t = list_from(&amp;[1.0f64, 2.0, 3.0, 2.0]);
        assert!(!(s &lt; t));
        assert!(s &gt; one);
        assert!(!(s &lt;= one));
        assert!(s &gt;= one);
    }

    #[test]
    fn test_debug() {
        let list: LinkedList&lt;i32&gt; = (0..10).collect();
        assert_eq!(format!(&quot;{:?}&quot;, list), &quot;[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]&quot;);

        let list: LinkedList&lt;&amp;str&gt; = vec![&quot;just&quot;, &quot;one&quot;, &quot;test&quot;, &quot;more&quot;]
            .iter()
            .copied()
            .collect();
        assert_eq!(format!(&quot;{:?}&quot;, list), r#&quot;[&quot;just&quot;, &quot;one&quot;, &quot;test&quot;, &quot;more&quot;]&quot;#);
    }

    #[test]
    fn test_hashmap() {
        // Check that HashMap works with this as a key

        let list1: LinkedList&lt;i32&gt; = (0..10).collect();
        let list2: LinkedList&lt;i32&gt; = (1..11).collect();
        let mut map = std::collections::HashMap::new();

        assert_eq!(map.insert(list1.clone(), &quot;list1&quot;), None);
        assert_eq!(map.insert(list2.clone(), &quot;list2&quot;), None);

        assert_eq!(map.len(), 2);

        assert_eq!(map.get(&amp;list1), Some(&amp;&quot;list1&quot;));
        assert_eq!(map.get(&amp;list2), Some(&amp;&quot;list2&quot;));

        assert_eq!(map.remove(&amp;list1), Some(&quot;list1&quot;));
        assert_eq!(map.remove(&amp;list2), Some(&quot;list2&quot;));

        assert!(map.is_empty());
    }

    #[test]
    fn test_cursor_move_peek() {
        let mut m: LinkedList&lt;u32&gt; = LinkedList::new();
        m.extend([1, 2, 3, 4, 5, 6]);
        let mut cursor = m.cursor_mut();
        cursor.move_next();
        assert_eq!(cursor.current(), Some(&amp;mut 1));
        assert_eq!(cursor.peek_next(), Some(&amp;mut 2));
        assert_eq!(cursor.peek_prev(), None);
        assert_eq!(cursor.index(), Some(0));
        cursor.move_prev();
        assert_eq!(cursor.current(), None);
        assert_eq!(cursor.peek_next(), Some(&amp;mut 1));
        assert_eq!(cursor.peek_prev(), Some(&amp;mut 6));
        assert_eq!(cursor.index(), None);
        cursor.move_next();
        cursor.move_next();
        assert_eq!(cursor.current(), Some(&amp;mut 2));
        assert_eq!(cursor.peek_next(), Some(&amp;mut 3));
        assert_eq!(cursor.peek_prev(), Some(&amp;mut 1));
        assert_eq!(cursor.index(), Some(1));

        let mut cursor = m.cursor_mut();
        cursor.move_prev();
        assert_eq!(cursor.current(), Some(&amp;mut 6));
        assert_eq!(cursor.peek_next(), None);
        assert_eq!(cursor.peek_prev(), Some(&amp;mut 5));
        assert_eq!(cursor.index(), Some(5));
        cursor.move_next();
        assert_eq!(cursor.current(), None);
        assert_eq!(cursor.peek_next(), Some(&amp;mut 1));
        assert_eq!(cursor.peek_prev(), Some(&amp;mut 6));
        assert_eq!(cursor.index(), None);
        cursor.move_prev();
        cursor.move_prev();
        assert_eq!(cursor.current(), Some(&amp;mut 5));
        assert_eq!(cursor.peek_next(), Some(&amp;mut 6));
        assert_eq!(cursor.peek_prev(), Some(&amp;mut 4));
        assert_eq!(cursor.index(), Some(4));
    }

    #[test]
    fn test_cursor_mut_insert() {
        let mut m: LinkedList&lt;u32&gt; = LinkedList::new();
        m.extend([1, 2, 3, 4, 5, 6]);
        let mut cursor = m.cursor_mut();
        cursor.move_next();
        cursor.splice_before(Some(7).into_iter().collect());
        cursor.splice_after(Some(8).into_iter().collect());
        // check_links(&amp;m);
        assert_eq!(
            m.iter().cloned().collect::&lt;Vec&lt;_&gt;&gt;(),
            &amp;[7, 1, 8, 2, 3, 4, 5, 6]
        );
        let mut cursor = m.cursor_mut();
        cursor.move_next();
        cursor.move_prev();
        cursor.splice_before(Some(9).into_iter().collect());
        cursor.splice_after(Some(10).into_iter().collect());
        check_links(&amp;m);
        assert_eq!(
            m.iter().cloned().collect::&lt;Vec&lt;_&gt;&gt;(),
            &amp;[10, 7, 1, 8, 2, 3, 4, 5, 6, 9]
        );

        /* remove_current not impl'd
        let mut cursor = m.cursor_mut();
        cursor.move_next();
        cursor.move_prev();
        assert_eq!(cursor.remove_current(), None);
        cursor.move_next();
        cursor.move_next();
        assert_eq!(cursor.remove_current(), Some(7));
        cursor.move_prev();
        cursor.move_prev();
        cursor.move_prev();
        assert_eq!(cursor.remove_current(), Some(9));
        cursor.move_next();
        assert_eq!(cursor.remove_current(), Some(10));
        check_links(&amp;m);
        assert_eq!(m.iter().cloned().collect::&lt;Vec&lt;_&gt;&gt;(), &amp;[1, 8, 2, 3, 4, 5, 6]);
        */

        let mut m: LinkedList&lt;u32&gt; = LinkedList::new();
        m.extend([1, 8, 2, 3, 4, 5, 6]);
        let mut cursor = m.cursor_mut();
        cursor.move_next();
        let mut p: LinkedList&lt;u32&gt; = LinkedList::new();
        p.extend([100, 101, 102, 103]);
        let mut q: LinkedList&lt;u32&gt; = LinkedList::new();
        q.extend([200, 201, 202, 203]);
        cursor.splice_after(p);
        cursor.splice_before(q);
        check_links(&amp;m);
        assert_eq!(
            m.iter().cloned().collect::&lt;Vec&lt;_&gt;&gt;(),
            &amp;[200, 201, 202, 203, 1, 100, 101, 102, 103, 8, 2, 3, 4, 5, 6]
        );
        let mut cursor = m.cursor_mut();
        cursor.move_next();
        cursor.move_prev();
        let tmp = cursor.split_before();
        assert_eq!(m.into_iter().collect::&lt;Vec&lt;_&gt;&gt;(), &amp;[]);
        m = tmp;
        let mut cursor = m.cursor_mut();
        cursor.move_next();
        cursor.move_next();
        cursor.move_next();
        cursor.move_next();
        cursor.move_next();
        cursor.move_next();
        cursor.move_next();
        let tmp = cursor.split_after();
        assert_eq!(
            tmp.into_iter().collect::&lt;Vec&lt;_&gt;&gt;(),
            &amp;[102, 103, 8, 2, 3, 4, 5, 6]
        );
        check_links(&amp;m);
        assert_eq!(
            m.iter().cloned().collect::&lt;Vec&lt;_&gt;&gt;(),
            &amp;[200, 201, 202, 203, 1, 100, 101]
        );
    }

    fn check_links&lt;T: Eq + std::fmt::Debug&gt;(list: &amp;LinkedList&lt;T&gt;) {
        let from_front: Vec&lt;_&gt; = list.iter().collect();
        let from_back: Vec&lt;_&gt; = list.iter().rev().collect();
        let re_reved: Vec&lt;_&gt; = from_back.into_iter().rev().collect();

        assert_eq!(from_front, re_reved);
    }
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#a-bunch-of-silly-lists" id="a-bunch-of-silly-lists">A Bunch of Silly Lists</a></h1>
<p>Alright. That's it. We made all the lists.</p>
<p>ahahahaha</p>
<p>No</p>
<p>There's always more lists.</p>
<p>This chapter is a living document of the more ridiculous linked lists and how
they interact with Rust.</p>
<ol>
<li><a href="infinity-double-single.html">The Double Single</a></li>
<li><a href="infinity-stack-allocated.html">The Stack Allocated List</a></li>
<li>The Self-Referential Arena List?</li>
<li>The GhostCell List?</li>
</ol>
<h1><a class="header" href="#the-double-singly-linked-list" id="the-double-singly-linked-list">The Double Singly-Linked List</a></h1>
<p>We struggled with doubly-linked lists because they have tangled ownership
semantics: no node strictly owns any other node. However we struggled
with this because we brought in our preconceived notions of what a linked
list <em>is</em>. Namely, we assumed that all the links go in the same direction.</p>
<p>Instead, we can smash our list into two halves: one going to the left,
and one going to the right:</p>
<pre><code class="language-rust ignore">// lib.rs
// ...
pub mod silly1;     // NEW!
</code></pre>
<pre><code class="language-rust ignore">// silly1.rs
use crate::second::List as Stack;

struct List&lt;T&gt; {
    left: Stack&lt;T&gt;,
    right: Stack&lt;T&gt;,
}
</code></pre>
<p>Now, rather than having a mere safe stack, we have a general purpose list.
We can grow the list leftwards or rightwards by pushing onto either stack.
We can also &quot;walk&quot; along the list by popping values off one end and onto the
other. To avoid needless allocations, we're going to copy the source of
our safe Stack to get access to its private details:</p>
<pre><code class="language-rust ignore">pub struct Stack&lt;T&gt; {
    head: Link&lt;T&gt;,
}

type Link&lt;T&gt; = Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;;

struct Node&lt;T&gt; {
    elem: T,
    next: Link&lt;T&gt;,
}

impl&lt;T&gt; Stack&lt;T&gt; {
    pub fn new() -&gt; Self {
        Stack { head: None }
    }

    pub fn push(&amp;mut self, elem: T) {
        let new_node = Box::new(Node {
            elem: elem,
            next: self.head.take(),
        });

        self.head = Some(new_node);
    }

    pub fn pop(&amp;mut self) -&gt; Option&lt;T&gt; {
        self.head.take().map(|node| {
            let node = *node;
            self.head = node.next;
            node.elem
        })
    }

    pub fn peek(&amp;self) -&gt; Option&lt;&amp;T&gt; {
        self.head.as_ref().map(|node| {
            &amp;node.elem
        })
    }

    pub fn peek_mut(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt; {
        self.head.as_mut().map(|node| {
            &amp;mut node.elem
        })
    }
}

impl&lt;T&gt; Drop for Stack&lt;T&gt; {
    fn drop(&amp;mut self) {
        let mut cur_link = self.head.take();
        while let Some(mut boxed_node) = cur_link {
            cur_link = boxed_node.next.take();
        }
    }
}
</code></pre>
<p>And just rework <code>push</code> and <code>pop</code> a bit:</p>
<pre><code class="language-rust ignore">pub fn push(&amp;mut self, elem: T) {
    let new_node = Box::new(Node {
        elem: elem,
        next: None,
    });

    self.push_node(new_node);
}

fn push_node(&amp;mut self, mut node: Box&lt;Node&lt;T&gt;&gt;) {
    node.next = self.head.take();
    self.head = Some(node);
}

pub fn pop(&amp;mut self) -&gt; Option&lt;T&gt; {
    self.pop_node().map(|node| {
        node.elem
    })
}

fn pop_node(&amp;mut self) -&gt; Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt; {
    self.head.take().map(|mut node| {
        self.head = node.next.take();
        node
    })
}
</code></pre>
<p>Now we can make our List:</p>
<pre><code class="language-rust ignore">pub struct List&lt;T&gt; {
    left: Stack&lt;T&gt;,
    right: Stack&lt;T&gt;,
}

impl&lt;T&gt; List&lt;T&gt; {
    fn new() -&gt; Self {
        List { left: Stack::new(), right: Stack::new() }
    }
}
</code></pre>
<p>And we can do the usual stuff:</p>
<pre><code class="language-rust ignore">pub fn push_left(&amp;mut self, elem: T) { self.left.push(elem) }
pub fn push_right(&amp;mut self, elem: T) { self.right.push(elem) }
pub fn pop_left(&amp;mut self) -&gt; Option&lt;T&gt; { self.left.pop() }
pub fn pop_right(&amp;mut self) -&gt; Option&lt;T&gt; { self.right.pop() }
pub fn peek_left(&amp;self) -&gt; Option&lt;&amp;T&gt; { self.left.peek() }
pub fn peek_right(&amp;self) -&gt; Option&lt;&amp;T&gt; { self.right.peek() }
pub fn peek_left_mut(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt; { self.left.peek_mut() }
pub fn peek_right_mut(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt; { self.right.peek_mut() }
</code></pre>
<p>But most interestingly, we can walk around!</p>
<pre><code class="language-rust ignore">pub fn go_left(&amp;mut self) -&gt; bool {
    self.left.pop_node().map(|node| {
        self.right.push_node(node);
    }).is_some()
}

pub fn go_right(&amp;mut self) -&gt; bool {
    self.right.pop_node().map(|node| {
        self.left.push_node(node);
    }).is_some()
}
</code></pre>
<p>We return booleans here as just a convenience to indicate whether we actually
managed to move. Now let's test this baby out:</p>
<pre><code class="language-rust ignore">#[cfg(test)]
mod test {
    use super::List;

    #[test]
    fn walk_aboot() {
        let mut list = List::new();             // [_]

        list.push_left(0);                      // [0,_]
        list.push_right(1);                     // [0, _, 1]
        assert_eq!(list.peek_left(), Some(&amp;0));
        assert_eq!(list.peek_right(), Some(&amp;1));

        list.push_left(2);                      // [0, 2, _, 1]
        list.push_left(3);                      // [0, 2, 3, _, 1]
        list.push_right(4);                     // [0, 2, 3, _, 4, 1]

        while list.go_left() {}                 // [_, 0, 2, 3, 4, 1]

        assert_eq!(list.pop_left(), None);
        assert_eq!(list.pop_right(), Some(0));  // [_, 2, 3, 4, 1]
        assert_eq!(list.pop_right(), Some(2));  // [_, 3, 4, 1]

        list.push_left(5);                      // [5, _, 3, 4, 1]
        assert_eq!(list.pop_right(), Some(3));  // [5, _, 4, 1]
        assert_eq!(list.pop_left(), Some(5));   // [_, 4, 1]
        assert_eq!(list.pop_right(), Some(4));  // [_, 1]
        assert_eq!(list.pop_right(), Some(1));  // [_]

        assert_eq!(list.pop_right(), None);
        assert_eq!(list.pop_left(), None);

    }
}
</code></pre>
<pre><code class="language-text">&gt; cargo test

     Running target/debug/lists-5c71138492ad4b4a

running 16 tests
test fifth::test::into_iter ... ok
test fifth::test::basics ... ok
test fifth::test::iter ... ok
test fifth::test::iter_mut ... ok
test fourth::test::into_iter ... ok
test fourth::test::basics ... ok
test fourth::test::peek ... ok
test first::test::basics ... ok
test second::test::into_iter ... ok
test second::test::basics ... ok
test second::test::iter ... ok
test second::test::iter_mut ... ok
test third::test::basics ... ok
test third::test::iter ... ok
test second::test::peek ... ok
test silly1::test::walk_aboot ... ok

test result: ok. 16 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>This is an extreme example of a <em>finger</em> data structure, where we maintain
some kind of finger into the structure, and as a consequence can support
operations on locations in time proportional to the distance from the finger.</p>
<p>We can make very fast changes to the list around our finger, but if we want
to make changes far away from our finger we have to walk all the way over there.
We can permanently walk over there by shifting the elements from one stack to
the other, or we could just walk along the links with an <code>&amp;mut</code>
temporarily to do the changes. However the <code>&amp;mut</code> can never go back up the
list, while our finger can!</p>
<h1><a class="header" href="#the-stack-allocated-linked-list" id="the-stack-allocated-linked-list">The Stack-Allocated Linked List</a></h1>
<p>This book is largely focused on <em>heap-allocated</em> linked lists, because those are the most common and practical, but we don't <em>have</em> to use heap allocation. Heap allocation is nice because it makes it easy to dynamically allocate memory. Stack allocation is less friendly in this regard — things like C's <code>alloca</code> are widely regarded as Very Cursed And Problematic.</p>
<p>So let's allocate memory on the stack the easy way: by calling a function and getting a new stack frame with more space! This is a very silly solution to our problem but also genuinely practical and useful. It's done all the time, potentially without actually even thinking about it as a linked list! </p>
<p>Any time you're doing something recursively, you can just pass a pointer to the current step's state to the next step. If that pointer itself is <em>part</em> of the state, then you've created a linked list that's stack-allocated!</p>
<p>Now of course we're in the <em>silly</em> part of the book so we're going to do this in a silly way: by making the linked list the star and forcing all the user's code to live in a swamp of callbacks. Everybody loves nested callbacks!</p>
<p>Our List type will just be a Node with a reference to another Node:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct List&lt;'a, T&gt; {
    pub data: T,
    pub prev: Option&lt;&amp;'a List&lt;'a, T&gt;&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>And it will have only one operation, <code>push</code>, which will take the old list, the state for the current node, and a callback. The new list will be produced in the callback. We will also let callbacks return any value, which <code>push</code> will return when it completes:</p>
<pre><code class="language-rust ignore">impl&lt;'a, T&gt; List&lt;'a, T&gt; {
    pub fn push&lt;U&gt;(
        prev: Option&lt;&amp;'a List&lt;'a, T&gt;&gt;, 
        data: T, 
        callback: impl FnOnce(&amp;List&lt;'a, T&gt;) -&gt; U,
    ) -&gt; U {
        let list = List { data, prev };
        callback(&amp;list)
    }
}
</code></pre>
<p>That's it! We can use it like this:</p>
<pre><code class="language-rust ignore">List::push(None, 3, |list| {
    println!(&quot;{}&quot;, list.data);
    List::push(Some(list), 5, |list| {
        println!(&quot;{}&quot;, list.data);
        List::push(Some(list), 13, |list| {
            println!(&quot;{}&quot;, list.data);
        })
    })
})
</code></pre>
<p>It's beautiful. 😿</p>
<p>The user can already traverse this list by using while-let to walk over the <code>prev</code> values, but just for fun, let's implement an iterator, which is the usual:</p>
<pre><code class="language-rust ignore">impl&lt;'a, T&gt; List&lt;'a, T&gt; {
    pub fn iter(&amp;'a self) -&gt; Iter&lt;'a, T&gt; {
        Iter { next: Some(self) }
    }
}

impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {
    type Item = &amp;'a T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.next.map(|node| {
            self.next = node.prev;
            &amp;node.data
        })
    }
}
</code></pre>
<p>Let's test it out:</p>
<pre><code class="language-rust ignore">#[cfg(test)]
mod test {
    use super::List;

    #[test]
    fn elegance() {
        List::push(None, 3, |list| {
            assert_eq!(list.iter().copied().sum::&lt;i32&gt;(), 3);
            List::push(Some(list), 5, |list| {
                assert_eq!(list.iter().copied().sum::&lt;i32&gt;(), 5 + 3);
                List::push(Some(list), 13, |list| {
                    assert_eq!(list.iter().copied().sum::&lt;i32&gt;(), 13 + 5 + 3);
                })
            })
        })
    }
}
</code></pre>
<pre><code class="language-text">&gt; cargo test

running 18 tests
test fifth::test::into_iter ... ok
test fifth::test::iter ... ok
test fifth::test::iter_mut ... ok
test fifth::test::basics ... ok
test fifth::test::miri_food ... ok
test first::test::basics ... ok
test second::test::into_iter ... ok
test fourth::test::peek ... ok
test fourth::test::into_iter ... ok
test second::test::iter_mut ... ok
test fourth::test::basics ... ok
test second::test::basics ... ok
test second::test::iter ... ok
test third::test::basics ... ok
test silly1::test::walk_aboot ... ok
test silly2::test::elegance ... ok
test second::test::peek ... ok
test third::test::iter ... ok

test result: ok. 18 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out;
</code></pre>
<p>Now at this point you might be wonder &quot;hey can I mutate the data stored in a node?&quot;. Maybe! Let's try to make the list use mutable references instead of shared ones:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct List&lt;'a, T&gt; {
    pub data: T,
    pub prev: Option&lt;&amp;'a mut List&lt;'a, T&gt;&gt;,
}

pub struct Iter&lt;'a, T&gt; {
    next: Option&lt;&amp;'a List&lt;'a, T&gt;&gt;,
}

impl&lt;'a, T&gt; List&lt;'a, T&gt; {
    pub fn push&lt;U&gt;(
        prev: Option&lt;&amp;'a mut List&lt;'a, T&gt;&gt;, 
        data: T, 
        callback: impl FnOnce(&amp;mut List&lt;'a, T&gt;) -&gt; U,
    ) -&gt; U {
        let mut list = List { data, prev };
        callback(&amp;mut list)
    }

    pub fn iter(&amp;'a self) -&gt; Iter&lt;'a, T&gt; {
        Iter { next: Some(self) }
    }
}

impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {
    type Item = &amp;'a T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.next.map(|node| {
            self.next = node.prev.as_ref().map(|prev| &amp;**prev);
            &amp;node.data
        })
    }
}

<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-text">&gt; cargo test

error[E0521]: borrowed data escapes outside of closure
  --&gt; src\silly2.rs:47:32
   |
46 |  List::push(Some(list), 13, |list| {
   |                              ----
   |                              |
   |              `list` declared here, outside of the closure body
   |              `list` is a reference that is only valid in the closure body
47 |      assert_eq!(list.iter().copied().sum::&lt;i32&gt;(), 13 + 5 + 3);
   |                 ^^^^^^^^^^^ `list` escapes the closure body here

error[E0521]: borrowed data escapes outside of closure
  --&gt; src\silly2.rs:45:28
   |
44 |  List::push(Some(list), 5, |list| {
   |                             ----
   |                             |
   |              `list` declared here, outside of the closure body
   |              `list` is a reference that is only valid in the closure body
45 |      assert_eq!(list.iter().copied().sum::&lt;i32&gt;(), 5 + 3);
   |                 ^^^^^^^^^^^ `list` escapes the closure body here


&lt;ad infinitum&gt;
</code></pre>
<p>Whelp. Seems like it doesn't like our iterator. Maybe we messed that up? Let's
simplify the test a bit to check:</p>
<pre><code class="language-rust ignore">#[test]
fn elegance() {
    List::push(None, 3, |list| {
        assert_eq!(list.data, 3);
        List::push(Some(list), 5, |list| {
            assert_eq!(list.data, 5);
            List::push(Some(list), 13, |list| {
                assert_eq!(list.data, 13);
            })
        })
    })
}
</code></pre>
<pre><code class="language-text">&gt; cargo test

error[E0521]: borrowed data escapes outside of closure
  --&gt; src\silly2.rs:46:17
   |
44 |   List::push(Some(list), 5, |list| {
   |                              ----
   |                              |
   |              `list` declared here, outside of the closure body
   |              `list` is a reference that is only valid in the closure body
45 |       assert_eq!(list.data, 5);
46 | /     List::push(Some(list), 13, |list| {
47 | |         assert_eq!(list.data, 13);
48 | |     })
   | |______^ `list` escapes the closure body here

error[E0521]: borrowed data escapes outside of closure
  --&gt; src\silly2.rs:44:13
   |
42 |   List::push(None, 3, |list| {
   |                        ----
   |                        |
   |              `list` declared here, outside of the closure body
   |              `list` is a reference that is only valid in the closure body
43 |       assert_eq!(list.data, 3);
44 | /     List::push(Some(list), 5, |list| {
45 | |         assert_eq!(list.data, 5);
46 | |         List::push(Some(list), 13, |list| {
47 | |             assert_eq!(list.data, 13);
48 | |         })
49 | |     })
   | |______________^ `list` escapes the closure body here
</code></pre>
<p>Hmm no that's still some hot garbage.</p>
<p>The problem is that our list is accidentally(😉) relying on <em>variance</em>. <a href="https://doc.rust-lang.org/nomicon/subtyping.html">Variance is a complicated subject</a> but let's look at it in simplified terms here:</p>
<p>Each list contains a reference to a List with <em>the exact same type as itself</em>. From the perspective of the inner-most list, that means all lists are using the same lifetime as itself, but this is <em>objectively</em> false: each node in the list lives strictly longer than the next one, because they are literally in nested scopes!</p>
<p>So... why did the code compile when we were using shared references? Because in many cases, the compiler knows it's safe to have something that lives &quot;too long&quot;! When we stuff a reference to a list into the next one, the compiler is quietly &quot;shrinking&quot; down the lifetimes to make them fit what the new list expects. This lifetime shrinking is <em>variance</em>. </p>
<p>It's the exact same trick in languages with inheritance that let's you pass a Cat where an Animal (a supertype of a Cat) is expected. Intuitively we know it's fine to pass a Cat when an Animal is expected because a Cat is just an Animal <em>and more</em>. It's <em>fine</em> to forget the &quot;and more&quot; part for a while, right?</p>
<p>Similarly, a larger lifetime is just a smaller lifetime <em>and more</em>. So it's fine to forget the &quot;and more&quot; here too!</p>
<p>But of course you are now wondering: then why doesn't the mutable reference version work!?</p>
<p>Well, variance <em>isn't</em> always safe. If our code <em>did</em> compile, we could have written a use-after-free like this:</p>
<pre><code class="language-rust ignore">List::push(None, 3, |list| {
    List::push(Some(list), 5, |list| {
        List::push(Some(list), 13, |list| {
            // HAHAHA all the lifetimes are the same, so the compiler will
            // let me rewrite my parent to hold a mutable reference to myself!
            // I will create all the use-after-frees!!
            *list.prev.as_mut().unwrap().prev = Some(list);
        })
    })
})
</code></pre>
<p>The problem with forgetting details is that <em>somewhere else might remember
those details and expect them to remain true</em>. That is a very big problem
once you introduce <em>mutation</em>. If you're not careful, the code that doesn't
remember the &quot;and more&quot; that we threw away might think it's fine to write
things to places that &quot;remember&quot; and <em>expect</em> the &quot;and more&quot; to still be there.</p>
<p>Put in terms of inheritance: this code has to be illegal:</p>
<pre><code class="language-rust ignore">let mut my_kitty = Cat;                  // Make a Cat (long lifetime)
let animal: &amp;mut Animal = &amp;mut my_kitty; // Forget it's a Cat (shorten lifetime)
*animal = Dog;                           // Write a Dog (short lifetime)
my_kitty.meow();                         // Meowing Dog! (Use After Free)
</code></pre>
<p>So while you <em>can</em> shorten the lifetime of a mutable reference, once you start
<em>nesting</em> them things become &quot;invariant&quot; and you're not allowed to shorten
lifetimes anymore. </p>
<p>Specifically <code>&amp;mut &amp;'big mut T</code> cannot be converted to <code>&amp;mut &amp;'small mut T</code>, 
where <code>'big</code> is bigger than <code>'small</code>. Or more formally, <code>&amp;'a mut T</code> is covariant
over <code>'a</code> but invariant over <code>T</code>.</p>
<p>Fun fact: Java actually specifically <em>lets</em> you do this kind of thing, but it
<a href="https://docs.oracle.com/javase/7/docs/api/java/lang/ArrayStoreException.html">does runtime checks to prevent meowing dogs</a>.</p>
<hr />
<p>So what can we do to mutate the data? Use interior mutability! This lets us
tell the compiler that we just want to be able to mutate the <em>data</em> but won't
touch the references.</p>
<p>We can just revert back to the previous version of our code with shared references,
and use <code>Cell</code> in a new test:</p>
<pre><code class="language-rust ignore">#[test]
fn cell() {
    use std::cell::Cell;

    List::push(None, Cell::new(3), |list| {
        List::push(Some(list), Cell::new(5), |list| {
            List::push(Some(list), Cell::new(13), |list| {
                // Multiply every value in the list by 10
                for val in list.iter() {
                    val.set(val.get() * 10)
                }

                let mut vals = list.iter();
                assert_eq!(vals.next().unwrap().get(), 130);
                assert_eq!(vals.next().unwrap().get(), 50);
                assert_eq!(vals.next().unwrap().get(), 30);
                assert_eq!(vals.next(), None);
                assert_eq!(vals.next(), None);
            })
        })
    })
}
</code></pre>
<pre><code class="language-text">&gt; cargo test

running 19 tests
test fifth::test::into_iter ... ok
test fifth::test::basics ... ok
test fifth::test::iter_mut ... ok
test fifth::test::iter ... ok
test fourth::test::basics ... ok
test fourth::test::into_iter ... ok
test second::test::into_iter ... ok
test first::test::basics ... ok
test fourth::test::peek ... ok
test second::test::basics ... ok
test fifth::test::miri_food ... ok
test silly2::test::cell ... ok
test third::test::iter ... ok
test second::test::iter_mut ... ok
test second::test::peek ... ok
test silly1::test::walk_aboot ... ok
test silly2::test::elegance ... ok
test third::test::basics ... ok
test second::test::iter ... ok

test result: ok. 19 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out;
</code></pre>
<p>Easy as recursive pie! ✨</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
